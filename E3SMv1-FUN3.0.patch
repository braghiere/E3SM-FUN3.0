diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/AllocationMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/AllocationMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/AllocationMod.F90	2020-06-10 13:56:35.013392274 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/AllocationMod.F90	2020-07-30 20:38:47.951609989 -0400
@@ -9,7 +9,7 @@
   use shr_kind_mod        , only : r8 => shr_kind_r8
   use shr_log_mod         , only : errMsg => shr_log_errMsg
   use clm_varcon          , only : dzsoi_decomp
-  use clm_varctl          , only : use_c13, use_c14, use_nitrif_denitrif, spinup_state
+  use clm_varctl          , only : use_c13, use_c14, use_nitrif_denitrif, spinup_state, use_fun, use_funp
   use clm_varctl          , only : nyears_ad_carbon_only
   use abortutils          , only : endrun
   use decompMod           , only : bounds_type
@@ -41,6 +41,14 @@
   use WaterStateType      , only : waterstate_type
   use clm_varctl          , only : NFIX_PTASE_plant
 
+  ! used variables for FUN
+  use SoilHydrologyType   , only : soilhydrology_type
+  use TemperatureType     , only : temperature_type
+  use WaterFluxType       , only : waterflux_type
+  use perf_mod            , only : t_startf, t_stopf
+  use CNFUNMod            , only : CNFUN, CNFUNInit
+  use subgridAveMod       , only : p2c_2d
+  !
   !
   implicit none
   save
@@ -330,6 +338,7 @@
 !     !!  add phosphorus  -X.YANG
     type(phosphorusstate_type) , intent(inout) :: phosphorusstate_vars
     type(phosphorusflux_type)  , intent(inout) :: phosphorusflux_vars
+
     !
     ! !LOCAL VARIABLES:
     real(r8) :: compet_decomp_no3      ! (unitless) relative competitiveness of immobilizers for NO3 for BGC module
@@ -651,10 +660,15 @@
          smin_no3_to_plant_patch      => veg_nf%smin_no3_to_plant             , &
          sminn_to_plant_patch         => veg_nf%sminn_to_plant                , &
          pnup_pfrootc                 => veg_ns%pnup_pfrootc                 , &
-         leafn                        => veg_ns%leafn                          &
+         leafn                        => veg_ns%leafn                        ,  &
+         stress_decid                 =>   veg_vp%stress_decid                 ,  &           ! Input:   binary flag for stress
+          season_decid                => veg_vp%season_decid                 ,  & ! Input:   binary flag for seasonal 
+         ! -deciduous leaf habit (0 or 1)
+          perecm                      =>     veg_vp%perecm                     & ! Input:   binary flag for seasonal 
+         ! -deciduous leaf habit (0 or 1)
+                          
          )
 
-
       sminp_to_plant_patch         => veg_pf%sminp_to_plant
       secondp_vr                   => col_ps%secondp_vr
       leafp                        => veg_ps%leafp
@@ -681,6 +695,8 @@
       plant_n_uptake_flux          => col_nf%plant_n_uptake_flux
       plant_p_uptake_flux          => col_pf%plant_p_uptake_flux
 
+      
+
       ! set time steps
       dt = real( get_step_size(), r8 )
 
@@ -741,6 +757,8 @@
          ! carbon flux available for allocation
          availc(p) = gpp(p) - mr
 
+
+
          ! new code added for isotope calculations, 7/1/05, PET
          ! If mr > gpp, then some mr comes from gpp, the rest comes from
          ! cpool (xsmr)
@@ -783,6 +801,8 @@
             cpool_to_xsmrpool(p) = xsmrpool_recover(p)
          end if
 
+
+
          f1 = froot_leaf(ivt(p))
          f2 = croot_stem(ivt(p))
 
@@ -908,6 +928,7 @@
 
                   if (ivt(p) /= nsoybean .or. astem(p) == astemf(ivt(p)) .or. peaklai(p) == 1._r8) then
                      if (grain_flag(p) == 0._r8) then
+                       if(.not.use_fun) then
                         t1 = 1 / dt
                         leafn_to_retransn(p) = t1 * ((leafc(p) / leafcn(ivt(p))) - (leafc(p) / &
                              fleafcn(ivt(p))))
@@ -918,6 +939,14 @@
                            frootn_to_retransn(p) = t1 * ((frootc(p) / frootcn(ivt(p))) - (frootc(p) / &
                                 ffrootcn(ivt(p))))
                         end if
+                       else !leafn retrans flux is handled in phenology
+                       frootn_to_retransn(p) = 0._r8
+                       livestemn_to_retransn(p) = 0._r8 
+                       !if(use_funp)then
+                       !  frootp_to_retransp(p) = 0._r8
+                       !  livestemp_to_retransp(p) = 0._r8 
+                       !end if
+                       end if !fun
                         grain_flag(p) = 1._r8
                      end if
                   end if
@@ -948,6 +977,7 @@
          ! determine N requirements
          ! determine P requirements   -X. YANG
 
+        if(.not.use_fun)then
          if (woody(ivt(p)) == 1.0_r8) then
             c_allometry(p) = (1._r8+g1)*(1._r8+f1+f3*(1._r8+f2))
             n_allometry(p) = 1._r8/cnl + f1/cnfr + (f3*f4*(1._r8+f2))/cnlw + &
@@ -969,6 +999,30 @@
             n_allometry(p) = 1._r8/cnl + f1/cnfr
             p_allometry(p) = 1._r8/cpl + f1/cpfr
          end if
+       else !no FUN. 
+	    if (woody(ivt(p)) == 1.0_r8) then
+	       c_allometry(p) = (1._r8)*(1._r8+f1+f3*(1._r8+f2))
+	       n_allometry(p) = 1._r8/cnl + f1/cnfr + (f3*f4*(1._r8+f2))/cnlw + &
+	            (f3*(1._r8-f4)*(1._r8+f2))/cndw
+               p_allometry(p) = 1._r8/cpl + f1/cpfr + (f3*f4*(1._r8+f2))/cplw + &
+                 (f3*(1._r8-f4)*(1._r8+f2))/cpdw
+
+	    else if (ivt(p) >= npcropmin) then ! skip generic crops
+	       cng = graincn(ivt(p))
+               cpg = graincp(ivt(p))
+	       c_allometry(p) = (1._r8)*(1._r8+f1+f5+f3*(1._r8+f2))
+	       n_allometry(p) = 1._r8/cnl + f1/cnfr + f5/cng + (f3*f4*(1._r8+f2))/cnlw + &
+	            (f3*(1._r8-f4)*(1._r8+f2))/cndw
+               p_allometry(p) = 1._r8/cpl + f1/cpfr + f5/cpg + (f3*f4*(1._r8+f2))/cplw + &
+                 (f3*(1._r8-f4)*(1._r8+f2))/cpdw
+	    else
+	       c_allometry(p) = 1._r8+f1
+	       n_allometry(p) = 1._r8/cnl + f1/cnfr
+               p_allometry(p) = 1._r8/cpl + f1/cpfr
+	    end if
+         end if !use_fun
+
+
          plant_ndemand(p) = availc(p)*(n_allometry(p)/c_allometry(p))
          plant_pdemand(p) = availc(p)*(p_allometry(p)/c_allometry(p))
 
@@ -985,6 +1039,8 @@
          !              retransn pool has N from leaves, stems, and roots for
          !              retranslocation
 
+     if(.not.use_fun)then
+
          if (ivt(p) >= npcropmin .and. grain_flag(p) == 1._r8) then
             avail_retransn(p) = plant_ndemand(p)
             avail_retransp(p) = plant_pdemand(p)
@@ -1011,16 +1067,29 @@
             retransn_to_npool(p) = plant_ndemand(p)
          end if
 
+         if ( .not. use_fun ) then
          plant_ndemand(p) = plant_ndemand(p) - retransn_to_npool(p)
+         else
+	       if (season_decid(ivt(p)) == 1._r8.or.stress_decid(ivt(p))==1._r8) then
+	          plant_ndemand(p) = plant_ndemand(p) - retransn_to_npool(p)
+	       end if
+	    end if
 
          if (plant_pdemand(p) > avail_retransp(p)) then
             retransp_to_ppool(p) = avail_retransp(p)
          else
             retransp_to_ppool(p) = plant_pdemand(p)
          end if
-         plant_pdemand(p) = plant_pdemand(p) - retransp_to_ppool(p)
 
+         if ( .not. use_funp ) then
+         plant_pdemand(p) = plant_pdemand(p) - retransp_to_ppool(p)
+         else
+	       if (season_decid(ivt(p)) == 1._r8.or.stress_decid(ivt(p))==1._r8) then
+	          plant_pdemand(p) = plant_pdemand(p) - retransp_to_ppool(p)
+	       end if
+	    end if
 
+        end if !use_fun
       end do ! end pft loop
 
       ! now use the p2c routine to get the column-averaged plant_ndemand
@@ -1068,9 +1137,14 @@
                             num_soilp, filter_soilp                         , &
                             cnstate_vars                                    , &
                             carbonstate_vars, carbonflux_vars               , &
+ c13_carbonflux_vars, c14_carbonflux_vars            , &
                             nitrogenstate_vars, nitrogenflux_vars           , &
                             phosphorusstate_vars,phosphorusflux_vars        , &
-                            soilstate_vars,waterstate_vars)
+                            soilstate_vars,waterstate_vars, &
+       crop_vars, &
+        soilhydrology_vars, temperature_vars, waterflux_vars, &
+       canopystate_vars)
+
     ! PHASE-2 of Allocation:  resolving N/P limitation
     ! !USES:
     use shr_sys_mod      , only: shr_sys_flush
@@ -1102,6 +1176,18 @@
 
     type(soilstate_type)     , intent(in)    :: soilstate_vars
     type(waterstate_type)    , intent(in)    :: waterstate_vars
+
+     !! add varibles needed for FUN
+    type(crop_type)          , intent(inout) :: crop_vars
+    type(carbonflux_type)    , intent(inout) :: c13_carbonflux_vars
+    type(carbonflux_type)    , intent(inout) :: c14_carbonflux_vars
+    type(soilhydrology_type) , intent(in)    :: soilhydrology_vars
+    type(temperature_type)   , intent(in)    :: temperature_vars
+    type(waterflux_type)     , intent(in)    :: waterflux_vars
+    type(canopystate_type)   , intent(in)    :: canopystate_vars
+
+
+
     !
     ! !LOCAL VARIABLES:
     real(r8) :: sum_pdemand_scaled(bounds%begc:bounds%endc,1:nlevdecomp)  ! sum of total P demand, scaled with relative competitiveness
@@ -1167,6 +1253,9 @@
     real(r8):: solution_pconc(bounds%begc:bounds%endc, 1:nlevdecomp)
     real(r8):: cn_stoich_var=0.2    ! variability of CN ratio
     real(r8):: cp_stoich_var=0.4    ! variability of CP ratio
+
+    real(r8) :: sminn_to_plant_new(bounds%begc:bounds%endc)
+    real(r8) :: sminp_to_plant_new(bounds%begc:bounds%endc)
     !-----------------------------------------------------------------------
 
     associate(                                                                                 &
@@ -1306,9 +1395,19 @@
          leafn_storage                => veg_ns%leafn_storage              , &
          leafn_xfer                   => veg_ns%leafn_xfer                 , &
          leafp_storage                => veg_ps%leafp_storage            , &
-         leafp_xfer                   => veg_ps%leafp_xfer                 &
+         leafp_xfer                   => veg_ps%leafp_xfer               , &
+         
+         sminn_to_plant_fun_vr        => col_nf%sminn_to_plant_fun_vr            , & ! Output: 
+           sminn_to_plant_fun_no3_vr        => col_nf%sminn_to_plant_fun_no3_vr            , & ! Output:
+         sminn_to_plant_fun_nh4_vr        => col_nf%sminn_to_plant_fun_nh4_vr            , & ! Output:
+         sminp_to_plant_fun_vr        => col_pf%sminp_to_plant_fun_vr            & ! Output:
+         !  [real(r8) (:) ]  Total layer soil P uptake of FUN (gP/m2
+         !  /s)           
          )
 
+      sminn_to_plant_new(bounds%begc:bounds%endc)  =  0._r8
+      sminp_to_plant_new(bounds%begc:bounds%endc)  =  0._r8
+
       ! set time steps
       dt = real( get_step_size(), r8 )
 
@@ -1321,6 +1420,7 @@
             col_plant_pdemand(c) = plant_pdemand_col(c)
          end do
 
+
          ! Starting resolving N/P limitation
          ! calculate nuptake & puptake profile
          call calc_nuptake_prof(bounds, num_soilc, filter_soilc, cnstate_vars, nitrogenstate_vars, nuptake_prof)
@@ -1335,668 +1435,6 @@
       ! (2) nitrogen and phosphorus uptake is based on root kinetics
       ! (3) no second pass nutrient uptake for plants
       ! ============================================================= 
-      if (.not. use_nitrif_denitrif) then
-         
-         if (nu_com .eq. 'RD') then ! 'RD' : relative demand approach
-
-            ! column loops to resolve plant/heterotroph competition for mineral N
-            ! init sminn_tot
-            do j = 1, nlevdecomp
-               do fc=1,num_soilc
-                  c = filter_soilc(fc)
-                  sum_ndemand_vr(c,j) = col_plant_ndemand(c) * nuptake_prof(c,j) + potential_immob_vr(c,j)
-                  sum_pdemand_vr(c,j) = col_plant_pdemand(c) * puptake_prof(c,j) + potential_immob_p_vr(c,j)
-               end do
-            end do
-            
-            do j = 1, nlevdecomp
-               do fc=1,num_soilc
-                  c = filter_soilc(fc)      
-                  l = col_pp%landunit(c)
-                  if (sum_ndemand_vr(c,j)*dt < sminn_vr(c,j)) then
-
-                     ! N availability is not limiting immobilization or plant
-                     ! uptake, and both can proceed at their potential rates
-                     nlimit(c,j) = 0
-                     fpi_vr(c,j) = 1.0_r8
-                     actual_immob_vr(c,j) = potential_immob_vr(c,j)
-                     sminn_to_plant_vr(c,j) = col_plant_ndemand(c) * nuptake_prof(c,j)
-                  else if ( cnallocate_carbon_only() .or. cnallocate_carbonphosphorus_only() ) then !.or. &
-                     !                (crop_supln .and. (lun_pp%itype(l) == istcrop) .and. &
-                     !                (ivt(col_pp%pfti(c)) >= npcropmin)) )then
-                     ! this code block controls the addition of N to sminn pool
-                     ! to eliminate any N limitation, when Carbon_Only is set.  This lets the
-                     ! model behave essentially as a carbon-only model, but with the
-                     ! benefit of keeping track of the N additions needed to
-                     ! eliminate N limitations, so there is still a diagnostic quantity
-                     ! that describes the degree of N limitation at steady-state.
-
-                     nlimit(c,j) = 1
-                     fpi_vr(c,j) = 1.0_r8
-                     actual_immob_vr(c,j) = potential_immob_vr(c,j)
-                     sminn_to_plant_vr(c,j) =  col_plant_ndemand(c) * nuptake_prof(c,j)
-                     supplement_to_sminn_vr(c,j) = sum_ndemand_vr(c,j) - (sminn_vr(c,j)/dt)
-                  else
-                     ! N availability can not satisfy the sum of immobilization and
-                     ! plant growth demands, so these two demands compete for available
-                     ! soil mineral N resource.
-
-                     nlimit(c,j) = 1
-                     if (sum_ndemand_vr(c,j) > 0.0_r8 .and. sminn_vr(c,j) > 0.0_r8) then
-                        actual_immob_vr(c,j) = (sminn_vr(c,j)/dt)*(potential_immob_vr(c,j) / sum_ndemand_vr(c,j))
-                     else
-                        actual_immob_vr(c,j) = 0.0_r8
-                     end if
-
-                     if (potential_immob_vr(c,j) > 0.0_r8) then
-                        fpi_vr(c,j) = actual_immob_vr(c,j) / potential_immob_vr(c,j)
-                     else
-                        fpi_vr(c,j) = 1.0_r8
-                     end if
-
-                     sminn_to_plant_vr(c,j) = (sminn_vr(c,j)/dt) - actual_immob_vr(c,j)
-                  end if
-               end do
-            end do
-
-         else ! ECA mode or MIC outcompete plant mode
-
-            do j = 1, nlevdecomp  
-               do fc=1,num_soilc
-                  c = filter_soilc(fc)
-                  ! plant, microbial decomposer compete for N
-                  ! loop over each pft within the same column
-                  ! calculate competition coefficients for N/P
-                  ! first need to convert concentration to per soil water based
-                  ! 2.76 consider soil adsorption effect on [NH4+] availability, based on Zhu et al., 2016 DOI: 10.1002/2016JG003554
-                  solution_nh4conc(c,j) = sminn_vr(c,j) / (bd(c,j)*2.76 + h2osoi_vol(c,j)) ! convert to per soil water based
-                  e_km_n = 0._r8
-                  decompmicc(c,j) = 0.0_r8
-                  do p = col_pp%pfti(c), col_pp%pftf(c)
-                     if (veg_pp%active(p).and. (veg_pp%itype(p) .ne. noveg)) then
-                        e_km_n = e_km_n + e_plant_scalar*frootc(p)*froot_prof(p,j)*veg_pp%wtcol(p)/km_plant_nh4(ivt(p))
-                        decompmicc(c,j) = decompmicc(c,j) + decompmicc_patch_vr(ivt(p),j)*veg_pp%wtcol(p)
-                     end if
-                  end do
-                  e_km_n = e_km_n + e_decomp_scalar*decompmicc(c,j)*(1._r8/km_decomp_nh4 )
-                  do p = col_pp%pfti(c), col_pp%pftf(c)
-                     if (veg_pp%active(p).and. (veg_pp%itype(p) .ne. noveg)) then
-                        compet_plant_n(p) = solution_nh4conc(c,j) / ( km_plant_nh4(ivt(p)) * (1 + &
-                             solution_nh4conc(c,j)/km_plant_nh4(ivt(p)) + e_km_n))
-                     else
-                        compet_plant_n(p) = 0.0_r8
-                     end if
-                  end do
-                  compet_decomp_n = solution_nh4conc(c,j) / (km_decomp_nh4 * (1 + solution_nh4conc(c,j)/km_decomp_nh4 + e_km_n))
-
-                  ! relative demand approach: root nutrient uptake profile is based on nutrient concentration profile
-                  ! nu_com with ECA or MIC: root nutrient uptake profile is based on fine root density profile
-                  col_plant_ndemand_vr(c,j) = 0._r8
-                  do p = col_pp%pfti(c), col_pp%pftf(c)
-                     if (veg_pp%active(p).and. (veg_pp%itype(p) .ne. noveg)) then
-                        ! scaling factor based on  CN ratio flexibility
-                        if (cnallocate_carbonphosphorus_only() .or. cnallocate_carbon_only()) then
-                            cn_scalar(p) = 0.0_r8 
-                        else
-                            cn_scalar(p) = min(max(((leafc(p) + leafc_storage(p) + leafc_xfer(p))/ &
-                                                   max(leafn(p) + leafn_storage(p) + leafn_xfer(p), 1e-20_r8) - &
-                                                   leafcn(ivt(p))*(1- cn_stoich_var)) / &
-                                                   (leafcn(ivt(p)) - leafcn(ivt(p))*(1- cn_stoich_var)),0.0_r8),1.0_r8)
-                        endif
-                        plant_ndemand_vr_patch(p,j) = vmax_plant_nh4(ivt(p))* frootc(p) * &
-                             froot_prof(p,j) * cn_scalar(p) * t_scalar(c,j) *  compet_plant_n(p) 
-
-                        plant_ndemand_vr_patch(p,j) = max(plant_ndemand_vr_patch(p,j), 0.0_r8)
-                        col_plant_ndemand_vr(c,j) = col_plant_ndemand_vr(c,j) + plant_ndemand_vr_patch(p,j)*veg_pp%wtcol(p)
-                     else
-                        cn_scalar(p) = 0.0_r8
-                        plant_ndemand_vr_patch(p,j) = 0.0_r8
-                     end if
-                  end do
-
-                  !  compete for nitrogen
-                  sum_ndemand_vr(c,j) = col_plant_ndemand_vr(c,j) + potential_immob_vr(c,j)
-                  if (nu_com .eq. 'ECA') then ! 'ECA' mode
-                     sum_ndemand_scaled(c,j) = col_plant_ndemand_vr(c,j) + &
-                          potential_immob_vr(c,j)*compet_decomp_n
-                  else ! 'MIC' mode
-                     sum_ndemand_scaled(c,j) = potential_immob_vr(c,j)*compet_decomp_n
-                  end if
-                  if (sum_ndemand_vr(c,j)*dt < sminn_vr(c,j)) then
-                     ! N availability is not limiting immobilization or plant
-                     ! uptake, and all can proceed at their potential rates
-                     nlimit(c,j) = 0
-                     fpi_vr(c,j) = 1.0_r8
-                     actual_immob_vr(c,j) = potential_immob_vr(c,j)
-                     sminn_to_plant_vr(c,j) = col_plant_ndemand_vr(c,j)
-                  else if ( cnallocate_carbon_only() .or. cnallocate_carbonphosphorus_only() ) then !.or. &
-                     !                (crop_supln .and. (lun_pp%itype(l) == istcrop) .and. &
-                     !                (ivt(col_pp%pfti(c)) >= npcropmin)) )then
-                     ! this code block controls the addition of N to sminn pool
-                     ! to eliminate any N limitation, when Carbon_Only is set.  This lets the
-                     ! model behave essentially as a carbon-only model, but with the
-                     ! benefit of keeping track of the N additions needed to
-                     ! eliminate N limitations, so there is still a diagnostic quantity
-                     ! that describes the degree of N limitation at steady-state.
-                     nlimit(c,j) = 1
-                     fpi_vr(c,j) = 1.0_r8
-                     actual_immob_vr(c,j) = potential_immob_vr(c,j)
-                     sminn_to_plant_vr(c,j) =  col_plant_ndemand_vr(c,j)
-                     supplement_to_sminn_vr(c,j) = sum_ndemand_vr(c,j) - (sminn_vr(c,j)/dt)
-                  else
-                     ! N availability can not satisfy the sum of immobilization, nitrification, and
-                     ! plant growth demands, so these three demands compete for available
-                     ! soil mineral NH4 resource.
-                     nlimit(c,j) = 1
-                     if (sum_ndemand_vr(c,j) > 0.0_r8 .and. sminn_vr(c,j) > 0.0_r8 .and. sum_ndemand_scaled(c,j) > 0.0 ) then
-                        actual_immob_vr(c,j) = min((sminn_vr(c,j)/dt)*(potential_immob_vr(c,j)* &
-                             compet_decomp_n / sum_ndemand_scaled(c,j)), potential_immob_vr(c,j))
-                        if (nu_com .eq. 'ECA') sminn_to_plant_vr(c,j) = min((sminn_vr(c,j)/dt)* &
-                             (col_plant_ndemand_vr(c,j)/sum_ndemand_scaled(c,j)), col_plant_ndemand_vr(c,j))
-                     else
-                        actual_immob_vr(c,j) = 0.0_r8
-                        sminn_to_plant_vr(c,j) = 0.0_r8
-                     end if
-                     if (potential_immob_vr(c,j) > 0.0_r8) then
-                        fpi_vr(c,j) = actual_immob_vr(c,j) / potential_immob_vr(c,j)
-                     else
-                        fpi_vr(c,j) = 1.0_r8
-                     end if
-                     if (nu_com .eq. 'MIC') sminn_to_plant_vr(c,j) = min( max( 0._r8, &
-                                                (sminn_vr(c,j)/dt) - actual_immob_vr(c,j)) , col_plant_ndemand_vr(c,j))
-                  end if
-               end do
-            end do
-         end if ! end of N competition
-
-         ! add phosphorus           
-         if (nu_com .eq. 'RD') then ! 'RD' : relative demand approach
-            do j = 1, nlevdecomp
-               do fc=1,num_soilc
-                  c = filter_soilc(fc)
-                  l = col_pp%landunit(c)
-                  if (sum_pdemand_vr(c,j)*dt < solutionp_vr(c,j)) then
-
-                     ! P availability is not limiting immobilization or plant
-                     ! uptake, and both can proceed at their potential rates
-                     plimit(c,j) = 0
-                     fpi_p_vr(c,j) = 1.0_r8
-                     actual_immob_p_vr(c,j) = potential_immob_p_vr(c,j)
-                     sminp_to_plant_vr(c,j) = col_plant_pdemand(c) * puptake_prof(c,j)
-
-                  else if ( cnallocate_carbon_only() .or. cnallocate_carbonnitrogen_only() ) then !.or. &
-
-                     plimit(c,j) = 1
-                     fpi_p_vr(c,j) = 1.0_r8
-                     actual_immob_p_vr(c,j) = potential_immob_p_vr(c,j)
-                     sminp_to_plant_vr(c,j) =  col_plant_pdemand(c) * puptake_prof(c,j)
-                     supplement_to_sminp_vr(c,j) = sum_pdemand_vr(c,j) - (solutionp_vr(c,j)/dt)
-
-                  else
-                     ! P availability can not satisfy the sum of immobilization and
-                     ! plant growth demands, so these two demands compete for
-                     ! available soil mineral solution P resource.
-
-                     plimit(c,j) = 1
-                     if (sum_pdemand_vr(c,j) > 0.0_r8 .and. solutionp_vr(c,j) >0._r8) then
-                        actual_immob_p_vr(c,j) = (solutionp_vr(c,j)/dt)*(potential_immob_p_vr(c,j) / sum_pdemand_vr(c,j))
-                     else
-                        actual_immob_p_vr(c,j) = 0.0_r8
-                     end if
-
-                     if (potential_immob_p_vr(c,j) > 0.0_r8) then
-                        fpi_p_vr(c,j) = actual_immob_p_vr(c,j) / potential_immob_p_vr(c,j)
-                     else
-                        fpi_p_vr(c,j) = 1.0_r8
-                     end if
-
-                     sminp_to_plant_vr(c,j) = max( 0._r8,(solutionp_vr(c,j)/dt) - actual_immob_p_vr(c,j) ) 
-                  end if
-               end do
-            end do
-         else ! ECA mode or MIC outcompete plant mode
-            do j = 1, nlevdecomp  
-               do fc=1,num_soilc
-                  c = filter_soilc(fc)
-
-                  ! ECA and MIC mode assume mineral surface adsorption flux is a potential competitor of solution P
-                  ! assume solutionP - labileP not equilibrate within 30 min, due to instantaneous
-                  ! plant P uptake, microbial P uptake/release
-                  ! secondary P desorption is assumed to go into solution P pool
-
-                  ! potential adsorption rate without plant and microbial interaction
-                  ! including weathering, deposition, phosphatase, mineralization, immobilization, plant uptake
-                  dsolutionp_dt(c,j) = gross_pmin_vr(c,j) -potential_immob_p_vr(c,j) - &
-                       col_plant_pdemand_vr(c,j) + biochem_pmin_vr_col(c,j) + &
-                       primp_to_labilep_vr_col(c,j) + pdep_to_sminp(c) *ndep_prof(c,j)
-                  adsorb_to_labilep_vr(c,j) = (vmax_minsurf_p_vr(isoilorder(c),j)* km_minsurf_p_vr(isoilorder(c),j)) / &
-                       ((km_minsurf_p_vr(isoilorder(c),j)+max(solutionp_vr(c,j),0._r8))**2._r8 ) * dsolutionp_dt(c,j)
-                  ! sign convention: if adsorb_to_labilep_vr(c,j) < 0, then it's desorption
-                  if (adsorb_to_labilep_vr(c,j) >= 0) then
-                     adsorb_to_labilep_vr(c,j) = max(min(adsorb_to_labilep_vr(c,j), &
-                          (vmax_minsurf_p_vr(isoilorder(c),j) - labilep_vr(c,j))/dt),0.0_r8)
-                     desorb_to_solutionp_vr(c,j) = 0.0_r8
-                  else
-                     desorb_to_solutionp_vr(c,j) = min(-1.0*adsorb_to_labilep_vr(c,j), labilep_vr(c,j)/dt)
-                     adsorb_to_labilep_vr(c,j) = 0.0_r8
-                  end if
-
-                  ! plant, microbial decomposer, mineral surface compete for P
-                  ! loop over each pft within the same column
-                  ! calculate competition coefficients for N/P
-                  solution_pconc(c,j) = solutionp_vr(c,j)/h2osoi_vol(c,j) ! convert to per soil water based
-                  solution_pconc(c,j) = max(solution_pconc(c,j), 0._r8)
-                  e_km_p = 0._r8
-                  decompmicc(c,j) = 0.0_r8
-                  do p = col_pp%pfti(c), col_pp%pftf(c)
-                     if (veg_pp%active(p).and. (veg_pp%itype(p) .ne. noveg)) then
-                        e_km_p = e_km_p + e_plant_scalar*frootc(p)*froot_prof(p,j)*veg_pp%wtcol(p)/km_plant_p(ivt(p))
-                        decompmicc(c,j) = decompmicc(c,j) + decompmicc_patch_vr(ivt(p),j)*veg_pp%wtcol(p)
-                     end if
-                  end do
-                  e_km_p = e_km_p + e_decomp_scalar*decompmicc(c,j)/km_decomp_p + &
-                       max(0._r8,vmax_minsurf_p_vr(isoilorder(c),j)-labilep_vr(c,j))/km_minsurf_p_vr(isoilorder(c),j)
-                  do p = col_pp%pfti(c), col_pp%pftf(c)
-                     if (veg_pp%active(p).and. (veg_pp%itype(p) .ne. noveg)) then
-                        compet_plant_p(p) = solution_pconc(c,j) / ( km_plant_p(ivt(p)) * (1 + &
-                             solution_pconc(c,j)/km_plant_p(ivt(p)) + e_km_p))
-                     else
-                        compet_plant_p(p) = 0.0_r8
-                     end if
-                  end do
-                  compet_decomp_p = solution_pconc(c,j) / (km_decomp_p * (1 + solution_pconc(c,j)/km_decomp_p + e_km_p))
-                  compet_minsurf_p = solution_pconc(c,j) / (km_minsurf_p_vr(isoilorder(c),j) * &
-                       (1 + solution_pconc(c,j)/km_minsurf_p_vr(isoilorder(c),j) + e_km_p))
-
-                  ! relative demand approach: root nutrient uptake profile is based on nutrient concentration profile
-                  ! nu_com with ECA or MIC: root nutrient uptake profile is based on fine root density profile
-                  col_plant_pdemand_vr(c,j) = 0._r8
-                  do p = col_pp%pfti(c), col_pp%pftf(c)
-                     if (veg_pp%active(p).and. (veg_pp%itype(p) .ne. noveg)) then
-                        ! scaling factor based on  CP ratio flexibility
-                        if (cnallocate_carbonnitrogen_only() .or. cnallocate_carbon_only()) then
-                            cp_scalar(p) = 0.0_r8
-                        else
-                            cp_scalar(p) = min(max(((leafc(p) + leafc_storage(p) + leafc_xfer(p)) / &
-                                                  max(leafp(p) + leafp_storage(p) + leafp_xfer(p), 1e-20_r8) - &
-                                                  leafcp(ivt(p))*(1- cp_stoich_var)) / &
-                                                  (leafcp(ivt(p)) - leafcp(ivt(p))*(1- cp_stoich_var)),0.0_r8),1.0_r8)
-                        endif
-
-                        plant_pdemand_vr_patch(p,j) = vmax_plant_p(ivt(p)) * frootc(p) * froot_prof(p,j) * &
-                             cp_scalar(p) * t_scalar(c,j) * compet_plant_p(p)
-                        plant_pdemand_vr_patch(p,j) = max(plant_pdemand_vr_patch(p,j),0.0_r8)
-                        col_plant_pdemand_vr(c,j) = col_plant_pdemand_vr(c,j) + plant_pdemand_vr_patch(p,j)*veg_pp%wtcol(p)
-                     else
-                        cp_scalar(p) = 0.0_r8
-                        plant_pdemand_vr_patch(p,j) = 0.0_r8
-                     end if
-                  end do
-
-                  ! compete for phosphorus
-                  sum_pdemand_vr(c,j) = col_plant_pdemand_vr(c,j) + potential_immob_p_vr(c,j) + adsorb_to_labilep_vr(c,j)
-                  if (nu_com .eq. 'ECA') then ! ECA mode
-                     sum_pdemand_scaled(c,j) = col_plant_pdemand_vr(c,j) + potential_immob_p_vr(c,j)*compet_decomp_p + &
-                          adsorb_to_labilep_vr(c,j)*compet_minsurf_p
-                  else ! 'MIC' mode
-                     sum_pdemand_scaled(c,j) = potential_immob_p_vr(c,j)*compet_decomp_p + &
-                          adsorb_to_labilep_vr(c,j)*compet_minsurf_p
-                  end if
-                  if (sum_pdemand_vr(c,j)*dt < solutionp_vr(c,j)) then
-                     ! P availability is not limiting immobilization or plant
-                     ! uptake, and both can proceed at their potential rates
-                     plimit(c,j) = 0
-                     fpi_p_vr(c,j) = 1.0_r8
-                     actual_immob_p_vr(c,j) = potential_immob_p_vr(c,j)
-                     sminp_to_plant_vr(c,j) = col_plant_pdemand_vr(c,j)
-                     adsorb_to_labilep_vr(c,j) = adsorb_to_labilep_vr(c,j)
-                  else if ( cnallocate_carbon_only() .or. cnallocate_carbonnitrogen_only() ) then !.or. &
-                     plimit(c,j) = 1
-                     fpi_p_vr(c,j) = 1.0_r8
-                     actual_immob_p_vr(c,j) = potential_immob_p_vr(c,j)
-                     sminp_to_plant_vr(c,j) =  col_plant_pdemand_vr(c,j)
-                     adsorb_to_labilep_vr(c,j) = adsorb_to_labilep_vr(c,j)
-                     supplement_to_sminp_vr(c,j) = sum_pdemand_vr(c,j) - solutionp_vr(c,j)/dt
-                     
-                  else
-                     ! P availability can not satisfy the sum of immobilization and
-                     ! plant growth demands, so these two demands compete for
-                     ! available soil mineral solution P resource.
-                     plimit(c,j) = 1
-                     if (sum_pdemand_vr(c,j) > 0.0_r8 .and. solutionp_vr(c,j) >0._r8 .and. sum_pdemand_scaled(c,j) > 0.0) then
-                        if (nu_com .eq. 'ECA') sminp_to_plant_vr(c,j) = min(solutionp_vr(c,j)/dt * &
-                             col_plant_pdemand_vr(c,j)/ sum_pdemand_scaled(c,j),col_plant_pdemand_vr(c,j))
-                        actual_immob_p_vr(c,j) = min(solutionp_vr(c,j)/dt * potential_immob_p_vr(c,j) * compet_decomp_p /&
-                             sum_pdemand_scaled(c,j), potential_immob_p_vr(c,j))
-                        adsorb_to_labilep_vr(c,j) = min(solutionp_vr(c,j)/dt * adsorb_to_labilep_vr(c,j) * compet_minsurf_p /&
-                             sum_pdemand_scaled(c,j), adsorb_to_labilep_vr(c,j))
-                     else
-                        sminp_to_plant_vr(c,j) = 0.0_r8
-                        actual_immob_p_vr(c,j) = 0.0_r8
-                        adsorb_to_labilep_vr(c,j) = 0.0_r8
-                     end if
-                     if (potential_immob_p_vr(c,j) > 0.0_r8) then
-                        fpi_p_vr(c,j) = actual_immob_p_vr(c,j) / potential_immob_p_vr(c,j)
-                     else
-                        fpi_p_vr(c,j) = 1.0_r8
-                     end if
-
-                     if (nu_com .eq. 'MIC') sminp_to_plant_vr(c,j) = min(max( 0._r8, &
-                                            (solutionp_vr(c,j)/dt) - actual_immob_p_vr(c,j) - adsorb_to_labilep_vr(c,j) ), &
-                                            col_plant_pdemand_vr(c,j)) 
-                  end if
-
-               end do
-            end do
-         end if ! end of P competition
-
-         !!!  resolving N limitation vs. P limitation for decomposition
-         !!!  update (1) actual immobilization for N and P (2) sminn_to_plant and sminp_to_plant
-         if( .not.cnallocate_carbonphosphorus_only().and. .not.cnallocate_carbonnitrogen_only() &
-              .and. .not.cnallocate_carbon_only() )then
-
-            if (nu_com .eq. 'RD') then
-               do j = 1, nlevdecomp
-                  do fc=1,num_soilc
-                     c = filter_soilc(fc)
-
-                     if (nlimit(c,j) == 1.and.plimit(c,j) == 0) then
-
-                        actual_immob_p_vr(c,j) = potential_immob_p_vr(c,j) * fpi_vr(c,j)
-
-                        sminp_to_plant_vr(c,j) = col_plant_pdemand(c) * puptake_prof(c,j)
-
-                     elseif (nlimit(c,j) == 0.and.plimit(c,j) == 1) then
-
-                        actual_immob_vr(c,j)   = potential_immob_vr(c,j) *fpi_p_vr(c,j)
-                        sminn_to_plant_vr(c,j) = col_plant_ndemand(c) * nuptake_prof(c,j)
-
-                     elseif (nlimit(c,j) == 1.and.plimit(c,j) == 1)then
-
-                        if( fpi_vr(c,j) <=fpi_p_vr(c,j) )then
-
-                           actual_immob_p_vr(c,j) = potential_immob_p_vr(c,j) *fpi_vr(c,j)
-
-                           sminp_to_plant_vr(c,j) = min( max( 0._r8,(solutionp_vr(c,j)/dt) - actual_immob_p_vr(c,j) ), &
-                                col_plant_pdemand(c)*puptake_prof(c,j) )
-                        else
-
-                           actual_immob_vr(c,j)=potential_immob_vr(c,j) * fpi_p_vr(c,j)
-                           sminn_to_plant_vr(c,j) = min( (sminn_vr(c,j)/dt) - actual_immob_vr(c,j), &
-                                col_plant_ndemand(c)*nuptake_prof(c,j) )
-                        endif
-                     endif
-                  enddo
-               enddo
-
-            else ! 'ECA' or 'MIC' mode
-
-               do j = 1, nlevdecomp
-                  do fc=1,num_soilc
-                     c = filter_soilc(fc)
-
-                     if (nlimit(c,j) == 1.and.plimit(c,j) == 0) then
-
-                        actual_immob_p_vr(c,j) = potential_immob_p_vr(c,j) * fpi_vr(c,j)
-
-                        sminp_to_plant_vr(c,j) = col_plant_pdemand_vr(c,j)
-
-                     elseif (nlimit(c,j) == 0.and.plimit(c,j) == 1) then
-
-                        actual_immob_vr(c,j)   = potential_immob_vr(c,j) *fpi_p_vr(c,j)
-                        sminn_to_plant_vr(c,j) = col_plant_ndemand_vr(c,j)
-
-                     elseif (nlimit(c,j) == 1.and.plimit(c,j) == 1)then
-
-                        if( fpi_vr(c,j) <=fpi_p_vr(c,j) )then
-
-                           actual_immob_p_vr(c,j) = potential_immob_p_vr(c,j) *fpi_vr(c,j)                        
-                           sminp_to_plant_vr(c,j) = min( max( 0._r8,(solutionp_vr(c,j)/dt) - actual_immob_p_vr(c,j) ), &
-                                col_plant_pdemand_vr(c,j) )
-
-                        else
-
-                           actual_immob_vr(c,j)=potential_immob_vr(c,j) * fpi_p_vr(c,j)
-                           sminn_to_plant_vr(c,j) = min( (sminn_vr(c,j)/dt) - actual_immob_vr(c,j),col_plant_ndemand_vr(c,j) )
-
-                        endif
-                     endif
-                  enddo
-               enddo
-            end if
-            
-         end if
-
-         if(cnallocate_carbonnitrogen_only())then
-         !! add loops for c,j
-            do j = 1, nlevdecomp
-                do fc=1,num_soilc
-                    c = filter_soilc(fc)
-                    actual_immob_p_vr(c,j) = potential_immob_p_vr(c,j) * fpi_vr(c,j)
-                    sminp_to_plant_vr(c,j) = col_plant_pdemand(c) * puptake_prof(c,j)
-                end do
-            end do
-         endif
-
-         ! sum up N and P  fluxes to plant    ??????WAS sminn_to_plant(c)
-         ! INITIALIZED AS ZERO --- CHECK   X.YANG
-
-         do fc=1,num_soilc
-            c = filter_soilc(fc)
-            sminn_to_plant(c) = 0._r8
-            sminp_to_plant(c) = 0._r8
-         end do
-
-         do j = 1, nlevdecomp
-            do fc=1,num_soilc
-               c = filter_soilc(fc)
-               sminn_to_plant(c) = sminn_to_plant(c) + sminn_to_plant_vr(c,j) * dzsoi_decomp(j)
-               sminp_to_plant(c) = sminp_to_plant(c) + sminp_to_plant_vr(c,j) * dzsoi_decomp(j)
-
-            end do
-         end do
-
-         ! update column plant N/P demand, pft level plant NP uptake for ECA and MIC mode
-         if (nu_com .eq. 'ECA' .or. nu_com .eq. 'MIC') then
-            do fc=1,num_soilc
-               c = filter_soilc(fc)
-               col_plant_ndemand(c) = 0._r8
-               col_plant_pdemand(c) = 0._r8
-            end do
-            do j = 1, nlevdecomp  
-               do fc=1,num_soilc
-                  c = filter_soilc(fc)
-                  col_plant_ndemand(c) = col_plant_ndemand(c) + col_plant_ndemand_vr(c,j) * dzsoi_decomp(j)
-                  col_plant_pdemand(c) = col_plant_pdemand(c) + col_plant_pdemand_vr(c,j) * dzsoi_decomp(j)
-               end do
-            end do
-            do fp=1,num_soilp
-               p = filter_soilp(fp)
-               sminn_to_plant_patch(p) = 0.0_r8
-               sminp_to_plant_patch(p) = 0.0_r8
-            end do
-            do j = 1, nlevdecomp  
-               do fc=1,num_soilc
-                  c = filter_soilc(fc)
-                  if (col_plant_ndemand_vr(c,j) > 0._r8 ) then
-                     fpg_vr(c,j) = sminn_to_plant_vr(c,j)/col_plant_ndemand_vr(c,j)
-                  else
-                     fpg_vr(c,j) = 1.0_r8
-                  end if
-
-                  if (col_plant_pdemand_vr(c,j) > 0._r8) then
-                     fpg_p_vr(c,j) = sminp_to_plant_vr(c,j)/col_plant_pdemand_vr(c,j)
-                  else
-                     fpg_p_vr(c,j) = 1.0_r8
-                  end if
-                  do p = col_pp%pfti(c), col_pp%pftf(c)
-                     if (veg_pp%active(p).and. (veg_pp%itype(p) .ne. noveg)) then
-                        sminn_to_plant_patch(p) = sminn_to_plant_patch(p) + plant_ndemand_vr_patch(p,j) * &
-                             fpg_vr(c,j) *dzsoi_decomp(j)
-                        sminp_to_plant_patch(p) = sminp_to_plant_patch(p) + plant_pdemand_vr_patch(p,j) * &
-                             fpg_p_vr(c,j) *dzsoi_decomp(j)
-                     end if
-                  end do
-               end do
-            end do
-         end if
-
-         ! RD: plants have second pass to obtain nutrient
-         ! ECA/MIC: plants nutrient uptake is based on kinetics, no second pass nutrient uptake
-         if (nu_com .eq. 'RD') then
-            ! give plants a second pass to see if there is any mineral N left over with which to satisfy residual N demand.
-            do fc=1,num_soilc
-               c = filter_soilc(fc)    
-               residual_sminn(c) = 0._r8
-               residual_sminp(c) = 0._r8
-            end do
-
-            ! sum up total N left over after initial plant and immobilization fluxes
-            do fc=1,num_soilc
-               c = filter_soilc(fc)    
-               residual_plant_ndemand(c) = col_plant_ndemand(c) - sminn_to_plant(c)
-               residual_plant_pdemand(c) = col_plant_pdemand(c) - sminp_to_plant(c)
-            end do
-            do j = 1, nlevdecomp
-               do fc=1,num_soilc
-                  c = filter_soilc(fc)    
-                  if (residual_plant_ndemand(c)  >  0._r8 ) then
-                     if (nlimit(c,j) .eq. 0) then
-                        residual_sminn_vr(c,j) = max(sminn_vr(c,j) - (actual_immob_vr(c,j) + sminn_to_plant_vr(c,j) ) * dt, 0._r8)
-                        residual_sminn(c) = residual_sminn(c) + residual_sminn_vr(c,j) * dzsoi_decomp(j)
-                     else
-                        residual_sminn_vr(c,j)  = 0._r8
-                     endif
-                  endif
-                  !!! add phosphorus - X.YANG
-                  if (residual_plant_pdemand(c)  >  0._r8 ) then
-                     if (plimit(c,j) .eq. 0) then
-                        residual_sminp_vr(c,j) = max(solutionp_vr(c,j) - (actual_immob_p_vr(c,j) + sminp_to_plant_vr(c,j) ) &
-                        * dt, 0._r8)
-                        residual_sminp(c) = residual_sminp(c) + residual_sminp_vr(c,j) * dzsoi_decomp(j)
-                     else
-                        residual_sminp_vr(c,j)  = 0._r8
-                     endif
-                  endif
-               end do
-            end do
-
-            ! distribute residual N and P to plants
-            do j = 1, nlevdecomp
-               do fc=1,num_soilc
-                  c = filter_soilc(fc)    
-                  if ( residual_plant_ndemand(c)  >  0._r8 .and. residual_sminn(c)  >  0._r8 .and. nlimit(c,j) .eq. 0) then
-                     sminn_to_plant_vr(c,j) = sminn_to_plant_vr(c,j) + residual_sminn_vr(c,j) * &
-                          min(( residual_plant_ndemand(c) *  dt ) / residual_sminn(c), 1._r8) / dt
-                  endif
-
-                  if ( residual_plant_pdemand(c)  >  0._r8 .and. residual_sminp(c)  >  0._r8 .and. plimit(c,j) .eq. 0) then
-                     sminp_to_plant_vr(c,j) = sminp_to_plant_vr(c,j) + residual_sminp_vr(c,j) * &
-                          min(( residual_plant_pdemand(c) *  dt ) / residual_sminp(c), 1._r8) / dt
-                  endif
-               end do
-            end do
-
-            ! re-sum up N and P fluxes to plant
-            do fc=1,num_soilc
-               c = filter_soilc(fc)    
-               sminn_to_plant(c) = 0._r8
-               sminp_to_plant(c) = 0._r8
-            end do
-            do j = 1, nlevdecomp
-               do fc=1,num_soilc
-                  c = filter_soilc(fc)    
-                  sminn_to_plant(c) = sminn_to_plant(c) + sminn_to_plant_vr(c,j) * dzsoi_decomp(j)
-                  sum_ndemand_vr(c,j) = potential_immob_vr(c,j) + sminn_to_plant_vr(c,j)
-
-                  !!! for phosphorus
-                  sminp_to_plant(c) = sminp_to_plant(c) + sminp_to_plant_vr(c,j) * dzsoi_decomp(j)
-                  sum_pdemand_vr(c,j) = potential_immob_p_vr(c,j) + sminp_to_plant_vr(c,j)
-               end do
-            end do
-         end if
-
-         ! under conditions of excess N, some proportion is assumed to
-         ! be lost to denitrification, in addition to the constant
-         ! proportion lost in the decomposition pathways
-         do j = 1, nlevdecomp
-            do fc=1,num_soilc
-               c = filter_soilc(fc)
-               if ((sminn_to_plant_vr(c,j) + actual_immob_vr(c,j))*dt < sminn_vr(c,j)) then
-                  sminn_to_denit_excess_vr(c,j) = max(bdnr*((sminn_vr(c,j)/dt) - sum_ndemand_vr(c,j)),0._r8)
-               else
-                  sminn_to_denit_excess_vr(c,j) = 0._r8
-               endif
-            end do
-         end do
-
-         ! sum up N and P fluxes to immobilization
-         do j = 1, nlevdecomp
-            do fc=1,num_soilc
-               c = filter_soilc(fc)
-               actual_immob(c) = actual_immob(c) + actual_immob_vr(c,j) * dzsoi_decomp(j)
-               potential_immob(c) = potential_immob(c) + potential_immob_vr(c,j) * dzsoi_decomp(j)
-               !!! phosphorus
-               actual_immob_p(c) = actual_immob_p(c) + actual_immob_p_vr(c,j) * dzsoi_decomp(j)
-               potential_immob_p(c) = potential_immob_p(c) + potential_immob_p_vr(c,j) * dzsoi_decomp(j)
-            end do
-         end do
-
-         do fc=1,num_soilc
-            c = filter_soilc(fc)
-            ! calculate the fraction of potential growth that can be
-            ! acheived with the N available to plants
-            if (col_plant_ndemand(c) > 0.0_r8) then
-               fpg(c) = sminn_to_plant(c) / col_plant_ndemand(c)
-            else
-               fpg(c) = 1.0_r8
-            end if
-
-            ! calculate the fraction of immobilization realized (for diagnostic purposes)
-            if (potential_immob(c) > 0.0_r8) then
-               fpi(c) = actual_immob(c) / potential_immob(c)
-            else
-               fpi(c) = 1.0_r8
-            end if
-         end do
-
-         do fc=1,num_soilc
-            c = filter_soilc(fc)
-            ! calculate the fraction of potential growth that can be
-            ! acheived with the P available to plants
-            if (col_plant_pdemand(c) > 0.0_r8) then
-               fpg_p(c) = sminp_to_plant(c) / col_plant_pdemand(c)
-            else
-               fpg_p(c) = 1.0_r8
-            end if
-
-            ! calculate the fraction of immobilization realized (for diagnostic purposes)
-            if (potential_immob_p(c) > 0.0_r8) then
-               fpi_p(c) = actual_immob_p(c) / potential_immob_p(c)
-            else
-               fpi_p(c) = 1.0_r8
-            end if
-         end do
-
-         ! for np imbalance
-         if (nu_com .ne. 'RD') then
-            do fc=1,num_soilc
-               c = filter_soilc(fc)
-               do p = col_pp%pfti(c), col_pp%pftf(c)
-                  pnup_pfrootc(p) =  0.0_r8
-                  if (veg_pp%active(p).and. (veg_pp%itype(p) .ne. noveg)) then
-                        do j = 1, nlevdecomp
-                           pnup_pfrootc(p) = pnup_pfrootc(p) + plant_ndemand_vr_patch(p,j) / max(frootc(p) * froot_prof(p,j)&
-                                ,1e-20_r8) * fpg_nh4_vr(c,j) / max(cn_scalar(p),1e-20_r8) / max(t_scalar(c,j),1e-20_r8) &
-                                * dzsoi_decomp(j)
-                        end do
-                  end if
-                  pnup_pfrootc(p) =  pnup_pfrootc(p) / zisoi(nlevdecomp-1)
-               end do
-            end do
-         end if
-
-      else  !----------NITRIF_DENITRIF-------------!
 
          if (nu_com .eq. 'RD') then
             ! calculate competition coefficients
@@ -2011,6 +1449,7 @@
             compet_decomp_no3 = AllocParamsInst%compet_decomp_no3
             compet_denit = AllocParamsInst%compet_denit
 
+
             ! main column/vertical loop
             do j = 1, nlevdecomp
                do fc=1,num_soilc
@@ -2022,15 +1461,23 @@
                   sum_nh4_demand(c,j) = col_plant_ndemand(c) * nuptake_prof(c,j) + potential_immob_vr(c,j) + pot_f_nit_vr(c,j)
                   sum_nh4_demand_scaled(c,j) = col_plant_ndemand(c)* nuptake_prof(c,j) * compet_plant_nh4(p) + &
                        potential_immob_vr(c,j)*compet_decomp_nh4 + pot_f_nit_vr(c,j)*compet_nit
+
                   if (sum_nh4_demand(c,j)*dt < smin_nh4_vr(c,j)) then
                      ! NH4 availability is not limiting immobilization or plant
                      ! uptake, and all can proceed at their potential rates
                      nlimit_nh4(c,j) = 0
                      fpi_nh4_vr(c,j) = 1.0_r8
                      actual_immob_nh4_vr(c,j) = potential_immob_vr(c,j)
-                     smin_nh4_to_plant_vr(c,j) = col_plant_ndemand(c) * nuptake_prof(c,j)
+                     !RF added new term.
 
                      f_nit_vr(c,j) = pot_f_nit_vr(c,j)
+                     
+                   
+                     if ( .not. use_fun ) then
+                     smin_nh4_to_plant_vr(c,j) = col_plant_ndemand(c) * nuptake_prof(c,j)
+                     else
+                     smin_nh4_to_plant_vr(c,j) = smin_nh4_vr(c,j)/dt - actual_immob_nh4_vr(c,j) - f_nit_vr(c,j)
+                     end if
 
                   else
 
@@ -2038,15 +1485,29 @@
                      ! plant growth demands, so these three demands compete for available
                      ! soil mineral NH4 resource.
                      nlimit_nh4(c,j) = 1
-                     if (sum_nh4_demand(c,j) > 0.0_r8 .and. smin_nh4_vr(c,j) > 0.0_r8 &
-                          .and. sum_nh4_demand_scaled(c,j) > 0.0_r8) then
+                     !Original ELM
+                     !if (sum_nh4_demand(c,j) > 0.0_r8 .and. smin_nh4_vr(c,j) > 0.0_r8 &
+                     !     .and. sum_nh4_demand_scaled(c,j) > 0.0_r8) then
+                     !As in CLM5
+                      if (sum_nh4_demand(c,j) > 0.0_r8) then
+                      ! RF microbes compete based on the hypothesised plant demand. 
                         actual_immob_nh4_vr(c,j) = min((smin_nh4_vr(c,j)/dt)*(potential_immob_vr(c,j)* &
                              compet_decomp_nh4 / sum_nh4_demand_scaled(c,j)), potential_immob_vr(c,j))
-                        smin_nh4_to_plant_vr(c,j) = min((smin_nh4_vr(c,j)/dt)*(col_plant_ndemand(c)* &
-                             nuptake_prof(c,j)*compet_plant_nh4(p) / sum_nh4_demand_scaled(c,j)), &
-                             col_plant_ndemand(c)*nuptake_prof(c,j))
+                        !smin_nh4_to_plant_vr(c,j) = min((smin_nh4_vr(c,j)/dt)*(col_plant_ndemand(c)* &
+                        !     nuptake_prof(c,j)*compet_plant_nh4(p) / sum_nh4_demand_scaled(c,j)), &
+                         !    col_plant_ndemand(c)*nuptake_prof(c,j))
                         f_nit_vr(c,j) =  min((smin_nh4_vr(c,j)/dt)*(pot_f_nit_vr(c,j)*compet_nit / &
                              sum_nh4_demand_scaled(c,j)), pot_f_nit_vr(c,j))
+ 
+                    if ( .not. use_fun ) then
+                         smin_nh4_to_plant_vr(c,j) = min((smin_nh4_vr(c,j)/dt)*(col_plant_ndemand(c)* &
+                          nuptake_prof(c,j)*compet_plant_nh4(p) / sum_nh4_demand_scaled(c,j)), col_plant_ndemand(c)*nuptake_prof(c,j))
+                          
+                     else
+                        ! RF added new term. send rest of N to plant - which decides whether it should pay or not? 
+                        smin_nh4_to_plant_vr(c,j) = smin_nh4_vr(c,j)/dt - actual_immob_nh4_vr(c,j) - f_nit_vr(c,j)
+                     end if
+
                      else
                         actual_immob_nh4_vr(c,j) = 0.0_r8
                         smin_nh4_to_plant_vr(c,j) = 0.0_r8
@@ -2061,44 +1522,91 @@
 
                   end if
 
+                  if(.not.use_fun)then
                   ! next compete for no3
                   sum_no3_demand(c,j) = (col_plant_ndemand(c)*nuptake_prof(c,j)-smin_nh4_to_plant_vr(c,j)) + &
                        (potential_immob_vr(c,j)-actual_immob_nh4_vr(c,j)) + pot_f_denit_vr(c,j)
                   sum_no3_demand_scaled(c,j) = (col_plant_ndemand(c)*nuptake_prof(c,j)-smin_nh4_to_plant_vr(c,j))&
                        *compet_plant_no3(p) + (potential_immob_vr(c,j)-actual_immob_nh4_vr(c,j))*compet_decomp_no3 &
                        + pot_f_denit_vr(c,j)*compet_denit
+                 else
+                  sum_no3_demand(c,j) = col_plant_ndemand(c)*nuptake_prof(c,j) + &
+                  (potential_immob_vr(c,j)-actual_immob_nh4_vr(c,j)) + pot_f_denit_vr(c,j)
+                   sum_no3_demand_scaled(c,j) = (col_plant_ndemand(c)*nuptake_prof(c,j))*compet_plant_no3(p) + &
+                  (potential_immob_vr(c,j)-actual_immob_nh4_vr(c,j))*compet_decomp_no3 + pot_f_denit_vr(c,j)*compet_denit
+                 end if
 
                   if (sum_no3_demand(c,j)*dt < smin_no3_vr(c,j)) then
                      ! NO3 availability is not limiting immobilization or plant
                      ! uptake, and all can proceed at their potential rates
-                     nlimit_no3(c,j) = 1
+                     !Original ELM
+                     !nlimit_no3(c,j) = 1
+                     !As in CLM5
+                     nlimit_no3(c,j) = 0
                      fpi_no3_vr(c,j) = 1.0_r8 -  fpi_nh4_vr(c,j)
                      actual_immob_no3_vr(c,j) = (potential_immob_vr(c,j)-actual_immob_nh4_vr(c,j))
-                     smin_no3_to_plant_vr(c,j) = (col_plant_ndemand(c)*nuptake_prof(c,j)-smin_nh4_to_plant_vr(c,j))
+                     !smin_no3_to_plant_vr(c,j) = (col_plant_ndemand(c)*nuptake_prof(c,j)-smin_nh4_to_plant_vr(c,j))
 
                      f_denit_vr(c,j) = pot_f_denit_vr(c,j)
 
+                 if(.not.use_fun)then
+                     smin_no3_to_plant_vr(c,j) = (col_plant_ndemand(c)*nuptake_prof(c,j)-smin_nh4_to_plant_vr(c,j))
+                  else
+                     ! This restricts the N uptake of a single layer to the value determined from the total demands and the 
+                     ! hypothetical uptake profile above. Which is a strange thing to do, since that is independent of FUN
+                     ! do we need this at all? 
+                     smin_no3_to_plant_vr(c,j) = col_plant_ndemand(c)*nuptake_prof(c,j)
+                     ! RF added new term. send rest of N to plant - which decides whether it should pay or not? 
+                     if ( use_fun ) then
+                        smin_no3_to_plant_vr(c,j) = smin_no3_vr(c,j)/dt - actual_immob_no3_vr(c,j) - f_denit_vr(c,j)
+                     end if
+                  endif
+
                   else
 
                      ! NO3 availability can not satisfy the sum of immobilization, denitrification, and
                      ! plant growth demands, so these three demands compete for available
                      ! soil mineral NO3 resource.
                      nlimit_no3(c,j) = 1
-                     if (sum_no3_demand(c,j) > 0.0_r8 .and. smin_no3_vr(c,j) > 0.0_r8 &
-                          .and. sum_no3_demand_scaled(c,j) > 0.0_r8) then
+                     !Original ELM
+                     !if (sum_no3_demand(c,j) > 0.0_r8 .and. smin_no3_vr(c,j) > 0.0_r8 &
+                     !     .and. sum_no3_demand_scaled(c,j) > 0.0_r8) then
+                     !As in CLM5
+                     if (sum_no3_demand(c,j) > 0.0_r8) then
+
+                     if(.not.use_fun)then
                         actual_immob_no3_vr(c,j) = min((smin_no3_vr(c,j)/dt)*((potential_immob_vr(c,j)- &
                              actual_immob_nh4_vr(c,j))*compet_decomp_no3 / sum_no3_demand_scaled(c,j)), &
                              potential_immob_vr(c,j)-actual_immob_nh4_vr(c,j))
+
                         smin_no3_to_plant_vr(c,j) = min((smin_no3_vr(c,j)/dt)*((col_plant_ndemand(c)* &
                              nuptake_prof(c,j)-smin_nh4_to_plant_vr(c,j))*compet_plant_no3(p) / sum_no3_demand_scaled(c,j)), &
                              col_plant_ndemand(c)*nuptake_prof(c,j)-smin_nh4_to_plant_vr(c,j))
+
                         f_denit_vr(c,j) =  min((smin_no3_vr(c,j)/dt)*(pot_f_denit_vr(c,j)*compet_denit / &
                              sum_no3_demand_scaled(c,j)), pot_f_denit_vr(c,j))
+                       else
+                        actual_immob_no3_vr(c,j) = min((smin_no3_vr(c,j)/dt)*((potential_immob_vr(c,j)- &
+                        actual_immob_nh4_vr(c,j))*compet_decomp_no3 / sum_no3_demand_scaled(c,j)), &
+                                  potential_immob_vr(c,j)-actual_immob_nh4_vr(c,j))
+
+                        f_denit_vr(c,j) = min((smin_no3_vr(c,j)/dt)*(pot_f_denit_vr(c,j)*compet_denit / &
+                        sum_no3_demand_scaled(c,j)), pot_f_denit_vr(c,j))
+        
+                        smin_no3_to_plant_vr(c,j) = (smin_no3_vr(c,j)/dt)*((col_plant_ndemand(c)* &
+                                  nuptake_prof(c,j)-smin_nh4_to_plant_vr(c,j))*compet_plant_no3(p) / sum_no3_demand_scaled(c,j))
+                                  
+                        ! RF added new term. send rest of N to plant - which decides whether it should pay or not? 
+                        smin_no3_to_plant_vr(c,j) = (smin_no3_vr(c,j) / dt) - actual_immob_no3_vr(c,j) - f_denit_vr(c,j)
+                        
+  
+                     end if ! use_fun
+
                      else
                         actual_immob_no3_vr(c,j) = 0.0_r8
                         smin_no3_to_plant_vr(c,j) = 0.0_r8
                         f_denit_vr(c,j) = 0.0_r8
-                     end if
+                     end if !any no3 demand?
 
                      if (potential_immob_vr(c,j) > 0.0_r8) then
                         fpi_no3_vr(c,j) = actual_immob_no3_vr(c,j) / potential_immob_vr(c,j)
@@ -2299,10 +1807,12 @@
 
                ! eliminate any N limitation, when carbon only or carbon phosphorus only is set.
                if ( cnallocate_carbon_only() .or. cnallocate_carbonphosphorus_only() ) then
-                  nlimit(c,j) = 0
+                  !Original ELM
+                  !nlimit(c,j) = 0
                   if ( fpi_no3_vr(c,j) + fpi_nh4_vr(c,j) < 1._r8 ) then
-                     nlimit(c,j) = 1
-                     fpi_vr(c,j) = 1._r8
+                     !Original ELM
+                     !nlimit(c,j) = 1
+                     !fpi_vr(c,j) = 1._r8
                      fpi_nh4_vr(c,j) = 1.0_r8 - fpi_no3_vr(c,j)
                      supplement_to_sminn_vr(c,j) = (potential_immob_vr(c,j) - actual_immob_no3_vr(c,j)) - actual_immob_nh4_vr(c,j)
                      ! update to new values that satisfy demand
@@ -2311,7 +1821,8 @@
 
                   if (nu_com .eq. 'RD') then
                      if ( smin_no3_to_plant_vr(c,j) + smin_nh4_to_plant_vr(c,j) < col_plant_ndemand(c)*nuptake_prof(c,j) ) then
-                        nlimit(c,j) = 1
+                        !Original ELM
+                        !nlimit(c,j) = 1
                         supplement_to_sminn_vr(c,j) = supplement_to_sminn_vr(c,j) + &
                              (col_plant_ndemand(c)*nuptake_prof(c,j) - smin_no3_to_plant_vr(c,j)) - smin_nh4_to_plant_vr(c,j)  ! use old values
                         ! update to new values that satisfy demand
@@ -2346,6 +1857,8 @@
          end do
 
 
+
+
          ! add phosphorus           
 
          if (nu_com .eq. 'RD') then
@@ -2364,6 +1877,7 @@
 
                      ! P availability is not limiting immobilization or plant
                      ! uptake, and both can proceed at their potential rates
+              
                      plimit(c,j) = 0
                      fpi_p_vr(c,j) = 1.0_r8
                      actual_immob_p_vr(c,j) = potential_immob_p_vr(c,j)
@@ -2383,7 +1897,9 @@
                      ! available soil mineral solution P resource.
 
                      plimit(c,j) = 1
-                     if (sum_pdemand_vr(c,j) > 0.0_r8 .and. solutionp_vr(c,j) >0._r8) then
+                     !if (sum_pdemand_vr(c,j) > 0.0_r8 .and. solutionp_vr(c,j) >0._r8) then
+                     if (sum_pdemand_vr(c,j) > 0.0_r8) then
+
                         actual_immob_p_vr(c,j) = (solutionp_vr(c,j)/dt)*(potential_immob_p_vr(c,j) / sum_pdemand_vr(c,j))
                      else
                         actual_immob_p_vr(c,j) = 0.0_r8
@@ -2396,6 +1912,7 @@
                      end if
 
                      sminp_to_plant_vr(c,j) = max( 0._r8,(solutionp_vr(c,j)/dt) - actual_immob_p_vr(c,j) ) 
+                     !sminp_to_plant_vr(c,j) = (solutionp_vr(c,j)/dt) - actual_immob_p_vr(c,j) 
                   end if
                end do
             end do
@@ -2539,6 +2056,44 @@
             end do
          end if ! end of P competition
 
+
+         if ( use_fun ) then
+            call t_startf('CNFUN')
+                call CNFUN (bounds                      , &
+                num_soilc, filter_soilc, num_soilp, filter_soilp    , &
+                canopystate_vars                                    , &
+                cnstate_vars, carbonstate_vars, carbonflux_vars     , &
+                c13_carbonflux_vars, c14_carbonflux_vars            , &
+                nitrogenstate_vars, nitrogenflux_vars               , &
+                phosphorusstate_vars, phosphorusflux_vars, crop_vars, &
+                soilhydrology_vars, temperature_vars, waterflux_vars, &
+                soilstate_vars)
+                
+          
+                      
+            ! sminn_to_plant_fun is output of actual N uptake from FUN
+            call p2c_2d(bounds,nlevdecomp, &
+                       veg_nf%sminn_to_plant_fun_no3_vr(bounds%begp:bounds%endp,1:nlevdecomp),&
+                       col_nf%sminn_to_plant_fun_no3_vr(bounds%begc:bounds%endc,1:nlevdecomp),&
+                       'unity')
+
+            call p2c_2d(bounds,nlevdecomp, &
+                       veg_nf%sminn_to_plant_fun_nh4_vr(bounds%begp:bounds%endp,1:nlevdecomp),&
+                       col_nf%sminn_to_plant_fun_nh4_vr(bounds%begc:bounds%endc,1:nlevdecomp),&
+                       'unity')
+
+          if(use_funp)then    
+           call p2c_2d(bounds,nlevdecomp, &
+                       veg_pf%sminp_to_plant_fun_vr(bounds%begp:bounds%endp,1:nlevdecomp),&
+                       col_pf%sminp_to_plant_fun_vr(bounds%begc:bounds%endc,1:nlevdecomp),&
+                       'unity')
+           end if
+
+
+            call t_stopf('CNFUN')
+         end if
+
+
          !!!  resolving N limitation vs. P limitation for decomposition 
          !!!  update (1) actual immobilization for N and P (2) sminn_to_plant and sminp_to_plant
 
@@ -2667,21 +2222,231 @@
            end do
          end if 
 
+
+       if(.not.use_fun)then   
          ! sum up plant N/P uptake at column level and patch level
          do fc=1,num_soilc
             c = filter_soilc(fc)
             ! sum up N fluxes to plant after initial competition
             sminn_to_plant(c) = 0._r8
-            sminp_to_plant(c) = 0._r8
          end do
          do j = 1, nlevdecomp
             do fc=1,num_soilc
                c = filter_soilc(fc)
                sminn_to_plant(c) = sminn_to_plant(c) + sminn_to_plant_vr(c,j) * dzsoi_decomp(j)
+                            
+            end do
+         end do
+        else
+            do fc=1,num_soilc
+               c = filter_soilc(fc)
+               ! sum up N fluxes to plant after initial competition
+               sminn_to_plant(c) = 0._r8 !this isn't use in fun. 
+               
+               do j = 1, nlevdecomp
+                  if ((sminn_to_plant_fun_no3_vr(c,j)-smin_no3_to_plant_vr(c,j)).gt.0.0000000000001_r8) then
+                      write(iulog,*) 'problem with limitations on no3 uptake', &
+                                 sminn_to_plant_fun_no3_vr(c,j),smin_no3_to_plant_vr(c,j)
+                      call endrun("too much NO3 uptake predicted by FUN")
+                  end if
+
+                  if ((sminn_to_plant_fun_nh4_vr(c,j)-smin_nh4_to_plant_vr(c,j)).gt.0.0000001_r8) then
+
+                      write(iulog,*) 'problem with limitations on nh4 uptake', &
+                                  sminn_to_plant_fun_nh4_vr(c,j),smin_nh4_to_plant_vr(c,j)
+                      call endrun("too much NH4 uptake predicted by FUN")
+                  end if
+
+              
+
+               end do
+            end do
+         end if
+
+         if(.not.use_fun)then
+            ! give plants a second pass to see if there is any mineral N left over with which to satisfy residual N demand.
+            ! first take frm nh4 pool; then take from no3 pool
+            do fc=1,num_soilc
+               c = filter_soilc(fc)
+               residual_plant_ndemand(c) = col_plant_ndemand(c) - sminn_to_plant(c)
+               residual_smin_nh4(c) = 0._r8
+            end do
+            do j = 1, nlevdecomp  
+               do fc=1,num_soilc
+                  c = filter_soilc(fc)
+                  if (residual_plant_ndemand(c)  >  0._r8 ) then
+                     if (nlimit_nh4(c,j) .eq. 0) then
+                        residual_smin_nh4_vr(c,j) = max(smin_nh4_vr(c,j) - (actual_immob_nh4_vr(c,j) + &
+                                                    smin_nh4_to_plant_vr(c,j) + f_nit_vr(c,j) ) * dt, 0._r8)
+
+                        residual_smin_nh4(c) = residual_smin_nh4(c) + residual_smin_nh4_vr(c,j) * dzsoi_decomp(j)
+                     else
+                        residual_smin_nh4_vr(c,j)  = 0._r8
+                     endif
+   
+                     if ( residual_smin_nh4(c) > 0._r8 .and. nlimit_nh4(c,j) .eq. 0 ) then
+                        smin_nh4_to_plant_vr(c,j) = smin_nh4_to_plant_vr(c,j) + residual_smin_nh4_vr(c,j) * &
+                             min(( residual_plant_ndemand(c) *  dt ) / residual_smin_nh4(c), 1._r8) / dt
+                     endif
+                  end if
+               end do
+            end do
+
+            ! re-sum up N fluxes to plant after second pass for nh4
+            do fc=1,num_soilc
+               c = filter_soilc(fc)
+               sminn_to_plant(c) = 0._r8
+            end do
+            do j = 1, nlevdecomp
+               do fc=1,num_soilc
+                  c = filter_soilc(fc)
+                  sminn_to_plant_vr(c,j) = smin_nh4_to_plant_vr(c,j) + smin_no3_to_plant_vr(c,j)
+                  sminn_to_plant(c) = sminn_to_plant(c) + (sminn_to_plant_vr(c,j)) * dzsoi_decomp(j)
+               end do
+            end do
+
+            !
+            ! and now do second pass for no3
+            do fc=1,num_soilc
+               c = filter_soilc(fc)
+               residual_plant_ndemand(c) = col_plant_ndemand(c) - sminn_to_plant(c)
+               residual_smin_no3(c) = 0._r8
+            end do
+
+            do j = 1, nlevdecomp
+               do fc=1,num_soilc
+                  c = filter_soilc(fc)
+                  if (residual_plant_ndemand(c) > 0._r8 ) then
+                     if (nlimit_no3(c,j) .eq. 0) then
+                       residual_smin_no3_vr(c,j) = max(smin_no3_vr(c,j) - (actual_immob_no3_vr(c,j) + &
+                                                   smin_no3_to_plant_vr(c,j) + f_denit_vr(c,j) ) * dt, 0._r8)
+                        residual_smin_no3(c) = residual_smin_no3(c) + residual_smin_no3_vr(c,j) * dzsoi_decomp(j)
+                     else
+                        residual_smin_no3_vr(c,j)  = 0._r8
+                     endif
+   
+                     if ( residual_smin_no3(c) > 0._r8 .and. nlimit_no3(c,j) .eq. 0) then
+                        smin_no3_to_plant_vr(c,j) = smin_no3_to_plant_vr(c,j) + residual_smin_no3_vr(c,j) * &
+                             min(( residual_plant_ndemand(c) *  dt ) / residual_smin_no3(c), 1._r8) / dt
+                     endif
+                  endif
+               end do
+            end do
+
+            ! re-sum up N fluxes to plant after second passes of both no3 and nh4
+            do fc=1,num_soilc
+               c = filter_soilc(fc)
+               sminn_to_plant(c) = 0._r8
+            end do
+            do j = 1, nlevdecomp
+               do fc=1,num_soilc
+                  c = filter_soilc(fc)
+                  sminn_to_plant_vr(c,j) = smin_nh4_to_plant_vr(c,j) + smin_no3_to_plant_vr(c,j)
+                  sminn_to_plant(c) = sminn_to_plant(c) + (sminn_to_plant_vr(c,j)) * dzsoi_decomp(j)
+               end do
+            end do   
+         else !use_fun
+         !calculate maximum N available to plants. 
+            do fc=1,num_soilc
+               c = filter_soilc(fc)
+               sminn_to_plant(c) = 0._r8
+              
+            end do
+            do j = 1, nlevdecomp
+               do fc=1,num_soilc
+                  c = filter_soilc(fc)
+                  sminn_to_plant_vr(c,j) = smin_nh4_to_plant_vr(c,j) + smin_no3_to_plant_vr(c,j)
+                  sminn_to_plant(c) = sminn_to_plant(c) + (sminn_to_plant_vr(c,j)) * dzsoi_decomp(j)
+             
+
+               end do
+            end do
+
+            
+             ! add up fun fluxes from SMINN to plant. 
+             do j = 1, nlevdecomp
+                do fc=1,num_soilc
+                   c = filter_soilc(fc)
+                   sminn_to_plant_new(c)  = sminn_to_plant_new(c) + &
+                             (sminn_to_plant_fun_no3_vr(c,j) + sminn_to_plant_fun_nh4_vr(c,j)) * dzsoi_decomp(j)
+               
+             end do
+           end do                             
+         end if !use_fun
+
+         !!!!!!!!!!!!!!!!Phosphorus!!!!!!!!!!!!!!!!!!
+
+         ! sum up P fluxes to plant
+         do j = 1, nlevdecomp
+            do fc=1,num_soilc
+               c = filter_soilc(fc)    
+               sminp_to_plant(c) = sminp_to_plant(c) + sminp_to_plant_vr(c,j) * dzsoi_decomp(j)
+               if ( use_funp ) then
+                 if (sminp_to_plant_fun_vr(c,j).gt.sminp_to_plant_vr(c,j)) then
+                      
+                      sminp_to_plant_fun_vr(c,j)  = sminp_to_plant_vr(c,j)
+                      
+                  end if
+               end if
+            end do
+         end do
+
+         ! give plants a second pass to see if there is any mineral P left over with which to satisfy residual P demand.
+         do fc=1,num_soilc
+            c = filter_soilc(fc)    
+            residual_sminp(c) = 0._r8
+         end do
+
+         ! sum up total P left over after initial plant and immobilization fluxes
+         do fc=1,num_soilc
+            c = filter_soilc(fc)    
+            residual_plant_pdemand(c) = col_plant_pdemand(c) - sminp_to_plant(c)
+         end do
+         do j = 1, nlevdecomp
+            do fc=1,num_soilc
+               c = filter_soilc(fc)    
+               if (residual_plant_pdemand(c)  >  0._r8 ) then
+                  if (plimit(c,j) .eq. 0) then
+                     residual_sminp_vr(c,j) = max(solutionp_vr(c,j) - (actual_immob_p_vr(c,j) + sminp_to_plant_vr(c,j) ) * dt, 0._r8)
+                     residual_sminp(c) = residual_sminp(c) + residual_sminp_vr(c,j) * dzsoi_decomp(j)
+                  else
+                     residual_sminp_vr(c,j)  = 0._r8
+                  endif
+               endif
+            end do
+         end do
+
+         ! distribute residual P to plants
+         do j = 1, nlevdecomp
+            do fc=1,num_soilc
+               c = filter_soilc(fc)    
+               if ( residual_plant_pdemand(c)  >  0._r8 .and. residual_sminp(c)  >  0._r8 .and. plimit(c,j) .eq. 0) then
+                  sminp_to_plant_vr(c,j) = sminp_to_plant_vr(c,j) + residual_sminp_vr(c,j) * &
+                       min(( residual_plant_pdemand(c) *  dt ) / residual_sminp(c), 1._r8) / dt
+               endif
+            end do
+         end do
+
+         ! re-sum up P fluxes to plant
+         do fc=1,num_soilc
+            c = filter_soilc(fc)    
+            sminp_to_plant(c) = 0._r8
+         end do
+         do j = 1, nlevdecomp
+            do fc=1,num_soilc
+               c = filter_soilc(fc)    
                sminp_to_plant(c) = sminp_to_plant(c) + sminp_to_plant_vr(c,j) * dzsoi_decomp(j)
+               if ( .not. use_funp ) then
+                  sum_pdemand_vr(c,j) = potential_immob_p_vr(c,j) + sminp_to_plant_vr(c,j)
+               else
+                  sminp_to_plant_new(c)  = sminp_to_plant_new(c)   + sminp_to_plant_fun_vr(c,j) * dzsoi_decomp(j)
+                  sum_pdemand_vr(c,j)    = potential_immob_p_vr(c,j) + sminp_to_plant_fun_vr(c,j)
+               end if
             end do
          end do
 
+
+
          ! update column plant N/P demand, pft level plant NP uptake for ECA and MIC mode
          if (nu_com .eq. 'ECA' .or. nu_com .eq. 'MIC') then
             do fc=1,num_soilc
@@ -2766,11 +2531,19 @@
             c = filter_soilc(fc)
             ! calculate the fraction of potential growth that can be
             ! acheived with the N available to plants
+
+           if (.not. use_fun ) then !FUN has no concept of FPG   
             if (col_plant_ndemand(c) > 0.0_r8) then
-               fpg(c) = sminn_to_plant(c) / col_plant_ndemand(c)
+             !if (.not. use_fun ) then !FUN has no concept of FPG        
+               fpg(c) = sminn_to_plant(c) / col_plant_ndemand(c) 
+             !else 
+             !  fpg(c) = sminn_to_plant_new(c) / col_plant_ndemand(c) 
+             !end if        
             else
                fpg(c) = 1._r8
             end if
+           end if        
+          
 
             ! calculate the fraction of immobilization realized (for diagnostic purposes)
             if (potential_immob(c) > 0.0_r8) then
@@ -2783,12 +2556,20 @@
          do fc=1,num_soilc
             c = filter_soilc(fc)    
             ! calculate the fraction of potential growth that can be
-            ! acheived with the P available to plants      
+            ! acheived with the P available to plants  
+           if(.not.use_funp)then 
             if (col_plant_pdemand(c) > 0.0_r8) then
+!comment
+             !if(.not.use_funp)then 
                fpg_p(c) = sminp_to_plant(c) / col_plant_pdemand(c)
+             !else
+              ! fpg_p(c) = sminp_to_plant_new(c) / col_plant_pdemand(c)        
+             !end if
             else
                fpg_p(c) = 1.0_r8
             end if
+           end if
+            
 
             ! calculate the fraction of immobilization realized (for diagnostic purposes)
             if (potential_immob_p(c) > 0.0_r8) then
@@ -2819,8 +2600,6 @@
             end do
          end if
 
-      end if  !end of if_not_use_nitrif_denitrif
-
     end associate
     
  end subroutine Allocation2_ResolveNPLimit
@@ -2832,7 +2611,9 @@
         cnstate_vars, carbonstate_vars, carbonflux_vars     , &
         c13_carbonflux_vars, c14_carbonflux_vars            , &
         nitrogenstate_vars, nitrogenflux_vars               , &
-        phosphorusstate_vars, phosphorusflux_vars, crop_vars)
+        phosphorusstate_vars, phosphorusflux_vars, crop_vars, &
+        soilhydrology_vars, temperature_vars, waterflux_vars, &
+        soilstate_vars)
     ! PHASE-3 of Allocation: start new pft loop to distribute the available N/P between the
     ! competing patches on the basis of relative demand, and allocate C/N/P to new growth and storage
 
@@ -2858,7 +2639,7 @@
 
     type(canopystate_type)   , intent(in)    :: canopystate_vars
     type(cnstate_type)       , intent(inout) :: cnstate_vars
-    type(carbonstate_type)   , intent(in)    :: carbonstate_vars
+    type(carbonstate_type)   , intent(inout) :: carbonstate_vars
     type(carbonflux_type)    , intent(inout) :: carbonflux_vars
     type(carbonflux_type)    , intent(inout) :: c13_carbonflux_vars
     type(carbonflux_type)    , intent(inout) :: c14_carbonflux_vars
@@ -2868,6 +2649,12 @@
     type(phosphorusstate_type) , intent(inout) :: phosphorusstate_vars
     type(phosphorusflux_type)  , intent(inout) :: phosphorusflux_vars
     type(crop_type)          , intent(inout) :: crop_vars
+
+     !! add varibles needed for FUN
+    type(soilhydrology_type)  , intent(in) :: soilhydrology_vars
+    type(temperature_type)    , intent(in) :: temperature_vars
+    type(waterflux_type)      , intent(in) :: waterflux_vars
+    type(soilstate_type)      , intent(in) :: soilstate_vars
     !
     ! !LOCAL VARIABLES:
     !
@@ -2961,7 +2748,7 @@
          cpool_to_grainc              => veg_cf%cpool_to_grainc               , & ! Output: [real(r8) (:)   ]  allocation to grain C (gC/m2/s)
          cpool_to_grainc_storage      => veg_cf%cpool_to_grainc_storage       , & ! Output: [real(r8) (:)   ]  allocation to grain C storage (gC/m2/s)
 
-         npool                        => veg_ns%npool                        , & ! Input:  [real(r8) (:)   ]  (gN/m2) plant N pool storage
+          npool                       => veg_ns%npool                        , & ! Input:  [real(r8) (:)   ]  (gN/m2) plant N pool storage
 
          plant_ndemand                => veg_nf%plant_ndemand               , & ! Output: [real(r8) (:)   ]  N flux required to support initial GPP (gN/m2/s)
          plant_nalloc                 => veg_nf%plant_nalloc                , & ! Output: [real(r8) (:)   ]  total allocated N flux (gN/m2/s)
@@ -3078,7 +2865,26 @@
          supplement_to_plantp         => veg_pf%supplement_to_plantp              , &
 
          c13cf => c13_carbonflux_vars, &
-         c14cf => c14_carbonflux_vars  &
+         c14cf => c14_carbonflux_vars, &
+
+           !Variables added for FUN
+         sminn_vr                     =>                              col_ns%sminn_vr                     , & ! Input:  [real(r8) (:,:) ]  (gN/m3) soil mineral N
+         smin_nh4_vr                  =>                 col_ns%smin_nh4_vr                  , & ! Output: [real(r8) (:,:) ]  (gN/m3) soil mineral NH4
+         smin_no3_vr                  =>                     col_ns%smin_no3_vr                  , & ! Output: [real(r8) (:,:) ]  (gN/m3) soil mineral NO3
+         solutionp_vr                 =>                     col_ps%solutionp_vr                   , & ! Input:  [real(r8) (:,:) ]  (gN/m3) soil soluble mineral P ready for plant uptake 
+         frootc                       => veg_cs%frootc                         , & ! Input:  [real(r8) (:)   ]      
+         !frootc                       => carbonstate_vars%frootc_patch         , & ! Input:  [real(r8) (:)   ]                        
+         zwts_col                     => soilhydrology_vars%zwts_col           , & ! col water table depth, the shallower between zwt_perch and zwt   ]    
+         !t_soi10cm_col                => temperature_vars%t_soi10cm_col        , & ! soil temperature in top 10 cm of soil (Kelvin)   ]  
+         t_soisno                     => temperature_vars%t_soisno_col         , & ! Input:   [real(r8) (:,:)]
+         !   soil temperature (Kelvin)  (-nlevsno+1:nlevgrnd) 
+         qflx_tran_veg                => waterflux_vars%qflx_tran_veg_col      ,  & ! col vegetation transpiration (mm H2O/s) (+ = to atm)   ]  
+         !qflx_tran_veg                => waterflux_inst%qflx_tran_veg_patch      & ! Input:   [real(r8) (:)  ]
+         !   vegetation transpiration (mm H2O/s) (+ = to atm) 
+         sminn_to_plant_fun        => veg_nf%sminn_to_plant_fun              , & ! Output:
+         !  [real(r8) (:) ]  Total soil N uptake of FUN (gN/m2/s)        
+         sminp_to_plant_fun        => veg_pf%sminp_to_plant_fun               & ! Output:
+         !  [real(r8) (:) ]  Total soil P uptake of FUN (gP/m2/s)            
          )
 
 !
@@ -3185,8 +2991,20 @@
 
              if (veg_vp%nstor(veg_pp%itype(p)) > 1e-6_r8) then 
                !N pool modification
-               sminn_to_npool(p) = plant_ndemand(p) * min(fpg(c), fpg_p(c))
-               sminp_to_ppool(p) = plant_pdemand(p) * min(fpg(c), fpg_p(c))
+               !sminn_to_npool(p) = plant_ndemand(p) * min(fpg(c), fpg_p(c))
+               !sminp_to_ppool(p) = plant_pdemand(p) * min(fpg(c), fpg_p(c))
+             
+             if(use_fun)then ! if we are using FUN, we get the N available from there.
+             sminn_to_npool(p) = sminn_to_plant_fun(p)
+             else ! no FUN. :( we get N available from the FPG calculation in soilbiogeochemistry competition. 
+             sminn_to_npool(p) = plant_ndemand(p) * min(fpg(c), fpg_p(c))       
+             endif
+
+             if(use_funp )then ! if we are using FUN, we get the P available from there.
+             sminp_to_ppool(p) = sminp_to_plant_fun(p)
+             else ! no FUN. :( we get P available from the FPG calculation in soilbiogeochemistry competition. 
+             sminp_to_ppool(p) = plant_pdemand(p) * min(fpg(c), fpg_p(c))       
+             endif
 
                rc   = veg_vp%nstor(veg_pp%itype(p)) * max(annsum_npp(p) * n_allometry(p) / c_allometry(p), 0.01_r8)
                rc_p = veg_vp%nstor(veg_pp%itype(p)) * max(annsum_npp(p) * p_allometry(p) / c_allometry(p), 0.01_r8)
@@ -3211,8 +3029,23 @@
                plant_palloc(p) = (plant_pdemand(p) + retransp_to_ppool(p)) / r
 
              else
-               sminn_to_npool(p) = plant_ndemand(p) * fpg(c)
-               sminp_to_ppool(p) = plant_pdemand(p) * fpg_p(c)
+
+
+         if(use_fun)then ! if we are using FUN, we get the N available from there.
+            sminn_to_npool(p) = sminn_to_plant_fun(p)
+            !sminp_to_ppool(p) = sminp_to_plant_fun(p)
+         else ! no FUN. :( we get N available from the FPG calculation in soilbiogeochemistry competition. 
+            sminn_to_npool(p) = plant_ndemand(p) * fpg(c)
+            !sminp_to_ppool(p) = plant_pdemand(p) * fpg_p(c)        
+         endif
+
+         if(use_funp)then ! if we are using FUN, we get the N available from there.
+      
+            sminp_to_ppool(p) = sminp_to_plant_fun(p)
+         else ! no FUN. :( we get N available from the FPG calculation in soilbiogeochemistry competition. 
+           
+            sminp_to_ppool(p) = plant_pdemand(p) * fpg_p(c)        
+         endif
 
                plant_nalloc(p) = sminn_to_npool(p) + retransn_to_npool(p)
                plant_palloc(p) = sminp_to_ppool(p) + retransp_to_ppool(p)
@@ -3256,6 +3089,7 @@
                  end if
              endif
   
+           if(.not.use_fun)then  !ORIGINAL CLM(CN) downregulation code.
              excess_cflux(p) = availc(p) - plant_calloc(p)
 
              ! reduce gpp fluxes due to N limitation
@@ -3276,6 +3110,7 @@
                          c14_veg_cf%psnsun_to_cpool(p) = c14_veg_cf%psnsun_to_cpool(p)
                          c14_veg_cf%psnshade_to_cpool(p) = c14_veg_cf%psnshade_to_cpool(p)
                      endif
+             
 
                  else
                      psnsun_to_cpool(p)   = psnsun_to_cpool(p)  *(1._r8 - downreg(p))
@@ -3291,6 +3126,7 @@
                      endif
                  endif
              end if
+          end if !use_fun
          else
              ! 'ECA' or 'MIC' mode
              ! dynamic allocation based on light limitation (more woody growth) vs nutrient limitations (more fine root growth)
@@ -3485,6 +3321,7 @@
              end if
              
              plant_calloc(p) = availc(p)
+
              
              ! here no down-regulation on allocatable C here, NP limitation is implemented in leaf-level NP control on GPP
              if (woody(ivt(p)) == 1.0_r8) then
@@ -3561,6 +3398,7 @@
                   plant_palloc(p) / p_allometry(p) * (1 + cp_stoich_var ) + max((leafp(p)+leafp_storage(p) + leafp_xfer(p))* cpl * &
                   (1 + cp_stoich_var ) - &
                   (leafc(p)+leafc_storage(p) + leafc_xfer(p)),0.0_r8)/dt)
+            
             end if
 
             ! calculate excess carbon
@@ -3910,70 +3748,18 @@
       !! Nitrogen
       if (nu_com .eq. 'RD') then
 
-
+       
         !! Phosphorus
-
-        if( .not. use_nitrif_denitrif) then
-
-        if( .not.cnallocate_carbonphosphorus_only().and. .not.cnallocate_carbonnitrogen_only().and. &
-             .not.cnallocate_carbon_only() )then
-
-          temp_sminn_to_plant(bounds%begc:bounds%endc) = sminn_to_plant(bounds%begc:bounds%endc)
-          temp_sminp_to_plant(bounds%begc:bounds%endc) = sminp_to_plant(bounds%begc:bounds%endc)
-
-          call p2c(bounds,num_soilc,filter_soilc, &
-                sminn_to_npool(bounds%begp:bounds%endp), &
-                sminn_to_plant(bounds%begc:bounds%endc))
-          call p2c(bounds,num_soilc,filter_soilc,       &
-              sminp_to_ppool(bounds%begp:bounds%endp), &
-              sminp_to_plant(bounds%begc:bounds%endc))
-
-          do j = 1, nlevdecomp
-               do fc=1,num_soilc
-                  c = filter_soilc(fc)
-                  if ( temp_sminn_to_plant(c) > 0._r8) then 
-                     sminn_to_plant_vr(c,j)    = sminn_to_plant_vr(c,j) * ( sminn_to_plant(c)/temp_sminn_to_plant(c) )
-                  else
-                     sminn_to_plant_vr(c,j)    = 0._r8
-                  endif
-                   
-                  if ( temp_sminp_to_plant(c) > 0._r8) then 
-                     sminp_to_plant_vr(c,j) =  sminp_to_plant_vr(c,j) * ( sminp_to_plant(c)/temp_sminp_to_plant(c) )
-                  else
-                     sminp_to_plant_vr(c,j) = 0._r8
-                  endif 
-               end do
-          end do             
-
-        end if   ! carbonnitrogenphosphorus
-
-        if( cnallocate_carbonnitrogen_only() )then
-
-          call p2c(bounds,num_soilc,filter_soilc, &
-                  sminp_to_ppool(bounds%begp:bounds%endp), &
-                  sminp_to_plant(bounds%begc:bounds%endc))
-
-          call calc_puptake_prof(bounds, num_soilc, filter_soilc, &
-                  cnstate_vars, phosphorusstate_vars, puptake_prof)
-
-          do j = 1, nlevdecomp
-             do fc=1,num_soilc
-                c = filter_soilc(fc)
-                sminp_to_plant_vr(c,j) = sminp_to_plant(c) * puptake_prof(c,j)
-             end do
-          end do
-        
-        end if  ! carbonnitrogen 
-
-
-        else     ! use_nitrif_denitrif
   
           if( .not.cnallocate_carbonphosphorus_only() .and. &
               .not.cnallocate_carbonnitrogen_only().and.    &
               .not.cnallocate_carbon_only() )then
 
+         
           temp_sminn_to_plant(bounds%begc:bounds%endc) = sminn_to_plant(bounds%begc:bounds%endc)
           temp_sminp_to_plant(bounds%begc:bounds%endc) = sminp_to_plant(bounds%begc:bounds%endc)
+         
+
 
             call p2c(bounds,num_soilc,filter_soilc, &
                 sminn_to_npool(bounds%begp:bounds%endp), &
@@ -4005,6 +3791,7 @@
                end do
             end do
 
+ 
           end if   ! carbonnitrogenphosphorus
 
           if( cnallocate_carbonnitrogen_only() )then
@@ -4027,9 +3814,10 @@
                   endif 
                end do
             end do
+
+
           end if  ! carbonnitrogen
 
-        end if   ! use_nitrif_denitrif
 
       end if ! nu_com .eq. RD
          
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CarbonIsoFluxMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CarbonIsoFluxMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CarbonIsoFluxMod.F90	2020-06-10 13:56:35.063392022 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CarbonIsoFluxMod.F90	2020-06-03 14:09:48.233865288 -0400
@@ -372,6 +372,24 @@
            isoveg_cs%gresp_storage                , veg_cs%gresp_storage, &
            num_soilp                                            , filter_soilp, 1._r8, 0, isotope)
 
+      call CarbonIsoFluxCalc(&
+           isoveg_cf%soilc_change                  , veg_cf%soilc_change, &
+           isoveg_cs%cpool                         , veg_cs%cpool, &
+           num_soilp                                        , filter_soilp, 1._r8, 0, isotope)
+
+      call CarbonIsoFluxCalc(&
+           isoveg_cf%soilc_change_p                  , veg_cf%soilc_change_p, &
+           isoveg_cs%cpool                         , veg_cs%cpool, &
+           num_soilp                                        , filter_soilp, 1._r8, 0, isotope)
+
+      ! Note that cpool_to_resp_patch is a diagnostic flux and therefore this Iso flux calculation
+      ! not strictly required. 
+      !call CarbonIsoFluxCalc(&
+      !     isoveg_cf%cpool_to_resp                 , veg_cf%cpool_to_resp, &
+      !     isoveg_cs%cpool                         , veg_cs%cpool, &
+      !     num_soilp                                        , filter_soilp, 1._r8, 0, isotope)
+
+
       ! call routine to shift patch-level litterfall fluxes to column, for isotopes
       ! the non-isotope version of this routine is called in PhenologyMod.F90.F90
       ! For later clean-up, it would be possible to generalize this function to operate on a single 
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CarbonStateUpdate1Mod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CarbonStateUpdate1Mod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CarbonStateUpdate1Mod.F90	2020-06-10 13:56:35.066392007 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CarbonStateUpdate1Mod.F90	2020-06-02 19:15:45.120997561 -0400
@@ -367,6 +367,9 @@
          ! excess respiration flux from cpool
          veg_cs%cpool(p) = veg_cs%cpool(p) - veg_cf%xr(p)*dt
 
+         !RF Add in the carbon spent on uptake respiration. -R. BRAGHIERE
+         veg_cs%cpool(p)= veg_cs%cpool(p) - veg_cf%soilc_change(p)*dt - veg_cf%soilc_change_p(p)*dt
+
          ! maintenance respiration fluxes from xsmrpool
          veg_cs%xsmrpool(p) = veg_cs%xsmrpool(p) + veg_cf%cpool_to_xsmrpool(p)*dt
          veg_cs%xsmrpool(p) = veg_cs%xsmrpool(p) - veg_cf%leaf_xsmr(p)*dt
@@ -388,6 +391,16 @@
          end if
 
          ! allocation fluxes
+          ! if (.not.use_fun) then
+          !    veg_cf%cpool_to_leafc(p) = veg_cf%cpool_to_leafc(p) - veg_cf%cpool_to_leafc_resp(p)
+          !    veg_cf%cpool_to_leafc_storage(p) = veg_cf%cpool_to_leafc_storage(p) - &
+          !         veg_cf%cpool_to_leafc_storage_resp(p)
+          !    veg_cf%cpool_to_frootc(p) = veg_cf%cpool_to_frootc(p) - veg_cf%cpool_to_frootc_resp(p)
+          !    veg_cf%cpool_to_frootc_storage(p) = veg_cf%cpool_to_frootc_storage(p) &
+          !       - veg_cf%cpool_to_frootc_storage_resp(p)
+          ! end if
+
+
          veg_cs%cpool(p)           = veg_cs%cpool(p)          - veg_cf%cpool_to_leafc(p)*dt
          veg_cs%leafc(p)           = veg_cs%leafc(p)          + veg_cf%cpool_to_leafc(p)*dt
          veg_cs%cpool(p)           = veg_cs%cpool(p)          - veg_cf%cpool_to_leafc_storage(p)*dt
@@ -397,6 +410,14 @@
          veg_cs%cpool(p)           = veg_cs%cpool(p)          - veg_cf%cpool_to_frootc_storage(p)*dt
          veg_cs%frootc_storage(p)  = veg_cs%frootc_storage(p) + veg_cf%cpool_to_frootc_storage(p)*dt
          if (woody(ivt(p)) == 1._r8) then
+              !if (.not.use_fun) then
+              !   veg_cf%cpool_to_livecrootc(p) = veg_cf%cpool_to_livecrootc(p) - veg_cf%cpool_to_livecrootc_resp(p)
+              !   veg_cf%cpool_to_livecrootc_storage(p) = veg_cf%cpool_to_livecrootc_storage(p) - &
+              !        veg_cf%cpool_to_livecrootc_storage_resp(p)
+              !   veg_cf%cpool_to_livestemc(p) = veg_cf%cpool_to_livestemc(p) - veg_cf%cpool_to_livestemc_resp(p)
+              !   veg_cf%cpool_to_livestemc_storage(p) = veg_cf%cpool_to_livestemc_storage(p) - &
+              !   veg_cf%cpool_to_livestemc_storage_resp(p)
+              !end if
             veg_cs%cpool(p)               = veg_cs%cpool(p)              - veg_cf%cpool_to_livestemc(p)*dt
             veg_cs%livestemc(p)           = veg_cs%livestemc(p)          + veg_cf%cpool_to_livestemc(p)*dt
             veg_cs%cpool(p)               = veg_cs%cpool(p)              - veg_cf%cpool_to_livestemc_storage(p)*dt
@@ -415,6 +436,11 @@
             veg_cs%deadcrootc_storage(p)  = veg_cs%deadcrootc_storage(p) + veg_cf%cpool_to_deadcrootc_storage(p)*dt
          end if
          if (ivt(p) >= npcropmin) then ! skip 2 generic crops
+              !if (.not.use_fun) then
+              !   veg_cf%cpool_to_livestemc(p) = veg_cf%cpool_to_livestemc(p) - veg_cf%cpool_to_livestemc_resp(p)
+              !   veg_cf%cpool_to_livestemc_storage(p) = veg_cf%cpool_to_livestemc_storage(p) - &
+              !   veg_cf%cpool_to_livestemc_storage_resp(p)
+              !end if
             veg_cs%cpool(p)               = veg_cs%cpool(p)              - veg_cf%cpool_to_livestemc(p)*dt
             veg_cs%livestemc(p)           = veg_cs%livestemc(p)          + veg_cf%cpool_to_livestemc(p)*dt
             veg_cs%cpool(p)               = veg_cs%cpool(p)              - veg_cf%cpool_to_livestemc_storage(p)*dt
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CH4Mod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CH4Mod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CH4Mod.F90	2020-06-10 13:56:35.022392229 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CH4Mod.F90	2020-07-13 16:54:13.420239845 -0400
@@ -17,7 +17,7 @@
   use clm_varcon         , only : catomw, s_con, d_con_w, d_con_g, c_h_inv, kh_theta, kh_tbase
   use landunit_varcon    , only : istdlak
   use clm_time_manager   , only : get_step_size, get_nstep
-  use clm_varctl         , only : iulog, use_cn, use_nitrif_denitrif, use_lch4
+  use clm_varctl         , only : iulog, use_cn, use_nitrif_denitrif, use_lch4, use_fun, use_funp
   use abortutils         , only : endrun
   use decompMod          , only : bounds_type
   use SharedParamsMod  , only : ParamsShareInst
@@ -3078,8 +3078,10 @@
                     source(c,j,1) + conc_ch4(c,j) / dtime, c, j
                g = col_pp%gridcell(c)
                write(iulog,*)'Latdeg,Londeg=',grc_pp%latdeg(g),grc_pp%londeg(g)
+              !if(.not.use_fun)then
                call endrun(msg=' ERROR: Methane demands exceed methane available.'&
                     //errMsg(__FILE__, __LINE__))
+              !end if
             else if (ch4stress(c,j) < 1._r8 .and. source(c,j,1) + conc_ch4(c,j) / dtime > 1.e-12_r8) then
                write(iulog,*) 'Methane limited, yet some left over. Error in methane competition (mol/m^3/s), c,j:', &
                     source(c,j,1) + conc_ch4(c,j) / dtime, c, j
@@ -3561,6 +3563,7 @@
 
          errch4(c) = errch4(c) + (ch4_surf_aere(c) + ch4_surf_ebul(c) + ch4_surf_diff(c))*dtime
 
+
          if (abs(errch4(c)) < 1.e-8_r8) then
             ch4_surf_diff(c) = ch4_surf_diff(c) - errch4(c)/dtime
          else ! errch4 > 1e-8 mol / m^2 / timestep
@@ -3568,8 +3571,18 @@
                  nstep,c,errch4(c)
             g = col_pp%gridcell(c)
             write(iulog,*)'Latdeg,Londeg=',grc_pp%latdeg(g),grc_pp%londeg(g)
+            !if(.not.use_fun)then
             call endrun(msg=' ERROR: CH4 Conservation Error in CH4Mod during diffusion'//&
                  errMsg(__FILE__, __LINE__))
+            !end if
+            !else
+            !ch4_surf_diff(c) = ch4_surf_diff(c) - errch4(c)/dtime
+            ! write(iulog,*)'CH4 Conservation Error in CH4Mod during diffusion, nstep, c, errch4 (mol /m^2.timestep)', &
+            !     nstep,c,errch4(c)
+            !g = col_pp%gridcell(c)
+            !write(iulog,*)'Latdeg,Londeg=',grc_pp%latdeg(g),grc_pp%londeg(g)
+      
+            !end if
          end if
       end do
 
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CNCarbonFluxType.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CNCarbonFluxType.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CNCarbonFluxType.F90	2020-06-10 13:57:17.290178903 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CNCarbonFluxType.F90	2020-06-03 15:58:17.307229933 -0400
@@ -15,7 +15,7 @@
   use VegetationType         , only : veg_pp
   use ColumnType             , only : col_pp                
   use LandunitType           , only : lun_pp
-  use clm_varctl             , only : nu_com
+  use clm_varctl             , only : nu_com, use_fun, use_funp
   use clm_varctl             , only : use_clm_interface, use_pflotran, pf_cmode, use_vertsoilc
   use AnnualFluxDribbler     , only : annual_flux_dribbler_type, annual_flux_dribbler_gridcell
   ! 
@@ -146,11 +146,16 @@
 
      ! leaf and fine root litterfall fluxes                          
      real(r8), pointer :: leafc_to_litter_patch                     (:)     ! leaf C litterfall (gC/m2/s)
+     real(r8), pointer :: leafc_to_litter_fun_patch                     (:)     !leaf C litterfall used by FUN (gC/m2/s)
+     real(r8), pointer :: leafc_to_litter_funp_patch                     (:)     !leaf C litterfall used by FUN (gC/m2/s)
+
      real(r8), pointer :: frootc_to_litter_patch                    (:)     ! fine root C litterfall (gC/m2/s)
      real(r8), pointer :: livestemc_to_litter_patch                 (:)     ! live stem C litterfall (gC/m2/s)
      real(r8), pointer :: grainc_to_food_patch                      (:)     ! grain C to food for prognostic crop(gC/m2/s)
 
-     ! maintenance respiration fluxes                          
+
+     ! maintenance respiration fluxes  
+     !real(r8), pointer :: cpool_to_resp_patch                       (:)     ! CNflex excess C maintenance respiration (gC/m2/s)                        
      real(r8), pointer :: leaf_mr_patch                             (:)     ! leaf maintenance respiration (gC/m2/s)
      real(r8), pointer :: froot_mr_patch                            (:)     ! fine root maintenance respiration (gC/m2/s)
      real(r8), pointer :: livestem_mr_patch                         (:)     ! live stem maintenance respiration (gC/m2/s)
@@ -413,6 +418,10 @@
      real(r8), pointer :: annsum_npp_patch            (:) ! patch annual sum of NPP (gC/m2/yr)
      real(r8), pointer :: annsum_npp_col              (:) ! col annual sum of NPP, averaged from pft-level (gC/m2/yr)
      real(r8), pointer :: lag_npp_col                 (:) ! col lagged net primary production (gC/m2/s)
+     !Variable used by FUN
+     real(r8), pointer :: soilc_change_col            (:) ! col total used C from soil        (gC/m2/s)
+     real(r8), pointer :: soilc_change_p_col          (:) ! col total used C from soil        (gC/m2/s)
+
      
      ! debug
      real(r8), pointer :: plant_to_litter_cflux		  (:) ! for the purpose of mass balance check
@@ -430,6 +439,39 @@
      real(r8), pointer :: f_co2_soil_col                            (:)     ! total soil-atm. CO2 exchange (gC/m2/s)
     !------------------------------------------------------------------------
 
+    !Variables used by FUN
+     real(r8), pointer :: npp_Nactive_patch                         (:)     ! C used by mycorrhizal uptake    (gC/m2/s)
+     real(r8), pointer :: npp_burnedoff_patch                       (:)     ! C that cannot be used for N uptake   (gC/m2/s)
+     real(r8), pointer :: npp_burnedoff_p_patch                       (:)     ! C that cannot be used for P uptake   (gC/m2/s)
+     real(r8), pointer :: npp_Nnonmyc_patch                         (:)     ! C used by non-myc uptake        (gC/m2/s)
+     real(r8), pointer :: npp_Nam_patch                             (:)     ! C used by AM plant              (gC/m2/s)
+     real(r8), pointer :: npp_Necm_patch                            (:)     ! C used by ECM plant             (gC/m2/s)
+     real(r8), pointer :: npp_Nactive_no3_patch                     (:)     ! C used by mycorrhizal uptake    (gC/m2/s)
+     real(r8), pointer :: npp_Nactive_nh4_patch                     (:)     ! C used by mycorrhizal uptake    (gC/m2/s)
+     real(r8), pointer :: npp_Nnonmyc_no3_patch                     (:)     ! C used by non-myc               (gC/m2/s)
+     real(r8), pointer :: npp_Nnonmyc_nh4_patch                     (:)     ! C used by non-myc               (gC/m2/s)
+     real(r8), pointer :: npp_Nam_no3_patch                         (:)     ! C used by AM plant              (gC/m2/s)
+     real(r8), pointer :: npp_Nam_nh4_patch                         (:)     ! C used by AM plant              (gC/m2/s)
+     real(r8), pointer :: npp_Necm_no3_patch                        (:)     ! C used by ECM plant             (gC/m2/s)
+     real(r8), pointer :: npp_Necm_nh4_patch                        (:)     ! C used by ECM plant             (gC/m2/s)
+     real(r8), pointer :: npp_Nfix_patch                            (:)     ! C used by Symbiotic BNF         (gC/m2/s)
+     real(r8), pointer :: npp_Nretrans_patch                        (:)     ! C used by retranslocation       (gC/m2/s)
+     real(r8), pointer :: npp_Nuptake_patch                         (:)     ! Total C used by N uptake in FUN (gC/m2/s)
+     real(r8), pointer :: npp_growth_patch                          (:)     ! Total C u for growth in FUN      (gC/m2/s)   
+     real(r8), pointer :: leafc_change_patch                        (:)     ! Total used C from leaves        (gC/m2/s)
+     real(r8), pointer :: soilc_change_patch                        (:)     ! Total used C from soil          (gC/m2/s)
+     real(r8), pointer :: soilc_change_p_patch                        (:)     ! Total used C from soil          (gC/m2/s)
+
+    !Variables used by FUN-P
+     real(r8), pointer :: npp_Pactive_patch                         (:)     ! C used by mycorrhizal uptake    (gC/m2/s)
+     real(r8), pointer :: npp_Pnonmyc_patch                         (:)     ! C used by non-myc uptake        (gC/m2/s)
+     real(r8), pointer :: npp_Pam_patch                             (:)     ! C used by AM plant              (gC/m2/s)
+     real(r8), pointer :: npp_Pecm_patch                            (:)     ! C used by ECM plant             (gC/m2/s)
+     real(r8), pointer :: npp_Pretrans_patch                        (:)     ! C used by retranslocation       (gC/m2/s)
+     real(r8), pointer :: npp_Puptake_patch                         (:)     ! Total C used by P uptake in FUN (gC/m2/s)
+
+
+
      ! Objects that help convert once-per-year dynamic land cover changes into fluxes
      ! that are dribbled throughout the year
      type(annual_flux_dribbler_type) :: dwt_conv_cflux_dribbler
@@ -589,7 +631,10 @@
         allocate(this%livecrootc_xfer_to_livecrootc_patch      (begp:endp)) ; this%livecrootc_xfer_to_livecrootc_patch    (:) = nan
         allocate(this%deadcrootc_xfer_to_deadcrootc_patch      (begp:endp)) ; this%deadcrootc_xfer_to_deadcrootc_patch    (:) = nan
         allocate(this%leafc_to_litter_patch                    (begp:endp)) ; this%leafc_to_litter_patch                  (:) = nan
+        allocate(this%leafc_to_litter_fun_patch                  (begp:endp)) ; this%leafc_to_litter_fun_patch            (:) = nan
+        allocate(this%leafc_to_litter_funp_patch                  (begp:endp)) ; this%leafc_to_litter_funp_patch            (:) = nan
         allocate(this%frootc_to_litter_patch                   (begp:endp)) ; this%frootc_to_litter_patch                 (:) = nan
+        !allocate(this%cpool_to_resp_patch                       (begp:endp)) ; this%cpool_to_resp_patch                    (:) = nan
         allocate(this%leaf_mr_patch                            (begp:endp)) ; this%leaf_mr_patch                          (:) = nan
         allocate(this%froot_mr_patch                           (begp:endp)) ; this%froot_mr_patch                         (:) = nan
         allocate(this%livestem_mr_patch                        (begp:endp)) ; this%livestem_mr_patch                      (:) = nan
@@ -702,6 +747,38 @@
         allocate(this%agwdnpp_patch                             (begp:endp)) ; this%agwdnpp_patch                          (:) = nan
 
 
+    !Variables used by FUN
+    allocate(this%npp_Nactive_patch       (begp:endp)) ; this%npp_Nactive_patch       (:) = nan
+    allocate(this%npp_burnedoff_patch     (begp:endp)) ; this%npp_burnedoff_patch     (:) = nan
+    allocate(this%npp_burnedoff_p_patch     (begp:endp)) ; this%npp_burnedoff_p_patch     (:) = nan
+    allocate(this%npp_Nnonmyc_patch       (begp:endp)) ; this%npp_Nnonmyc_patch       (:) = nan
+    allocate(this%npp_Nam_patch           (begp:endp)) ; this%npp_Nam_patch           (:) = nan
+    allocate(this%npp_Necm_patch          (begp:endp)) ; this%npp_Necm_patch          (:) = nan
+    allocate(this%npp_Nactive_no3_patch   (begp:endp)) ; this%npp_Nactive_no3_patch   (:) = nan
+    allocate(this%npp_Nactive_nh4_patch   (begp:endp)) ; this%npp_Nactive_nh4_patch   (:) = nan
+    allocate(this%npp_Nnonmyc_no3_patch   (begp:endp)) ; this%npp_Nnonmyc_no3_patch   (:) = nan
+    allocate(this%npp_Nnonmyc_nh4_patch   (begp:endp)) ; this%npp_Nnonmyc_nh4_patch   (:) = nan
+    allocate(this%npp_Nam_no3_patch       (begp:endp)) ; this%npp_Nam_no3_patch       (:) = nan
+    allocate(this%npp_Nam_nh4_patch       (begp:endp)) ; this%npp_Nam_nh4_patch       (:) = nan
+    allocate(this%npp_Necm_no3_patch      (begp:endp)) ; this%npp_Necm_no3_patch      (:) = nan
+    allocate(this%npp_Necm_nh4_patch      (begp:endp)) ; this%npp_Necm_nh4_patch      (:) = nan
+    allocate(this%npp_Nfix_patch          (begp:endp)) ; this%npp_Nfix_patch          (:) = nan
+    allocate(this%npp_Nretrans_patch      (begp:endp)) ; this%npp_Nretrans_patch      (:) = nan
+    allocate(this%npp_Nuptake_patch       (begp:endp)) ; this%npp_Nuptake_patch       (:) = nan
+    allocate(this%npp_growth_patch       (begp:endp)) ; this%npp_growth_patch       (:) = nan
+    allocate(this%leafc_change_patch      (begp:endp)) ; this%leafc_change_patch      (:) = nan
+    allocate(this%soilc_change_patch      (begp:endp)) ; this%soilc_change_patch      (:) = nan
+    allocate(this%soilc_change_p_patch      (begp:endp)) ; this%soilc_change_p_patch      (:) = nan
+
+    !Variables used by FUN-P
+    allocate(this%npp_Pactive_patch       (begp:endp)) ; this%npp_Pactive_patch       (:) = nan
+    allocate(this%npp_Pnonmyc_patch       (begp:endp)) ; this%npp_Pnonmyc_patch       (:) = nan
+    allocate(this%npp_Pam_patch           (begp:endp)) ; this%npp_Pam_patch           (:) = nan
+    allocate(this%npp_Pecm_patch          (begp:endp)) ; this%npp_Pecm_patch          (:) = nan
+    allocate(this%npp_Pretrans_patch      (begp:endp)) ; this%npp_Pretrans_patch      (:) = nan
+    allocate(this%npp_Puptake_patch       (begp:endp)) ; this%npp_Puptake_patch       (:) = nan
+
+
      end if ! if(.not.use_fates)
 
      allocate(this%t_scalar_col                      (begc:endc,1:nlevdecomp_full)); this%t_scalar_col (:,:)=spval
@@ -842,6 +919,8 @@
      allocate(this%annsum_npp_patch      (begp:endp)) ; this%annsum_npp_patch      (:) = nan
      allocate(this%annsum_npp_col        (begc:endc)) ; this%annsum_npp_col        (:) = nan
      allocate(this%lag_npp_col           (begc:endc)) ; this%lag_npp_col           (:) = spval
+     allocate(this%soilc_change_col      (begc:endc)) ; this%soilc_change_col      (:) = spval
+     allocate(this%soilc_change_p_col      (begc:endc)) ; this%soilc_change_p_col      (:) = spval
 
      ! debug
      allocate(this%plant_to_litter_cflux (begc:endc)) ;	this%plant_to_litter_cflux (:) = nan
@@ -850,6 +929,7 @@
      allocate(this%allocation_stem       (begp:endp)) ; this%allocation_stem       (:) = nan
      allocate(this%allocation_froot      (begp:endp)) ; this%allocation_froot      (:) = nan
 
+
      ! clm_interface & pflotran
      !------------------------------------------------------------------------
      allocate(this%externalc_to_decomp_cpools_col(begc:endc,1:nlevdecomp_full,1:ndecomp_pools))
@@ -1025,6 +1105,8 @@
              this%plant_calloc_patch(p)          = spval
              this%prev_leafc_to_litter_patch(p)  = spval
              this%prev_frootc_to_litter_patch(p) = spval
+             this%leafc_to_litter_fun_patch(p)   = spval
+             this%leafc_to_litter_funp_patch(p)   = spval
              if ( use_c13 ) then
                 this%xsmrpool_c13ratio_patch(p)  = spval
              endif
@@ -1036,6 +1118,8 @@
              this%xsmrpool_recover_patch(p)      = 0._r8
              this%excess_cflux_patch(p)          = 0._r8
              this%prev_leafc_to_litter_patch(p)  = 0._r8
+             this%leafc_to_litter_fun_patch(p)   = 0._r8
+             this%leafc_to_litter_funp_patch(p)   = 0._r8
              this%prev_frootc_to_litter_patch(p) = 0._r8
              this%plant_calloc_patch(p)          = 0._r8
           end if
@@ -1271,7 +1355,9 @@
           this%livecrootc_xfer_to_livecrootc_patch(i)       = value_patch
           this%deadcrootc_xfer_to_deadcrootc_patch(i)       = value_patch
           this%leafc_to_litter_patch(i)                     = value_patch
+          !this%leafc_to_litter_fun_patch(i)                 = value_patch
           this%frootc_to_litter_patch(i)                    = value_patch
+          !this%cpool_to_resp_patch(i)                       = value_patch
           this%leaf_mr_patch(i)                             = value_patch
           this%froot_mr_patch(i)                            = value_patch
           this%livestem_mr_patch(i)                         = value_patch
@@ -1357,6 +1443,39 @@
           this%woodc_alloc_patch(i)                         = value_patch
           this%woodc_loss_patch(i)                          = value_patch
           this%xsmrpool_turnover_patch(i)                   = value_patch
+
+          !Variables used by FUN
+          this%npp_Nactive_patch(i)                         = value_patch
+          this%npp_burnedoff_patch(i)                       = value_patch
+          this%npp_burnedoff_p_patch(i)                     = value_patch
+          this%npp_Nnonmyc_patch(i)                         = value_patch
+          this%npp_Nam_patch(i)                             = value_patch
+          this%npp_Necm_patch(i)                            = value_patch
+          this%npp_Nactive_no3_patch(i)                     = value_patch
+          this%npp_Nactive_nh4_patch(i)                     = value_patch
+          this%npp_Nnonmyc_no3_patch(i)                     = value_patch
+          this%npp_Nnonmyc_nh4_patch(i)                     = value_patch
+          this%npp_Nam_no3_patch(i)                         = value_patch
+          this%npp_Nam_nh4_patch(i)                         = value_patch
+          this%npp_Necm_no3_patch(i)                        = value_patch
+          this%npp_Necm_nh4_patch(i)                        = value_patch
+          this%npp_Nfix_patch(i)                            = value_patch
+          this%npp_Nretrans_patch(i)                        = value_patch
+          this%npp_Nuptake_patch(i)                         = value_patch
+          this%npp_growth_patch(i)                          = value_patch
+          this%leafc_change_patch(i)                        = value_patch
+          this%soilc_change_patch(i)                        = value_patch
+
+
+          !Variables used by FUN-P
+          this%npp_Pactive_patch(i)                         = value_patch
+          this%npp_Pnonmyc_patch(i)                         = value_patch
+          this%npp_Pam_patch(i)                             = value_patch
+          this%npp_Pecm_patch(i)                            = value_patch
+          this%npp_Pretrans_patch(i)                        = value_patch
+          this%npp_Puptake_patch(i)                         = value_patch
+          this%soilc_change_p_patch(i)                      = value_patch
+
        end do
     end if !(.not.use_fates)
 
@@ -1481,6 +1600,10 @@
        this%vegfire_col(i)               = value_column       
        this%wood_harvestc_col(i)         = value_column 
        this%hrv_xsmrpool_to_atm_col(i)   = value_column
+       !Variable used by FUN
+       this%soilc_change_col(i)   = value_column
+       this%soilc_change_p_col(i) = value_column
+
     end do
 
     do k = 1, ndecomp_pools
@@ -1641,6 +1764,16 @@
             this%livestem_mr_patch(p) + &
             this%livecroot_mr_patch(p)
 
+
+       !if (.not.use_fun) then
+       !   this%mr_patch(p)  = &
+       !        this%cpool_to_resp_patch(p)     + &
+       !        this%leaf_mr_patch(p)     + &
+       !        this%froot_mr_patch(p)    + &
+       !        this%livestem_mr_patch(p) + &
+       !        this%livecroot_mr_patch(p)
+       !end if
+
        ! growth respiration (GR)
        ! current GR is respired this time step for new growth displayed in this timestep
        this%current_gr_patch(p) = &
@@ -1715,6 +1848,14 @@
           end if
        end if
 
+       !soilc_change  when FUN is on!
+       if (use_fun) then
+          this%ar_patch(p) = this%ar_patch(p) + this%soilc_change_patch(p)
+       end if
+       !soilc_change_p  when FUNP is on!
+       if (use_funp) then
+          this%ar_patch(p) = this%ar_patch(p) + this%soilc_change_p_patch(p)
+       end if
 
 
        ! net primary production (NPP)
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CNCarbonStateType.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CNCarbonStateType.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CNCarbonStateType.F90	2020-06-10 13:56:35.037392153 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CNCarbonStateType.F90	2020-05-10 20:09:52.140086440 -0400
@@ -44,6 +44,8 @@
      real(r8), pointer :: leafc_patch              (:)     ! (gC/m2) leaf C
      real(r8), pointer :: leafc_storage_patch      (:)     ! (gC/m2) leaf C storage
      real(r8), pointer :: leafc_xfer_patch         (:)     ! (gC/m2) leaf C transfer
+     real(r8), pointer :: leafc_storage_xfer_acc_patch   (:) ! (gC/m2) Accmulated leaf C transfer
+     real(r8), pointer :: storage_cdemand_patch    (:) ! (gC/m2)       C use from the C storage pool 
      real(r8), pointer :: frootc_patch             (:)     ! (gC/m2) fine root C
      real(r8), pointer :: frootc_storage_patch     (:)     ! (gC/m2) fine root C storage
      real(r8), pointer :: frootc_xfer_patch        (:)     ! (gC/m2) fine root C transfer
@@ -196,6 +198,8 @@
        allocate(this%leafc_patch              (begp :endp))                   ;     this%leafc_patch              (:)   = nan
        allocate(this%leafc_storage_patch      (begp :endp))                   ;     this%leafc_storage_patch      (:)   = nan
        allocate(this%leafc_xfer_patch         (begp :endp))                   ;     this%leafc_xfer_patch         (:)   = nan
+       allocate(this%leafc_storage_xfer_acc_patch         (begp :endp))                   ;     this%leafc_storage_xfer_acc_patch (:)   = nan
+       allocate(this%storage_cdemand_patch         (begp :endp))                   ;     this%storage_cdemand_patch    (:)   = nan
        allocate(this%frootc_patch             (begp :endp))                   ;     this%frootc_patch             (:)   = nan
        allocate(this%frootc_storage_patch     (begp :endp))                   ;     this%frootc_storage_patch     (:)   = nan
        allocate(this%frootc_xfer_patch        (begp :endp))                   ;     this%frootc_xfer_patch        (:)   = nan
@@ -468,6 +472,8 @@
                 end if
              end if
              this%leafc_xfer_patch(p) = 0._r8
+             this%leafc_storage_xfer_acc_patch(p) = 0._r8
+             this%storage_cdemand_patch(p) = 0._r8
 
              this%frootc_patch(p)            = 0._r8 
              this%frootc_storage_patch(p)    = 0._r8 
@@ -698,6 +704,8 @@
           this%leafc_patch(i)              = value_patch
           this%leafc_storage_patch(i)      = value_patch
           this%leafc_xfer_patch(i)         = value_patch
+          this%leafc_storage_xfer_acc_patch(i)  = value_patch
+          this%storage_cdemand_patch(i)    = value_patch
           this%frootc_patch(i)             = value_patch
           this%frootc_storage_patch(i)     = value_patch
           this%frootc_xfer_patch(i)        = value_patch
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CNEcosystemDynBetrMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CNEcosystemDynBetrMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CNEcosystemDynBetrMod.F90	2020-06-10 13:56:35.042392128 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CNEcosystemDynBetrMod.F90	2020-05-10 20:09:52.120086557 -0400
@@ -10,6 +10,7 @@
   use shr_kind_mod              , only : r8 => shr_kind_r8
   use shr_sys_mod               , only : shr_sys_flush
   use clm_varctl                , only : use_c13, use_c14, use_fates, use_dynroot
+  use clm_varctl                , only : use_fun
   use decompMod                 , only : bounds_type
   use perf_mod                  , only : t_startf, t_stopf
   use spmdMod                   , only : masterproc
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CNFUNMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CNFUNMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CNFUNMod.F90	1969-12-31 19:00:00.000000000 -0500
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CNFUNMod.F90	2020-09-23 20:47:27.541839336 -0400
@@ -0,0 +1,3348 @@
+module CNFUNMod
+
+!#include "shr_assert.h"
+!--------------------------------------------------------------------
+  !---
+! ! DESCRIPTION
+! ! The FUN model developed by Fisher et al. 2010 and
+! ! end Brzostek et al. 2014. Coded by Mingjie Shi 2015.
+! ! Coding logic and structure altered by Rosie Fisher. October 2015. 
+! ! Critically, this removes the 'FUN-resistors' idea of Brzostek et
+  !  al. 2014
+! ! and replaces it with uptake that is proportional to the N/C
+  !  exchange rate. 
+! ! and adjusts the logic so that FUN does not depends upon the
+  !  CLM4.0 'FPG' downregulation idea
+! ! and instead it takes C spent on N uptake away from growth.
+! ! The critical output of this code are sminn_to_plant_fun and
+  !  npp_Nuptake, which are the N 
+! ! available to the plant for growth, and the C spent on obtaining
+  !  it. 
+! ! Coding logic added in ELM with Phosphorus costs 
+  ! by Renato Braghiere 2019.
+
+
+  ! !USES:
+  use shr_kind_mod        , only : r8 => shr_kind_r8
+  use shr_log_mod         , only : errMsg => shr_log_errMsg
+  use clm_varcon          , only : dzsoi_decomp
+  use clm_varcon          , only : secspday, smallValue, fun_period 
+  use clm_varcon          , only : tfrz, spval
+  use clm_varctl          , only : use_c13, use_c14, use_nitrif_denitrif, spinup_state
+  use clm_varctl          , only : use_funp
+  use clm_varctl          , only : nyears_ad_carbon_only
+  use abortutils          , only : endrun
+  use decompMod           , only : bounds_type
+  use subgridAveMod       , only : p2c
+  use CanopyStateType     , only : canopystate_type
+  use CNCarbonFluxType    , only : carbonflux_type
+  use CNCarbonStateType   , only : carbonstate_type
+  use CNNitrogenFluxType  , only : nitrogenflux_type
+  use CNNitrogenStateType , only : nitrogenstate_type
+  !!! add phosphorus
+  use PhosphorusFluxType  , only : phosphorusflux_type
+  use PhosphorusStateType , only : phosphorusstate_type
+  use CNStateType         , only : cnstate_type
+  use PhotosynthesisType  , only : photosyns_type
+  use CropType            , only : crop_type
+  use VegetationPropertiesType      , only : veg_vp
+  use LandunitType        , only : lun_pp                
+  use ColumnType          , only : col_pp
+  use ColumnDataType      , only : col_ws
+  use ColumnDataType      , only : col_cf, c13_col_cf, c14_col_cf
+  use ColumnDataType      , only : col_ns, col_nf, col_ps, col_pf 
+  use ColumnDataType      , only : col_es 
+  use VegetationType      , only : veg_pp
+  use VegetationDataType  , only : veg_cs, veg_ns, veg_nf, veg_ps, veg_pf
+  use VegetationDataType  , only : veg_cf, c13_veg_cf, c14_veg_cf  
+  use VegetationDataType  , only : veg_wf
+  ! bgc interface & pflotran module switches
+  use clm_varctl          , only : use_clm_interface,use_clm_bgc, use_pflotran, pf_cmode
+  use clm_varctl          , only : nu_com
+  use SoilStatetype       , only : soilstate_type
+  use WaterStateType      , only : waterstate_type
+  use clm_varctl          , only : NFIX_PTASE_plant
+
+  ! used variables for FUN
+  use SoilHydrologyType   , only : soilhydrology_type
+  use TemperatureType     , only : temperature_type
+  use WaterFluxType       , only : waterflux_type
+  use perf_mod            , only : t_startf, t_stopf
+  !
+  !
+  implicit none
+  save
+  private
+
+! !PUBLIC MEMBER FUNCTIONS:
+  public:: readParams            ! Read in parameters needed for FUN
+  public:: CNFUNInit             ! FUN calculation initialization
+  public:: CNFUN                 ! Run FUN
+  
+  type, private :: params_type
+     real(r8) :: ndays_on        ! number of days to complete leaf onset
+     real(r8) :: ndays_off       ! number of days to complete leaf offset
+  end type params_type   
+ 
+  !
+  type(params_type), private :: params_inst  ! params_inst is
+  !  populated in readParamsMod
+  !
+  !
+  ! !PRIVATE DATA MEMBERS:
+  real(r8) :: dt              ! decomp timestep (seconds)
+  real(r8) :: ndays_on        ! number of days to complete onset
+  real(r8) :: ndays_off       ! number of days to complete offset
+  
+  integer, private, parameter :: COST_METHOD = 2 !new way of doing the N uptake
+  ! resistances. see teamwork thread on over-cheap uptake in N
+  !  resistors. 
+  integer,  private, parameter :: nstp            = 2             ! Number of
+  !  calculation part
+  integer,  private, parameter :: ncost6          = 6             ! Number of
+  !  N transport pathways
+  integer,  private, parameter :: pcost3          = 3             ! Number of
+  !  P transport pathways
+
+  character(len=*), parameter, private :: sourcefile = &
+       __FILE__
+
+!
+!--------------------------------------------------------------------
+  !---
+ contains
+!--------------------------------------------------------------------
+   !---
+ subroutine readParams ( ncid )
+  !
+  ! !USES:
+  use ncdio_pio , only : file_desc_t,ncd_io
+
+  ! !ARGUMENTS:
+  implicit none
+  type(file_desc_t),intent(inout) :: ncid   ! pio netCDF file id
+  !
+  ! !LOCAL VARIABLES:
+  character(len=32)  :: subname = 'CNFUNParamsType'
+  character(len=100) :: errCode = '-Error reading in parameters file:'
+  logical            :: readv ! has variable been read in or not
+  real(r8)           :: tempr ! temporary to read in parameter
+  character(len=100) :: tString ! temp. var for reading
+!--------------------------------------------------------------------
+  !---
+
+  ! read in parameters
+
+    tString='ndays_on'
+    call ncd_io(varname=trim(tString),data=tempr, flag='read', ncid=ncid, readvar=readv)
+    if ( .not. readv ) call endrun( msg=trim(errCode)//trim(tString)//errMsg(__FILE__, __LINE__))
+    params_inst%ndays_on=tempr
+
+    tString='ndays_off'
+    call ncd_io(varname=trim(tString),data=tempr, flag='read', ncid=ncid, readvar=readv)
+    if ( .not. readv ) call endrun( msg=trim(errCode)//trim(tString)//errMsg(__FILE__, __LINE__))
+    params_inst%ndays_off=tempr
+
+
+ end subroutine readParams
+
+!--------------------------------------------------------------------
+ !---
+
+subroutine CNFUNInit (bounds,cnstate_vars,carbonstate_vars, &
+                      nitrogenstate_vars,phosphorusstate_vars)
+  !
+  ! !DESCRIPTION:
+  !
+  ! !USES:
+  use clm_varcon      , only: secspday, fun_period
+  use clm_time_manager, only: get_step_size, get_nstep
+  use clm_time_manager, only: get_curr_date, get_days_per_year
+  use clm_varctl      , only: iulog, use_funp
+  use VegetationDataType  , only : veg_cs, veg_ns, veg_ps
+  !
+  ! !ARGUMENTS:
+  type(bounds_type)           , intent(in)    :: bounds
+  type(cnstate_type)          , intent(inout) :: cnstate_vars
+  type(carbonstate_type)      , intent(inout) :: carbonstate_vars
+  type(nitrogenstate_type)    , intent(inout) :: nitrogenstate_vars
+  type(phosphorusstate_type)  , intent(inout) :: phosphorusstate_vars
+
+  !
+  ! !LOCAL VARIABLES:
+  real(r8)          :: dayspyr                  ! days per year (days)
+  real(r8)          :: timestep_fun             ! Timestep length for
+  !  FUN (s)
+  real(r8)          :: numofyear                ! number of days per
+  !  year
+  integer           :: nstep                    ! time step number
+  integer           :: nstep_fun                ! Number of
+  !  atmospheric timesteps between calls to FUN
+  character(len=32) :: subname = 'CNFUNInit'
+!--------------------------------------------------------------------
+  !---
+
+! Set local pointers
+  associate(ivt                 => veg_pp%itype                                    , & ! Input:  [integer  (:) ]  pft vegetation type
+!
+         leafcn                 => veg_vp%leafcn                                   , & ! Input:  [real(r8) (:)   ]  leaf C:N (gC/gN)
+!
+         leafcp                 => veg_vp%leafcp                                   , & ! Input:  [real(r8) (:)   ]  leaf C:P (gC/gP)
+!
+         leafcn_offset          => cnstate_vars%leafcn_offset_patch                 , & ! Output:
+         !  [real(r8) (:)   ]  Leaf C:N used by FUN 
+!
+         leafcp_offset          => cnstate_vars%leafcp_offset_patch                 , & ! Output:
+         !  [real(r8) (:)   ]  Leaf C:P used by FUN 
+!
+         leafc_storage_xfer_acc =>          veg_cs%leafc_storage_xfer_acc                    , & ! Output: [real(r8) (:)
+         !   ]  Accmulated leaf C transfer (gC/m2) 
+!
+         storage_cdemand =>  veg_cs%storage_cdemand    , & ! Output: [real(r8) (:)
+!
+         !   ]  C use from the C storage pool
+         leafn_storage_xfer_acc =>  veg_ns%leafn_storage_xfer_acc   , & ! Output: [real(r8) (:)
+!
+         !  ]  Accmulated leaf N transfer (gC/m2)                 
+         storage_ndemand  => veg_ns%storage_ndemand  , & ! Output: [real(r8) (:)
+!
+         !  ]  N demand during the offset period 
+         leafp_storage_xfer_acc => veg_ps%leafp_storage_xfer_acc , & ! Output: [real(r8) (:)
+!
+         !  ]  Accmulated leaf P transfer (gC/m2)                 
+         storage_pdemand =>  veg_ps%storage_pdemand     & ! Output: [real(r8) (:)
+         !  ]  P demand during the offset period 
+         )
+  !--------------------------------------------------------------------
+  !---
+  ! Calculate some timestep-related values.
+  !--------------------------------------------------------------------
+  !---
+
+  ! set time steps
+  dt           = real(get_step_size(), r8)
+  dayspyr      = get_days_per_year()
+  nstep        = get_nstep()
+  timestep_fun = real(secspday * fun_period)
+  nstep_fun    = int(secspday * dayspyr / dt) 
+
+  ndays_on     = params_inst%ndays_on
+  ndays_off    = params_inst%ndays_off
+
+  !--------------------------------------------------------------------
+  !---
+  ! Decide if FUN will be called on this timestep.
+  !--------------------------------------------------------------------
+  !---
+  numofyear = nstep/nstep_fun
+
+  if (mod(nstep,nstep_fun) == 0) then
+     leafcn_offset(bounds%begp:bounds%endp)          = leafcn(ivt(bounds%begp:bounds%endp))
+
+     storage_cdemand(bounds%begp:bounds%endp)        = 0._r8
+     storage_ndemand(bounds%begp:bounds%endp)        = 0._r8
+
+     leafn_storage_xfer_acc(bounds%begp:bounds%endp) = 0._r8
+     leafc_storage_xfer_acc(bounds%begp:bounds%endp) = 0._r8
+
+     if(use_funp)then
+     leafcp_offset(bounds%begp:bounds%endp)          = leafcp(ivt(bounds%begp:bounds%endp))
+     storage_pdemand(bounds%begp:bounds%endp)        = 0._r8
+     leafp_storage_xfer_acc(bounds%begp:bounds%endp) = 0._r8
+     end if
+  end if  
+!--------------------------------------------------------------------
+  !---
+  end associate
+  end subroutine CNFUNInit 
+!--------------------------------------------------------------------
+  !---
+
+  !--------------------------------------------------------------------
+  !---  
+  ! Start the CNFUN subroutine
+  !--------------------------------------------------------------------
+  !---
+  subroutine CNFUN(bounds                      , &
+                num_soilc, filter_soilc, num_soilp, filter_soilp    , &
+                canopystate_vars                                    , &
+                cnstate_vars, carbonstate_vars, carbonflux_vars     , &
+                c13_carbonflux_vars, c14_carbonflux_vars            , &
+                nitrogenstate_vars, nitrogenflux_vars               , &
+                phosphorusstate_vars, phosphorusflux_vars, crop_vars, &
+                soilhydrology_vars, temperature_vars, waterflux_vars, &
+                soilstate_vars)
+
+    ! !USES:
+    use shr_sys_mod      , only: shr_sys_flush
+    use clm_varctl       , only: iulog,cnallocate_carbon_only,cnallocate_carbonnitrogen_only,&
+                                 cnallocate_carbonphosphorus_only
+!    use pftvarcon        , only: npcropmin, declfact, bfact, aleaff, arootf, astemf
+!    use pftvarcon        , only: arooti, fleafi, allconsl, allconss, grperc, grpnow, nsoybean
+    use pftvarcon        , only: noveg
+    use pftvarcon        , only: npcropmin, grperc, grpnow
+    use clm_varpar       , only: nlevdecomp 
+    use clm_varcon       , only: nitrif_n2o_loss_frac, secspday
+!    use landunit_varcon  , only: istsoil, istcrop
+    use clm_time_manager , only: get_step_size
+    !
+    ! !ARGUMENTS:
+    type(bounds_type)        , intent(in)    :: bounds
+    integer                  , intent(in)    :: num_soilc        ! number of soil columns in filter
+    integer                  , intent(in)    :: filter_soilc(:)  ! filter for soil columns
+    integer                  , intent(in)    :: num_soilp        ! number of soil patches in filter
+    integer                  , intent(in)    :: filter_soilp(:)  ! filter for soil patches
+
+    type(canopystate_type)   , intent(in)    :: canopystate_vars
+    type(cnstate_type)       , intent(inout) :: cnstate_vars
+    type(carbonstate_type)   , intent(in)    :: carbonstate_vars
+    type(carbonflux_type)    , intent(inout) :: carbonflux_vars
+    type(carbonflux_type)    , intent(inout) :: c13_carbonflux_vars
+    type(carbonflux_type)    , intent(inout) :: c14_carbonflux_vars
+    type(nitrogenstate_type) , intent(inout) :: nitrogenstate_vars
+    type(nitrogenflux_type)  , intent(inout) :: nitrogenflux_vars
+!    !!  add phosphorus  -X.YANG
+    type(phosphorusstate_type) , intent(inout) :: phosphorusstate_vars
+    type(phosphorusflux_type)  , intent(inout) :: phosphorusflux_vars
+    type(crop_type)            , intent(inout) :: crop_vars
+
+     !! add varibles needed for FUN
+    type(soilhydrology_type)  , intent(in) :: soilhydrology_vars
+    type(temperature_type)    , intent(in) :: temperature_vars
+    type(waterflux_type)      , intent(in) :: waterflux_vars
+    type(soilstate_type)      , intent(in) :: soilstate_vars
+    !
+  ! !LOCAL VARIABLES:
+  ! local pointers to implicit in arrays
+  ! 
+  !--------------------------------------------------------------------
+  ! ------------
+  ! Integer parameters
+  !--------------------------------------------------------------------
+  !-----------
+  integer,  parameter :: icostFix        = 1             ! Process
+  !  number for fixing.
+  integer,  parameter :: icostRetrans    = 2             ! Process
+  !  number for retranslocation.
+  integer,  parameter :: icostActiveNO3  = 3             ! Process
+  !  number for mycorrhizal uptake of NO3.
+  integer,  parameter :: icostActiveNH4  = 4             ! Process
+  !  number for mycorrhizal uptake of NH4
+  integer,  parameter :: icostnonmyc_no3  = 5            ! Process
+  !  number for nonmyc uptake of NO3.
+  integer,  parameter :: icostnonmyc_nh4  = 6            ! Process
+  !  number for nonmyc uptake of NH4.
+  integer,  parameter :: icostRetransP   = 1             ! Process
+  !  number for retranslocation.
+  integer,  parameter :: icostActivePOX  = 2             ! Process
+  !  number for mycorrhizal uptake of POX.
+  integer,  parameter :: icostnonmyc_pox  = 3            ! Process
+  !  number for nonmyc uptake of POX.
+  real(r8), parameter :: big_cost        = 1000000000._r8! An arbitrarily large cost
+
+  !  array index when plant is fixing
+  integer, parameter :: plants_are_fixing = 1
+  integer, parameter :: plants_not_fixing = 2
+
+  !  array index for ECM step versus AM step
+  integer, parameter :: ecm_step          = 1
+  integer, parameter :: am_step           = 2
+  !  arbitrary large cost (gC/gN).
+  !--------------------------------------------------------------------
+  !-----------------------------------------------
+  ! Local Real variables.
+  !--------------------------------------------------------------------
+  !-----------------------------------------------
+  real(r8)  :: excess                                                ! excess N taken up by transpiration    (gN/m2) 
+  real(r8)  :: steppday                                              ! model time steps in each day          (-)
+  real(r8)  :: rootc_dens_step                                       ! root C for each PFT in each soil layer(gC/m2)
+  real(r8)  :: retrans_limit1                                        ! a temporary variable for leafn        (gN/m2)
+  real(r8)  :: retrans_limit2                                        ! a temporary variable for leafp        (gP/m2)
+  real(r8)  :: qflx_tran_veg_layer                                   ! transpiration in each soil layer      (mm H2O/S)
+  real(r8)  :: dn                                                    ! Increment of N                        (gN/m2)  
+  real(r8)  :: dn_retrans                                            ! Increment of N                        (gN/m2)
+  real(r8)  :: dp                                                    ! Increment of P                        (gP/m2)  
+  real(r8)  :: dp_retrans                                            ! Increment of P                        (gP/m2)
+  real(r8)  :: dnpp                                                  ! Increment of NPP                      (gC/m2)
+  real(r8)  :: dnpp_p                                                  ! Increment of NPP                      (gC/m2)
+  real(r8)  :: dnpp_retrans                                          ! Increment of NPP                      (gC/m2)
+  real(r8)  :: rootc_dens(bounds%begp:bounds%endp,1:nlevdecomp)      ! the root carbon density               (gC/m2)
+  real(r8)  :: rootC(bounds%begp:bounds%endp)                        ! root biomass                          (gC/m2)
+  real(r8)  :: permyc(bounds%begp:bounds%endp,1:nstp)                ! the arrary for the ECM and AM ratio   (-) 
+  real(r8)  :: kc_active(bounds%begp:bounds%endp,1:nstp)             ! the kc_active parameter               (gC/m2)
+  real(r8)  :: kn_active(bounds%begp:bounds%endp,1:nstp)             ! the kn_active parameter               (gC/m2)
+  real(r8)  :: kcp_active(bounds%begp:bounds%endp,1:nstp)            ! the kcp_active parameter   
+  real(r8)  :: kp_active(bounds%begp:bounds%endp,1:nstp)             ! the kp_active parameter               (gC/m2)
+  real(r8)  :: availc_pool(bounds%begp:bounds%endp)                  ! The avaible C pool for allocation     (gC/m2)
+  real(r8)  :: plantN(bounds%begp:bounds%endp)                       ! Plant N                               (gN/m2)
+ real(r8)  :: availc_pool_p(bounds%begp:bounds%endp)                  ! The avaible C pool for allocation     (gC/m2)
+  real(r8)  :: plantP(bounds%begp:bounds%endp)                       ! Plant P                               (gP/m2)
+  real(r8)  :: plant_ndemand_pool(bounds%begp:bounds%endp)           ! The N demand pool                     (gN/m2)
+  real(r8)  :: plant_pdemand_pool(bounds%begp:bounds%endp)           ! The P demand pool                     (gP/m2)
+  real(r8)  :: plant_ndemand_pool_step(bounds%begp:bounds%endp,1:nstp)   ! the N demand pool                     (gN/m2)
+  real(r8)  :: plant_pdemand_pool_step(bounds%begp:bounds%endp,1:nstp)   ! the P demand pool                     (gP/m2)
+  real(r8)  :: leafn_step(bounds%begp:bounds%endp,1:nstp)            ! N loss based for deciduous trees      (gN/m2)
+  real(r8)  :: leafp_step(bounds%begp:bounds%endp,1:nstp)            ! P loss based for deciduous trees      (gP/m2)
+  real(r8)  :: leafn_retrans_step(bounds%begp:bounds%endp,1:nstp)    ! N loss based for deciduous trees      (gN/m2) 
+  real(r8)  :: leafp_retrans_step(bounds%begp:bounds%endp,1:nstp)    ! P loss based for deciduous trees      (gP/m2) 
+  real(r8)  :: litterfall_n(bounds%begp:bounds%endp)                 ! N loss based on the leafc to litter   (gN/m2) 
+  real(r8)  :: litterfall_p(bounds%begp:bounds%endp)                 ! P loss based on the leafc to litter   (gP/m2) 
+  real(r8)  :: litterfall_n_step(bounds%begp:bounds%endp,1:nstp)       ! N loss based on the leafc to litter   (gN/m2)
+  real(r8)  :: litterfall_p_step(bounds%begp:bounds%endp,1:nstp)       ! P loss based on the leafc to litter   (gP/m2)
+  real(r8)  :: litterfall_c_step(bounds%begp:bounds%endp,1:nstp)       ! N loss based on the leafc to litter   (gN/m2)
+  real(r8)  :: litterfall_c_step_p(bounds%begp:bounds%endp,1:nstp)     ! N loss based on the leafc to litter   (gN/m2)
+  real(r8)  :: tc_soisno(bounds%begc:bounds%endc,1:nlevdecomp)       ! Soil temperature            (degrees Celsius)
+  real(r8)  :: npp_remaining(bounds%begp:bounds%endp,1:nstp)         ! A temporary variable for npp_remaining(gC/m2) 
+  real(r8)  :: npp_remaining_p(bounds%begp:bounds%endp,1:nstp)       ! A temporary variable for npp_remaining(gC/m2) for P
+  real(r8)  :: n_passive_step(bounds%begp:bounds%endp,1:nstp)        ! N taken up by transpiration at substep(gN/m2)
+  real(r8)  :: p_passive_step(bounds%begp:bounds%endp,1:nstp)        ! P taken up by transpiration at substep(gP/m2)
+  real(r8)  :: n_passive_acc(bounds%begp:bounds%endp)                ! N acquired by passive uptake          (gN/m2)
+  real(r8)  :: p_passive_acc(bounds%begp:bounds%endp)                ! P acquired by passive uptake          (gP/m2)
+  real(r8)  :: cost_retran(bounds%begp:bounds%endp,1:nlevdecomp)     ! cost of retran                        (gC/gN)
+  real(r8)  :: cost_retran_p(bounds%begp:bounds%endp,1:nlevdecomp)     ! cost of retran  P                      (gC/gP)
+  real(r8)  :: cost_fix(bounds%begp:bounds%endp,1:nlevdecomp)        ! cost of fixation                      (gC/gN)
+  real(r8)  :: cost_resis(bounds%begp:bounds%endp,1:nlevdecomp)      ! cost of resis                         (gC/gN)
+  real(r8)  :: cost_resis_p(bounds%begp:bounds%endp,1:nlevdecomp)      ! cost of resis  P                       (gC/gP)
+  real(r8)  :: cost_res_resis(bounds%begp:bounds%endp,1:nlevdecomp)  ! The cost of resis                     (gN/gC)
+  real(r8)  :: cost_res_resis_p(bounds%begp:bounds%endp,1:nlevdecomp)  ! The cost of resis P                    (gP/gC)
+  real(r8)  :: n_fix_acc(bounds%begp:bounds%endp,1:nstp)             ! N acquired by fixation                (gN/m2)
+  real(r8)  :: n_fix_acc_total(bounds%begp:bounds%endp)              ! N acquired by fixation                (gN/m2)
+  real(r8)  :: npp_fix_acc(bounds%begp:bounds%endp,1:nstp)           ! Amount of NPP used by fixation        (gC/m2)
+  real(r8)  :: npp_fix_acc_total(bounds%begp:bounds%endp)            ! Amount of NPP used by fixation        (gC/m2)
+  real(r8)  :: n_retrans_acc(bounds%begp:bounds%endp,1:nstp)         ! N acquired by retranslocation         (gN/m2)
+  real(r8)  :: p_retrans_acc(bounds%begp:bounds%endp,1:nstp)         ! P acquired by retranslocation         (gP/m2)
+  real(r8)  :: n_retrans_acc_total(bounds%begp:bounds%endp)          ! N acquired by retranslocation         (gN/m2)
+  real(r8)  :: p_retrans_acc_total(bounds%begp:bounds%endp)          ! P acquired by retranslocation         (gP/m2)
+  real(r8)  :: free_nretrans_acc(bounds%begp:bounds%endp,1:nstp)     ! N acquired by retranslocation         (gN/m2)
+  real(r8)  :: free_pretrans_acc(bounds%begp:bounds%endp,1:nstp)     ! P acquired by retranslocation         (gP/m2)
+  real(r8)  :: npp_retrans_acc(bounds%begp:bounds%endp,1:nstp)       ! NPP used for the extraction           (gC/m2)
+  real(r8)  :: npp_retrans_p_acc(bounds%begp:bounds%endp,1:nstp)     ! NPP used for the extraction of P        (gC/m2)
+  real(r8)  :: npp_retrans_acc_total(bounds%begp:bounds%endp)        ! NPP used for the extraction           (gC/m2)
+  real(r8)  :: npp_retrans_p_acc_total(bounds%begp:bounds%endp)      ! NPP used for the extraction   of P        (gC/m2)
+  real(r8)  :: nt_uptake(bounds%begp:bounds%endp,1:nstp)             ! N uptake from retrans, active, and fix(gN/m2)
+  real(r8)  :: pt_uptake(bounds%begp:bounds%endp,1:nstp)             ! P uptake from retrans and active (gP/m2)
+  real(r8)  :: npp_uptake(bounds%begp:bounds%endp,1:nstp)            ! NPP used by the uptakes               (gC/m2)
+  real(r8)  :: npp_uptake_p(bounds%begp:bounds%endp,1:nstp)          ! NPP used by the uptakes of P              (gC/m2)
+
+  !----------NITRIF_DENITRIF-------------!
+
+  real(r8)  :: sminn_no3_diff                                        ! A temporary limit for N uptake                  (gN/m2)
+  real(r8)  :: sminn_nh4_diff                                        ! A temporary limit for N uptake                  (gN/m2)
+  real(r8)  :: sminp_pox_diff                                        ! A temporary limit for P uptake                  (gP/m2)
+  real(r8)  :: active_no3_limit1                                     ! A temporary limit for N uptake                  (gN/m2)
+  real(r8)  :: active_nh4_limit1                                     ! A temporary limit for N uptake                  (gN/m2)
+  real(r8)  :: active_pox_limit2                                     ! A temporary limit for P uptake                  (gP/m2)
+  real(r8)  :: cost_active_no3(bounds%begp:bounds%endp,1:nlevdecomp) ! cost of mycorrhizal                             (gC/gN)
+  real(r8)  :: cost_active_nh4(bounds%begp:bounds%endp,1:nlevdecomp) ! cost of mycorrhizal                             (gC/gN)
+  real(r8)  :: cost_active_pox(bounds%begp:bounds%endp,1:nlevdecomp) ! cost of mycorrhizal                             (gP/gP)
+  real(r8)  :: cost_nonmyc_no3(bounds%begp:bounds%endp,1:nlevdecomp) ! cost of nonmyc                                  (gC/gN)
+  real(r8)  :: cost_nonmyc_nh4(bounds%begp:bounds%endp,1:nlevdecomp) ! cost of nonmyc                                  (gC/gN)
+  real(r8)  :: cost_nonmyc_pox(bounds%begp:bounds%endp,1:nlevdecomp) ! cost of nonmyc                                  (gC/gP)
+
+  real(r8)  :: sminn_no3_conc(bounds%begc:bounds%endc,1:nlevdecomp)             ! Concentration of no3 in soil water (gN/gH2O)
+  real(r8)  :: sminn_no3_conc_step(bounds%begp:bounds%endp,1:nlevdecomp,1:nstp) ! A temporary variable for soil mineral N (gN/gH2O)
+  real(r8)  :: sminn_no3_layer(bounds%begc:bounds%endc,1:nlevdecomp)            ! Available no3 in each soil layer (gN/m2)
+  real(r8)  :: sminn_no3_layer_step(bounds%begp:bounds%endp,1:nlevdecomp,1:nstp)! A temporary variable for soil no3 (gN/m2) 
+  real(r8)  :: sminn_no3_uptake(bounds%begp:bounds%endp,1:nlevdecomp,1:nstp)    ! A temporary variable for soil mineral N (gN/m2/s)
+  real(r8)  :: sminn_nh4_conc(bounds%begc:bounds%endc,1:nlevdecomp)             ! Concentration of nh4 in soil water (gN/gH2O)
+  real(r8)  :: sminn_nh4_conc_step(bounds%begp:bounds%endp,1:nlevdecomp,1:nstp) ! A temporary variable for soil mineral N (gN/gH2O)
+  real(r8)  :: sminn_nh4_layer(bounds%begc:bounds%endc,1:nlevdecomp)            ! Available nh4 in each soil layer (gN/m2)
+  real(r8)  :: sminn_nh4_layer_step(bounds%begp:bounds%endp,1:nlevdecomp,1:nstp)! A temporary variable for soil mineral N (gN/m2)
+  real(r8)  :: sminn_nh4_uptake(bounds%begp:bounds%endp,1:nlevdecomp,1:nstp)    ! A temporary variable for soil mineral N (gN/m2/s)
+
+  real(r8)  :: sminp_pox_conc(bounds%begc:bounds%endc,1:nlevdecomp)             ! Concentration of pox in soil water (gP/gH2O)
+  real(r8)  :: sminp_pox_conc_step(bounds%begp:bounds%endp,1:nlevdecomp,1:nstp) ! A temporary variable for soil mineral P (gP/gH2O)
+  real(r8)  :: sminp_pox_layer(bounds%begc:bounds%endc,1:nlevdecomp)            ! Available pox in each soil layer (gP/m2)
+  real(r8)  :: sminp_pox_layer_step(bounds%begp:bounds%endp,1:nlevdecomp,1:nstp)! A temporary variable for soil mineral P (gP/m2)
+  real(r8)  :: sminp_pox_uptake(bounds%begp:bounds%endp,1:nlevdecomp,1:nstp)    ! A temporary variable for soil mineral P (gP/m2/s)
+
+  real(r8)  :: active_no3_uptake1(bounds%begp:bounds%endp,1:nlevdecomp)         ! no3 mycorrhizal uptake (gN/m2)
+  real(r8)  :: active_nh4_uptake1(bounds%begp:bounds%endp,1:nlevdecomp)         ! nh4 mycorrhizal uptake (gN/m2)
+  real(r8)  :: active_pox_uptake1(bounds%begp:bounds%endp,1:nlevdecomp)         ! pox mycorrhizal uptake (gP/m2)
+  real(r8)  :: nonmyc_no3_uptake1(bounds%begp:bounds%endp,1:nlevdecomp)         ! no3 non-mycorrhizal uptake (gN/m2) 
+  real(r8)  :: nonmyc_nh4_uptake1(bounds%begp:bounds%endp,1:nlevdecomp)         ! nh4 non-mycorrhizal uptake (gN/m2) 
+  real(r8)  :: nonmyc_pox_uptake1(bounds%begp:bounds%endp,1:nlevdecomp)         ! pox non-mycorrhizal uptake (gP/m2)
+  real(r8)  :: active_no3_uptake2(bounds%begp:bounds%endp,1:nlevdecomp)         ! no3 mycorrhizal uptake (gN/m2) 
+  real(r8)  :: active_nh4_uptake2(bounds%begp:bounds%endp,1:nlevdecomp)         ! nh4 mycorrhizal uptake (gN/m2) 
+  real(r8)  :: active_pox_uptake2(bounds%begp:bounds%endp,1:nlevdecomp)         ! pox mycorrhizal uptake (gP/m2)
+  real(r8)  :: nonmyc_no3_uptake2(bounds%begp:bounds%endp,1:nlevdecomp)         ! no3 non-mycorrhizal uptake (gN/m2) 
+  real(r8)  :: nonmyc_nh4_uptake2(bounds%begp:bounds%endp,1:nlevdecomp)         ! nh4 non-mycorrhizal uptake (gN/m2) 
+  real(r8)  :: nonmyc_pox_uptake2(bounds%begp:bounds%endp,1:nlevdecomp)         ! pox non-mycorrhizal uptake (gP/m2)
+  real(r8)  :: n_am_no3_acc(bounds%begp:bounds%endp)                            ! AM no3 uptake (gN/m2)
+  real(r8)  :: n_am_nh4_acc(bounds%begp:bounds%endp)                            ! AM nh4 uptake (gN/m2)
+  real(r8)  :: p_am_pox_acc(bounds%begp:bounds%endp)                            ! AM pox uptake (gP/m2)
+  real(r8)  :: n_ecm_no3_acc(bounds%begp:bounds%endp)                           ! ECM no3 uptake (gN/m2)
+  real(r8)  :: n_ecm_nh4_acc(bounds%begp:bounds%endp)                           ! ECM nh4 uptake (gN/m2)
+  real(r8)  :: p_ecm_pox_acc(bounds%begp:bounds%endp)                           ! ECM pox uptake (gN/m2)
+  real(r8)  :: n_active_no3_acc(bounds%begp:bounds%endp,1:nstp)                 ! Mycorrhizal no3 uptake (gN/m2)
+  real(r8)  :: n_active_nh4_acc(bounds%begp:bounds%endp,1:nstp)                 ! Mycorrhizal nh4 uptake (gN/m2)
+  real(r8)  :: p_active_pox_acc(bounds%begp:bounds%endp,1:nstp)                 ! Mycorrhizal pox uptake (gP/m2)
+  real(r8)  :: n_nonmyc_no3_acc(bounds%begp:bounds%endp,1:nstp)                 ! Non-myc     no3 uptake (gN/m2)
+  real(r8)  :: n_nonmyc_nh4_acc(bounds%begp:bounds%endp,1:nstp)                 ! Non-myc     nh4 uptake (gN/m2)
+  real(r8)  :: p_nonmyc_pox_acc(bounds%begp:bounds%endp,1:nstp)                 ! Non-myc     pox uptake (gP/m2)
+  real(r8)  :: n_active_no3_acc_total(bounds%begp:bounds%endp)                  ! Mycorrhizal no3 uptake (gN/m2)
+  real(r8)  :: n_active_nh4_acc_total(bounds%begp:bounds%endp)                  ! Mycorrhizal no3 uptake (gN/m2)
+  real(r8)  :: p_active_pox_acc_total(bounds%begp:bounds%endp)                  ! Mycorrhizal pox uptake (gP/m2)
+     
+  real(r8)  :: n_nonmyc_no3_acc_total(bounds%begp:bounds%endp)                  ! Non-myc     no3 uptake (gN/m2)
+  real(r8)  :: n_nonmyc_nh4_acc_total(bounds%begp:bounds%endp)                  ! Non-myc     nh4 uptake (gN/m2)
+  real(r8)  :: p_nonmyc_pox_acc_total(bounds%begp:bounds%endp)                  ! Non-myc     pox uptake (gP/m2)
+  real(r8)  :: npp_active_no3_acc(bounds%begp:bounds%endp,1:nstp)               ! Mycorrhizal no3 uptake used C (gC/m2)
+  real(r8)  :: npp_active_nh4_acc(bounds%begp:bounds%endp,1:nstp)               ! Mycorrhizal nh4 uptake used C (gC/m2)
+  real(r8)  :: npp_active_pox_acc(bounds%begp:bounds%endp,1:nstp)               ! Mycorrhizal pox uptake used C (gC/m2)
+  real(r8)  :: npp_nonmyc_no3_acc(bounds%begp:bounds%endp,1:nstp)               ! Non-myc     no3 uptake used C (gC/m2)
+  real(r8)  :: npp_nonmyc_nh4_acc(bounds%begp:bounds%endp,1:nstp)               ! Non-myc     nh4 uptake used C (gC/m2)
+  real(r8)  :: npp_nonmyc_pox_acc(bounds%begp:bounds%endp,1:nstp)               ! Non-myc     pox uptake used C (gC/m2)
+  real(r8)  :: npp_active_no3_acc_total(bounds%begp:bounds%endp)                ! Mycorrhizal no3 uptake used C (gC/m2)
+  real(r8)  :: npp_active_nh4_acc_total(bounds%begp:bounds%endp)                ! Mycorrhizal nh4 uptake used C (gC/m2)
+  real(r8)  :: npp_active_pox_acc_total(bounds%begp:bounds%endp)                ! Mycorrhizal pox uptake used C (gC/m2)
+  real(r8)  :: npp_nonmyc_no3_acc_total(bounds%begp:bounds%endp)                ! Non-myc     no3 uptake used C (gC/m2)
+  real(r8)  :: npp_nonmyc_nh4_acc_total(bounds%begp:bounds%endp)                ! Non-myc     nh4 uptake used C (gC/m2)
+  real(r8)  :: npp_nonmyc_pox_acc_total(bounds%begp:bounds%endp)                ! Non-myc     pox uptake used C (gC/m2)
+  real(r8)  :: n_am_no3_retrans(bounds%begp:bounds%endp)                        ! AM no3 uptake for offset (gN/m2)
+  real(r8)  :: n_am_nh4_retrans(bounds%begp:bounds%endp)                        ! AM nh4 uptake for offset (gN/m2)
+  real(r8)  :: p_am_pox_retrans(bounds%begp:bounds%endp)                        ! AM pox uptake for offset (gP/m2)
+  real(r8)  :: n_ecm_no3_retrans(bounds%begp:bounds%endp)                       ! ECM no3 uptake for offset (gN/m2)
+  real(r8)  :: n_ecm_nh4_retrans(bounds%begp:bounds%endp)                       ! ECM nh4 uptake for offset (gN/m2)
+  real(r8)  :: p_ecm_pox_retrans(bounds%begp:bounds%endp)                       ! ECM pox uptake for offset (gP/m2)
+  real(r8)  :: n_active_no3_retrans(bounds%begp:bounds%endp,1:nstp)             ! Mycorrhizal no3 for offset (gN/m2)
+  real(r8)  :: n_active_nh4_retrans(bounds%begp:bounds%endp,1:nstp)             ! Mycorrhizal nh4 for offset (gN/m2)
+  real(r8)  :: p_active_pox_retrans(bounds%begp:bounds%endp,1:nstp)             ! Mycorrhizal pox for offset (gP/m2)
+  real(r8)  :: n_nonmyc_no3_retrans(bounds%begp:bounds%endp,1:nstp)             ! Non-myc     no3 for offset (gN/m2)
+  real(r8)  :: n_nonmyc_nh4_retrans(bounds%begp:bounds%endp,1:nstp)             ! Non-myc     nh4 for offset (gN/m2)
+  real(r8)  :: p_nonmyc_pox_retrans(bounds%begp:bounds%endp,1:nstp)             ! Non-myc     pox for offset (gP/m2)
+  real(r8)  :: n_active_no3_retrans_total(bounds%begp:bounds%endp)              ! Mycorrhizal no3 for offset (gN/m2)
+  real(r8)  :: n_active_nh4_retrans_total(bounds%begp:bounds%endp)              ! Mycorrhizal nh4 for offset (gN/m2)
+  real(r8)  :: p_active_pox_retrans_total(bounds%begp:bounds%endp)              ! Mycorrhizal pox for offset (gP/m2)
+  real(r8)  :: n_nonmyc_no3_retrans_total(bounds%begp:bounds%endp)              ! Non-myc     no3 for offset (gN/m2)
+  real(r8)  :: n_nonmyc_nh4_retrans_total(bounds%begp:bounds%endp)              ! Non-myc     nh4 for offset (gN/m2)
+  real(r8)  :: p_nonmyc_pox_retrans_total(bounds%begp:bounds%endp)              ! Non-myc     nh4 for offset (gP/m2)
+  real(r8)  :: n_passive_no3_vr(bounds%begp:bounds%endp,1:nlevdecomp)           ! Layer passive no3 uptake (gN/m2)
+  real(r8)  :: n_passive_nh4_vr(bounds%begp:bounds%endp,1:nlevdecomp)           ! Layer passive nh4 uptake (gN/m2)
+  real(r8)  :: p_passive_pox_vr(bounds%begp:bounds%endp,1:nlevdecomp)           ! Layer passive pox uptake (gP/m2)
+  real(r8)  :: n_fix_no3_vr(bounds%begp:bounds%endp,1:nlevdecomp)               ! Layer fixation no3 uptake (gN/m2)
+  real(r8)  :: n_fix_nh4_vr(bounds%begp:bounds%endp,1:nlevdecomp)               ! Layer fixation nh4 uptake (gN/m2)
+  real(r8)  :: n_active_no3_vr(bounds%begp:bounds%endp,1:nlevdecomp)            ! Layer mycorrhizal no3 uptake (gN/m2)
+  real(r8)  :: n_nonmyc_no3_vr(bounds%begp:bounds%endp,1:nlevdecomp)            ! Layer non-myc     no3 uptake (gN/m2)
+  real(r8)  :: n_active_nh4_vr(bounds%begp:bounds%endp,1:nlevdecomp)            ! Layer mycorrhizal nh4 uptake (gN/m2)
+  real(r8)  :: n_nonmyc_nh4_vr(bounds%begp:bounds%endp,1:nlevdecomp)            ! Layer non-myc     nh4 uptake (gN/m2)
+  real(r8)  :: p_active_pox_vr(bounds%begp:bounds%endp,1:nlevdecomp)            ! Layer mycorrhizal pox uptake (gP/m2)
+  real(r8)  :: p_nonmyc_pox_vr(bounds%begp:bounds%endp,1:nlevdecomp)            ! Layer non-myc     pox uptake (gP/m2)
+  real(r8)  :: npp_active_no3_retrans(bounds%begp:bounds%endp,1:nstp)           ! Mycorrhizal no3 uptake used C for offset (gN/m2)
+  real(r8)  :: npp_active_nh4_retrans(bounds%begp:bounds%endp,1:nstp)           ! Mycorrhizal nh4 uptake used C for offset (gN/m2)
+  real(r8)  :: npp_active_pox_retrans(bounds%begp:bounds%endp,1:nstp)           ! Mycorrhizal pox uptake used C for offset (gP/m2)
+  real(r8)  :: npp_nonmyc_no3_retrans(bounds%begp:bounds%endp,1:nstp)           ! Non-myc no3 uptake used C for offset (gN/m2)
+  real(r8)  :: npp_nonmyc_nh4_retrans(bounds%begp:bounds%endp,1:nstp)           ! Non-myc nh4 uptake used C for offset (gN/m2)
+  real(r8)  :: npp_nonmyc_pox_retrans(bounds%begp:bounds%endp,1:nstp)           ! Non-myc pox uptake used C for offset (gP/m2)
+  real(r8)  :: npp_active_no3_retrans_total(bounds%begp:bounds%endp)            ! Mycorrhizal no3 uptake used C for offset (gN/m2)
+  real(r8)  :: npp_active_nh4_retrans_total(bounds%begp:bounds%endp)            ! Mycorrhizal nh4 uptake used C for offset (gN/m2)
+  real(r8)  :: npp_active_pox_retrans_total(bounds%begp:bounds%endp)            ! Mycorrhizal pox uptake used C for offset (gP/m2)
+  real(r8)  :: npp_nonmyc_no3_retrans_total(bounds%begp:bounds%endp)             ! Non-myc no3 uptake used C for offset (gN/m2)
+  real(r8)  :: npp_nonmyc_nh4_retrans_total(bounds%begp:bounds%endp)            ! Non-myc nh4 uptake used C for offset (gN/m2)
+  real(r8)  :: npp_nonmyc_pox_retrans_total(bounds%begp:bounds%endp)            ! Non-myc pox uptake used C for offset (gP/m2)
+  
+
+  real(r8)  :: costNit(1:nlevdecomp,ncost6)                          ! Cost of N via each process                      (gC/gN)
+  real(r8)  :: costPho(1:nlevdecomp,pcost3)                          ! Cost of P via each process                      (gC/gP)
+
+
+  ! Uptake fluxes for COST_METHOD=2
+  ! actual npp to each layer for each N uptake process
+  real(r8)  ::                   npp_to_fixation(1:nlevdecomp) 
+  real(r8)  ::                   npp_to_retrans(1:nlevdecomp)
+  real(r8)  ::                   npp_to_active_nh4(1:nlevdecomp)
+  real(r8)  ::                   npp_to_nonmyc_nh4(1:nlevdecomp)
+  real(r8)  ::                   npp_to_active_no3(1:nlevdecomp)
+  real(r8)  ::                   npp_to_nonmyc_no3 (1:nlevdecomp)
+
+  ! actual npp to each layer for each P uptake process
+  real(r8)  ::                   npp_to_retrans_p(1:nlevdecomp)
+  real(r8)  ::                   npp_to_active_pox(1:nlevdecomp)
+  real(r8)  ::                   npp_to_nonmyc_pox(1:nlevdecomp)
+  
+
+  ! fraction of carbon to each N uptake process 
+  real(r8)  ::                   npp_frac_to_fixation(1:nlevdecomp) 
+  real(r8)  ::                   npp_frac_to_retrans(1:nlevdecomp)
+  real(r8)  ::                   npp_frac_to_active_nh4(1:nlevdecomp)
+  real(r8)  ::                   npp_frac_to_nonmyc_nh4(1:nlevdecomp)
+  real(r8)  ::                   npp_frac_to_active_no3(1:nlevdecomp)
+  real(r8)  ::                   npp_frac_to_nonmyc_no3 (1:nlevdecomp)  
+
+  ! fraction of carbon to each P uptake process 
+  real(r8)  ::                   npp_frac_to_retrans_p(1:nlevdecomp)
+  real(r8)  ::                   npp_frac_to_active_pox(1:nlevdecomp)
+  real(r8)  ::                   npp_frac_to_nonmyc_pox(1:nlevdecomp)
+   
+  ! hypothetical fluxes on N in each layer 
+  real(r8)  ::                  n_exch_fixation(1:nlevdecomp)        ! N aquired from one unit of C for fixation (unitless)
+  real(r8)  ::                  n_exch_retrans(1:nlevdecomp)         ! N aquired from one unit of C for retrans (unitless)
+  real(r8)  ::                  n_exch_active_nh4(1:nlevdecomp)      ! N aquired from one unit of C for act nh4(unitless)
+  real(r8)  ::                  n_exch_nonmyc_nh4(1:nlevdecomp)      ! N aquired from one unit of C for nonmy nh4 (unitless) 
+  real(r8)  ::                  n_exch_active_no3(1:nlevdecomp)      ! N aquired from one unit of C for act no3 (unitless)
+  real(r8)  ::                  n_exch_nonmyc_no3(1:nlevdecomp)      ! N aquired from one unit of C for nonmyc no3 (unitless) 
+
+  ! hypothetical fluxes on P in each layer 
+  real(r8)  ::                  p_exch_retrans(1:nlevdecomp)         ! P aquired from one unit of C for retrans (unitless)
+  real(r8)  ::                  p_exch_active_pox(1:nlevdecomp)      ! P aquired from one unit of C for act pox(unitless)
+  real(r8)  ::                  p_exch_nonmyc_pox(1:nlevdecomp)      ! P aquired from one unit of C for nonmy pox (unitless) 
+  
+   !actual fluxes of N in each layer
+  real(r8)  ::                  n_from_fixation(1:nlevdecomp)        ! N aquired in each layer for fixation       (gN m-2 s-1)
+  real(r8)  ::                  n_from_retrans(1:nlevdecomp)         ! N aquired in each layer of C for retrans (gN m-2 s-1)
+  real(r8)  ::                  n_from_active_nh4(1:nlevdecomp)      ! N aquired in each layer of C for act nh4 (gN m-2 s-1)
+  real(r8)  ::                  n_from_nonmyc_nh4(1:nlevdecomp)      ! N aquired in each layer of C for nonmy nh4 (gN m-2 s-1)
+  real(r8)  ::                  n_from_active_no3(1:nlevdecomp)      ! N aquired in each layer of C for act no3 (gN m-2 s-1)
+  real(r8)  ::                  n_from_nonmyc_no3(1:nlevdecomp)      ! N aquired in each layer of C for nonmyc no3 (gN m-2 s-1) 
+
+   !actual fluxes of P in each layer
+  real(r8)  ::                  p_from_retrans(1:nlevdecomp)         ! P aquired in each layer of C for retrans (gP m-2 s-1)
+  real(r8)  ::                  p_from_active_pox(1:nlevdecomp)      ! P aquired in each layer of C for act pox (gP m-2 s-1)
+  real(r8)  ::                  p_from_nonmyc_pox(1:nlevdecomp)      ! P aquired in each layer of C for nonmy pox (gP m-2 s-1)
+ 
+
+  real(r8)  :: free_Nretrans(bounds%begp:bounds%endp)                     ! the total amount of NO3 and NH4                 (gN/m3/s)
+  real(r8)  :: free_Pretrans(bounds%begp:bounds%endp)                     ! the total amount of POX                         (gP/m3/s)
+
+
+  ! Uptake fluxes for COST_METHOD=2
+  !actual fluxes of N in each layer
+  real(r8)  ::                  frac_ideal_C_use                     ! How much less C do we use for 'buying' N than that
+  !  needed to get to the ideal ratio?  fraction. 
+
+  real(r8)  ::                  N_acquired
+  real(r8)  ::                  P_acquired
+  real(r8)  ::                  C_spent
+  real(r8)  ::                  C_spentP
+  real(r8)  ::                  leaf_narea ! leaf n per unit leaf
+  !  area in gN/m2 (averaged across canopy, which is OK for the cost
+  !   calculation)
+  real(r8)  ::                  leaf_parea ! leaf p per unit leaf
+  !  area in gP/m2 (averaged across canopy, which is OK for the cost
+  !   calculation)
+
+                       
+  real(r8)  ::                  sum_n_acquired                          ! Sum N aquired from one unit of C (unitless)  
+  real(r8)  ::                  sum_p_acquired                          ! Sum P aquired from one unit of C (unitless) 
+  real(r8)  ::                  burned_off_carbon                       ! carbon wasted by poor allocation algorithm. If
+  !  this is too big, we need a better iteration. 
+  real(r8)  ::                  burned_off_carbon_p                     ! carbon wasted by poor allocation algorithm. If
+  !  this is too big, we need a better iteration. 
+  real(r8)   ::                 temp_n_flux  
+  real(r8)   ::                 temp_p_flux  
+  real(r8)  ::                  delta_cn                                ! difference between 'ideal' leaf CN ratio and
+  !  actual leaf C:N ratio. C/N
+  real(r8)  ::                  delta_cp                                ! difference between 'ideal' leaf CP ratio and
+  !  actual leaf C:P ratio. C/P
+  real(r8) :: excess_carbon        ! how much carbon goes into the leaf C
+  !  pool on account of the flexibleCN modifications.   
+  real(r8) :: excess_carbon_p      ! how much carbon goes into the leaf C
+  !  pool on account of the flexibleCP modifications.
+  real(r8) :: excess_carbon_acc    ! excess accumulated over layers.
+  !  WITHOUT GROWTH RESP
+  real(r8) :: excess_carbon_acc_p    ! excess accumulated over layers.
+  !  WITHOUT GROWTH RESP
+  real(r8) :: fixerfrac            ! what fraction of plants can fix?
+  real(r8) :: fixerfrac_p          ! what fraction of plants can fix Phosphorus? 0%! But this is just a test variable!
+  real(r8) :: npp_to_spend         ! how much carbon do we need to get
+  !  rid of? 
+  real(r8) :: npp_to_spend_p       ! how much carbon do we need to get
+  !  rid of?
+  real(r8) :: soil_n_extraction    ! calculates total N pullled from
+  !  soil
+  real(r8) :: soil_p_extraction    ! calculates total N pullled from
+  !  soil
+  real(r8) :: total_N_conductance  !inverse of C to of N for whole soil
+  ! -leaf pathway
+  real(r8) :: total_P_conductance  !inverse of C to of P for whole soil
+  ! -leaf pathway
+  real(r8) :: total_N_resistance   ! C to of N for whole soil -leaf
+  !  pathway
+  real(r8) :: total_P_resistance   ! C to of P for whole soil -leaf
+  !  pathway
+  real(r8) :: free_RT_frac=0.0_r8  !fraction of N retranslocation which is automatic/free.
+  real(r8) :: free_RTP_frac=0.0_r8 !fraction of P retranslocation which is automatic/free.
+  !  SHould be made into a PFT parameter. 
+
+  real(r8) :: paid_for_n_retrans
+  real(r8) :: free_n_retrans
+  real(r8) :: paid_for_p_retrans
+  real(r8) :: free_p_retrans
+  real(r8) :: total_c_spent_retrans
+  real(r8) :: total_c_accounted_retrans
+  real(r8) :: total_c_spent_retrans_p
+  real(r8) :: total_c_accounted_retrans_p
+
+  real(r8) :: diff_free_paid
+
+  real(r8) :: grperc_n(bounds%begp:bounds%endp)
+  real(r8) :: grperc_p(bounds%begp:bounds%endp)
+
+  !Value to scale the phosphorus K parameters 
+  real(r8) :: scalex = 100._r8
+   
+  !Value to scale up the availc C for phosphorus 
+  real(r8) :: scale_availc = 1.0_r8
+
+  !Local FUN-P variables
+
+  !real(r8), dimension(25) :: perecm
+  !real(r8), dimension(25) :: FUN_fracfixers
+  !real(r8), dimension(25) :: akc_active
+  !real(r8), dimension(25) :: akn_active
+  !real(r8), dimension(25) :: ekc_active
+  !real(r8), dimension(25) :: ekn_active
+  !real(r8), dimension(25) :: kc_nonmyc
+  !real(r8), dimension(25) :: kn_nonmyc
+  !real(r8), dimension(25) :: kcp_nonmyc
+  !real(r8), dimension(25) :: kp_nonmyc
+
+
+  
+  !------end of not_use_nitrif_denitrif------!
+  !--------------------------------------------------------------------
+  !------------
+  ! Local Integer variables
+  !--------------------------------------------------------------------
+  !------------
+  integer   :: fn                                ! number of values
+  !  in pft filter
+  integer   :: fp                                ! lake filter pft
+  !  index
+  integer   :: fc                                ! lake filter column
+  !  index
+  integer   :: p, c                              ! pft index
+  integer   :: g, l                              ! indices
+  integer   :: j, i, k                           ! soil/snow level
+  !  index
+  integer   :: istp                              ! Loop counters/work
+  integer   :: icost                             ! a local index
+  integer   :: fixer                             ! 0 = non-fixer, 1
+  ! =fixer 
+  logical   :: unmetDemand                       ! True while there
+  !  is still demand for N
+  logical   :: unmetDemandP                      ! True while there
+  !  is still demand for P
+  logical   :: local_use_flexibleCN              ! local version of use_flexCN
+  integer   :: FIX                               ! for loop. 1 for
+  !  fixers, 2 for non fixers. This will become redundant with the
+  !   'fixer' parameter if it works. 
+  
+  !--------------------------------------------------------------------
+  !---------------------------------
+        
+associate(                                                                                 &
+         ivt                          => veg_pp%itype                                           , & ! Input:  [integer  (:) ]  pft vegetation type
+!
+         leafcn                       => veg_vp%leafcn                                  ,  & ! Input:  [real(r8) (:)   ]  leaf C:N (gC/gN)
+         leafcp                 => veg_vp%leafcp                                   , & ! Input:  [real(r8) (:)   ]  leaf C:P (gC/gP)
+        lflitcn                      =>  veg_vp%lflitcn                               , & ! Input:  [real(r8) (:)   ]  leaf litter C:N (gC/gN) 
+        season_decid                 => veg_vp%season_decid                          ,& ! Input:   binary flag for seasonal 
+         ! -deciduous leaf habit (0 or 1)
+         stress_decid           => veg_vp%stress_decid                           ,& ! Input:   binary flag for stress
+         !ALL COMMENTED VARIABLES NEED TO BE DECLARED
+         a_fix                  => veg_vp%a_fix                                         , & ! Input:   A BNF parameter
+         b_fix                  => veg_vp%b_fix                                         , & ! Input:   A BNF parameter
+         c_fix                  => veg_vp%c_fix                                         , & ! Input:   A BNF parameter
+         s_fix                  => veg_vp%s_fix                                         , & ! Input:   A BNF parameter
+         akc_active             => veg_vp%akc_active                                    , & ! Input:   A mycorrhizal uptake
+         !  parameter
+         akn_active             => veg_vp%akn_active                                    , & ! Input:   A mycorrhizal uptake
+         !  parameter
+         akcp_active             => veg_vp%akcp_active                                   , & ! Input:   A mycorrhizal uptake
+         !  parameter
+         akp_active             => veg_vp%akp_active                                    , & ! Input:   A mycorrhizal uptake
+         !  parameter
+         ekc_active             => veg_vp%ekc_active                                    , & ! Input:   A mycorrhizal uptake
+         !  parameter
+        ekn_active             => veg_vp%ekn_active                                    , & ! Input:   A mycorrhizal upatke
+         !  parameter
+         ekcp_active             => veg_vp%ekcp_active                                   , & ! Input:   A mycorrhizal uptake
+         !  parameter
+         ekp_active             => veg_vp%ekp_active                                    , & ! Input:   A mycorrhizal upatke
+         !  parameter
+         kc_nonmyc              => veg_vp%kc_nonmyc                                     , & ! Input:   A non-mycorrhizal uptake
+         !  parameter
+         kn_nonmyc              => veg_vp%kn_nonmyc                                     , & ! Input:   A non-mycorrhizal uptake
+         !  parameter
+         kcp_nonmyc              => veg_vp%kcp_nonmyc                                     , & ! Input:   A non-mycorrhizal uptake
+         !  parameter
+         kp_nonmyc              => veg_vp%kp_nonmyc                                     , & ! Input:   A non-mycorrhizal uptake
+         !  parameter
+         perecm                 => veg_vp%perecm                                        , & ! Input:   The fraction of ECM
+         ! -associated PFT 
+         kr_resorb              => veg_vp%kr_resorb                                     , & ! Input:   Parameter for N retranslocation
+         krp_resorb             => veg_vp%krp_resorb                                    , & ! Input:   Parameter for P retranslocation
+         ! -associated PFT 
+         !grperc                 => veg_vp%grperc (DECLARED AS pftcon variable)                      & ! Input:   growth percentage
+         fun_cn_flex_a           => veg_vp%fun_cn_flex_a                                , & ! Parameter a of FUN-flexcn link code (def 5)
+         fun_cn_flex_b           => veg_vp%fun_cn_flex_b                                , & ! Parameter b of FUN-flexcn link code (def 200)
+         fun_cn_flex_c           => veg_vp%fun_cn_flex_c                                , & ! Parameter b of FUN-flexcn link code (def 80)
+         fun_cp_flex_a           => veg_vp%fun_cp_flex_a                                , & ! Parameter a of FUN-flexcp link code (def 5)
+         fun_cp_flex_b           => veg_vp%fun_cp_flex_b                                , & ! Parameter b of FUN-flexcp link code (def 200)
+         fun_cp_flex_c           => veg_vp%fun_cp_flex_c                                , & ! Parameter b of FUN-flexcp link code (def 80)     
+         FUN_fracfixers          => veg_vp%FUN_fracfixers                               , & ! Fraction of C that can be used for fixation. 
+         leafcn_offset          => cnstate_vars%leafcn_offset_patch                    , & ! Output:
+         !  [real(r8)  (:)]  Leaf C:N used by FUN
+         leafcp_offset          => cnstate_vars%leafcp_offset_patch                    , & ! Output:
+         !  [real(r8)  (:)]  Leaf C:P used by FUN-P
+        plantCN                => cnstate_vars%plantCN_patch                          , & ! Output:  [real(r8)  (:)]  Plant
+         !  C:N used by FUN
+        plantCP                => cnstate_vars%plantCP_patch                          , & ! Output:  [real(r8)  (:)]  Plant
+         !  C:P used by FUN-P
+        onset_flag             => cnstate_vars%onset_flag_patch                       , & ! Output:  [real(r8)  (:)]  onset
+         !  flag
+        offset_flag            => cnstate_vars%offset_flag_patch                      , & ! Output:  [real(r8)  (:)]  offset
+         !  flag
+        availc                 =>              veg_cf%availc                                       , & ! Input:  [real(r8)  (:)]  C flux
+         !  available for allocation (gC/m2/s)
+        leafc                  => veg_cs%leafc                                        , & ! Input:  [real(r8) (:)   ]  
+        leafc_storage          => veg_cs%leafc_storage                               , & ! Input:   [real(r8)
+         !  (:)]  (gC/m2) leaf C storage
+        frootc                 => veg_cs%frootc                                      , & ! Input:  [real(r8) (:)   ]      
+         !  (:)]  (gC/m2) fine root C
+        frootc_storage         => veg_cs%frootc_storage                              , & ! Input:   [real(r8)
+         !  (:)]  (gC/m2) fine root C storage
+        livestemc              =>          veg_cs%livestemc                                   , & ! Input:   [real(r8)
+         !  (:)]  (gC/m2) live stem C
+       livecrootc             =>        veg_cs%livecrootc                                  , & ! Input:   [real(r8)
+         !  (:)]  (gC/m2) live coarse root C
+       leafc_storage_xfer_acc => veg_cs%leafc_storage_xfer_acc      , & ! Output:  [real(r8)
+         !  (:)]  Accmulated leaf C transfer (gC/m2)
+       storage_cdemand        => veg_cs%storage_cdemand             , & ! Output:  [real(r8)
+         !  (:)]  C use f rom the C storage pool
+       tlai                   => canopystate_vars%tlai_patch                        , & ! Input:  [real(r8) (:)   ] one
+         ! -sided leaf area index
+        leafn                        => veg_ns%leafn                                       , & ! Input:   [real(r8)  (:)]
+         !   (gN/m2) leaf N
+        leafp                        =>     veg_ps%leafp                                       , & ! Input:   [real(r8)  (:)]
+         !   (gP/m2) leaf P
+        frootn                       =>    veg_ns%frootn                                      , & ! Input:   [real(r8)  (:)]
+         !   (gN/m2) fine root N
+        frootp                       =>    veg_ps%frootp                                      , & ! Input:   [real(r8)  (:)]
+         !   (gP/m2) fine root P
+       livestemn                    =>     veg_ns%livestemn                                   , & ! Input:   [real(r8)  (:)]
+         !   (gN/m2) live stem N
+       livestemp                    =>     veg_ps%livestemp                                   , & ! Input:   [real(r8)  (:)]
+         !   (gP/m2) live stem P
+       livecrootn                  =>     veg_ns%livecrootn                                  , & ! Input:   [real(r8)  (:)]
+         !   (gN/m2) live coarse root N
+       livecrootp                  =>     veg_ps%livecrootp                                  , & ! Input:   [real(r8)  (:)]
+         !   (gP/m2) live coarse root P
+        leafn_storage_xfer_acc => veg_ns%leafn_storage_xfer_acc    , & ! Output:  [real(r8)  (:)]
+         !   Accmulated leaf N transfer (gC/m2)
+        leafp_storage_xfer_acc => veg_ps%leafp_storage_xfer_acc    , & ! Output:  [real(r8)  (:)]
+         !   Accmulated leaf P transfer (gC/m2)
+       storage_ndemand        => veg_ns%storage_ndemand           , & ! Output:  [real(r8)  (:)]
+         !   N demand during the offset period
+       storage_pdemand        => veg_ps%storage_pdemand           , & ! Output:  [real(r8)  (:)]
+         !   P demand during the offset period
+        leafc_to_litter        =>         veg_cf%leafc_to_litter                             , & ! Output:  [real(r8)
+         !  (:) ]  leaf C litterfall (gC/m2/s)
+         leafc_to_litter_fun   =>     veg_cf%leafc_to_litter_fun                         , & ! Output:  [real(r8)
+         !  (:) ]  leaf C litterfall used by FUN (gC/m2/s)
+         leafc_to_litter_funp   =>     veg_cf%leafc_to_litter_funp                         , & ! Output:  [real(r8)
+         !  (:) ]  leaf C litterfall used by FUN-P (gC/m2/s)
+       prev_leafc_to_litter   =>      veg_cf%prev_leafc_to_litter                          , & ! Output: [real(r8) (:)
+         !  ] previous timestep leaf C litterfall flux (gC/m2/s)
+        leafc_storage_to_xfer  =>     veg_cf%leafc_storage_to_xfer                         , & ! Output:  [real(r8)
+         !  (:) ] leaf C shift storage to transfer
+         npp_Nactive            =>     veg_cf%npp_Nactive                                  , & ! Output:  [real(r8)
+         !  (:) ]  Mycorrhizal N uptake used C (gC/m2/s)
+         npp_Pactive            =>     veg_cf%npp_Pactive                                  , & ! Output:  [real(r8)
+         !  (:) ]  Mycorrhizal P uptake used C (gC/m2/s)
+         npp_Nnonmyc            =>            veg_cf%npp_Nnonmyc                                 , & ! Output:  [real(r8)
+         !  (:) ]  Non-mycorrhizal N uptake use C (gC/m2/s)
+         npp_Pnonmyc            =>            veg_cf%npp_Pnonmyc                                 , & ! Output:  [real(r8)
+         !  (:) ]  Non-mycorrhizal P uptake use C (gC/m2/s)
+         npp_Nam                =>          veg_cf%npp_Nam                                     , & ! Output:  [real(r8)
+         !  (:) ]  AM uptake use C (gC/m2/s)
+         npp_Pam                =>          veg_cf%npp_Pam                                     , & ! Output:  [real(r8)
+         !  (:) ]  AM uptake of P use C (gC/m2/s)
+         npp_Necm               => veg_cf%npp_Necm                 , & ! Output:  [real(r8)
+         !  (:) ]  ECM uptake use C (gC/m2/s)
+         npp_Pecm               => veg_cf%npp_Pecm                 , & ! Output:  [real(r8)
+         !  (:) ]  ECM uptake of Puse C (gC/m2/s)
+         npp_Nactive_no3        => veg_cf%npp_Nactive_no3          , & ! Output:  [real(r8)
+         !  (:) ]  Mycorrhizal N uptake used C (gC/m2/s)
+         npp_Nnonmyc_no3        => veg_cf%npp_Nnonmyc_no3          , & ! Output:  [real(r8)
+         !  (:) ]  Non-myco uptake use C (gC/m2/s) rrhizal N uptake
+         !   (gN/m2/s)
+         npp_Nam_no3            => veg_cf%npp_Nam_no3              , & ! Output:  [real(r8)
+         !  (:) ]  AM uptake use C (gC/m2/s)
+         npp_Necm_no3           => veg_cf%npp_Necm_no3             , & ! Output:  [real(r8)
+         !  (:) ]  ECM uptake use C (gC/m2/s)
+         npp_Nactive_nh4        => veg_cf%npp_Nactive_nh4          , & ! Output:  [real(r8)
+         !  (:) ]  Mycorrhizal N uptake used C (gC/m2/s)
+         npp_Nnonmyc_nh4        => veg_cf%npp_Nnonmyc_nh4          , & ! Output:  [real(r8)
+         !  (:) ]  Non-mycorrhizal N uptake used C (gC/m2/s)
+         npp_Nam_nh4            => veg_cf%npp_Nam_nh4              , & ! Output:  [real(r8)
+         !  (:) ]  AM uptake used C(gC/m2/s)
+         npp_Necm_nh4           => veg_cf%npp_Necm_nh4             , & ! Output:  [real(r8)
+         !  (:) ]  ECM uptake used C (gC/m2/s)
+         npp_Nfix               => veg_cf%npp_Nfix                 , & ! Output:  [real(r8)
+         !  (:) ]  Symbiotic BNF used C (gC/m2/s)
+         npp_Nretrans           => veg_cf%npp_Nretrans             , & ! Output:  [real(r8)
+         !  (:) ]  Retranslocation N uptake used C (gC/m2/s)
+         npp_Pretrans           => veg_cf%npp_Pretrans             , & ! Output:  [real(r8)
+         !  (:) ]  Retranslocation P uptake used C (gC/m2/s)
+         npp_Nuptake            => veg_cf%npp_Nuptake              , & ! Output:  [real(r8)
+         !  (:) ]  Total N uptake of FUN used C (gC/m2/s)
+         npp_Puptake            => veg_cf%npp_Puptake              , & ! Output:  [real(r8)
+         !  (:) ]  Total N uptake of FUN used C (gC/m2/s)
+         npp_growth             => veg_cf%npp_growth               , & ! Output:  [real(r8)
+         !  (:) ]  Total N uptake of FUN used C (gC/m2/s) 
+         npp_growth_p           => veg_cf%npp_growth_p               , & ! Output:  [real(r8)
+         !  (:) ]  Total P uptake of FUN-P used C (gC/m2/s)
+         burnedoff_carbon       => veg_cf%npp_burnedoff            , & ! Output:  [real(r8)
+         !  (:) ]  C  that cannot be used for N uptake(gC/m2/s)
+         burnedoff_carbon_p     => veg_cf%npp_burnedoff_p          , & ! Output:  [real(r8)
+         !  (:) ]  C  that cannot be used for P uptake(gC/m2/s)   
+         leafc_change           => veg_cf%leafc_change             , & ! Output:  [real(r8)
+         !  (:) ]  Used C from the leaf (gC/m2/s)
+         leafn_storage_to_xfer  =>          veg_nf%leafn_storage_to_xfer                        ,  & ! Output:  [real(r8) (:) ]
+       !  (:) ] leaf N shift storage to transfer
+         leafp_storage_to_xfer  =>          veg_pf%leafp_storage_to_xfer                        ,  & ! Output:  [real(r8) (:) ]
+       !  (:) ] leaf P shift storage to transfer
+          plant_ndemand          =>         veg_nf%plant_ndemand                       , & ! Intput:  [real(r8) (:)
+         !  ]  N flux required to support initial GPP (gN/m2/s)
+          plant_pdemand          =>         veg_pf%plant_pdemand                       , & ! Intput:  [real(r8) (:)
+         !  ]  P flux required to support initial GPP (gP/m2/s)
+         plant_ndemand_retrans  =>       veg_nf%plant_ndemand_retrans              , & ! Output:  [real(r8) (:)
+         !  ]  N demand generated for FUN (gN/m2/s)
+         plant_pdemand_retrans  =>       veg_pf%plant_pdemand_retrans              , & ! Output:  [real(r8) (:)
+         !  ]  P demand generated for FUN-P (gP/m2/s)
+         plant_ndemand_season   =>             veg_nf%plant_ndemand_season               , & ! Output:  [real(r8) (:)
+         !  ]  N demand for seasonal deciduous forest (gN/m2/s)
+         plant_pdemand_season   =>             veg_pf%plant_pdemand_season               , & ! Output:  [real(r8) (:)
+         !  ]  P demand for seasonal deciduous forest (gP/m2/s)
+         plant_ndemand_stress   =>             veg_nf%plant_ndemand_stress               , & ! Output:  [real(r8) (:)
+         !  ]  N demand for stress deciduous forest   (gN/m2/s)
+         plant_pdemand_stress   =>             veg_pf%plant_pdemand_stress               , & ! Output:  [real(r8) (:)
+         !  ]  P demand for stress deciduous forest   (gP/m2/s)
+         Nactive                =>               veg_nf%Nactive                            , & ! Output:  [real(r8) (:)
+         !  ]  Mycorrhizal N uptake (gN/m2/s)
+         Pactive                =>               veg_pf%Pactive                            , & ! Output:  [real(r8) (:)
+         !  ]  Mycorrhizal P uptake (gP/m2/s)
+         Nnonmyc                =>             veg_nf%Nnonmyc                           , & ! Output:  [real(r8) (:)
+         !  ]  Non-mycorrhizal N uptake (gN/m2/s)
+         Pnonmyc                =>             veg_pf%Pnonmyc                           , & ! Output:  [real(r8) (:)
+         !  ]  Non-mycorrhizal P uptake (gP/m2/s)
+         Nam                    =>             veg_nf%Nam                               , & ! Output:  [real(r8) (:) ]  AM
+         !  uptake (gN/m2/s)
+         Pam                    =>             veg_pf%Pam                               , & ! Output:  [real(r8) (:) ]  AM
+         !  uptake (gP/m2/s)
+         Necm                   =>             veg_nf%Necm                              , & ! Output:  [real(r8) (:) ]  ECM
+         !  uptake (gN/m2/s)
+         Pecm                   =>             veg_pf%Pecm                              , & ! Output:  [real(r8) (:) ]  ECM
+         !  uptake (gP/m2/s)
+         Nactive_no3            =>             veg_nf%Nactive_no3                       , & ! Output:  [real(r8) (:)
+         !  ]  Mycorrhizal N uptake (gN/m2/s)
+         Nnonmyc_no3            =>            veg_nf%Nnonmyc_no3                       , & ! Output:  [real(r8) (:)
+         !  ]  Non-mycorrhizal N uptake (gN/m2/s)
+         Nam_no3                =>                 veg_nf%Nam_no3                           , & ! Output:  [real(r8) (:)
+         !  ]  AM uptake (gN/m2/s)
+         Necm_no3               =>              veg_nf%Necm_no3                          , & ! Output:  [real(r8) (:)
+         !  ]  ECM uptake (gN/m2/s)
+         Nactive_nh4            =>              veg_nf%Nactive_nh4                       , & ! Output:  [real(r8) (:)
+         !  ]  Mycorrhizal N uptake (gN/m2/s)
+         Nnonmyc_nh4            =>              veg_nf%Nnonmyc_nh4                      , & ! Output:  [real(r8) (:)
+         !  ]  Non-mycorrhizal N uptake (gN/m2/s)
+         Nam_nh4                =>            veg_nf%Nam_nh4                          , & ! Output:  [real(r8) (:)
+         !  ]  AM uptake (gN/m2/s)
+         Necm_nh4               =>             veg_nf%Necm_nh4                         , & ! Output:  [real(r8) (:)
+         !  ]  ECM uptake (gN/m2/s)
+         Npassive               =>             veg_nf%Npassive                         , & ! Output:  [real(r8) (:)
+         !  ]  Passive N uptake (gN/m2/s)
+         Ppassive               =>             veg_pf%Ppassive                         , & ! Output:  [real(r8) (:)
+         !  ]  Passive P uptake (gP/m2/s)
+         Nfix                   =>             veg_nf%Nfix                             , & ! Output:  [real(r8) (:) ]
+         !  Symbiotic BNF (gN/m2/s)
+         cost_nfix              =>            veg_nf%cost_Nfix                        , & ! Output:  [real(r8) (:)
+         !  ]  Cost of fixation gC:gN
+         cost_nactive           =>               veg_nf%cost_Nactive                    , & ! Output:  [real(r8) (:) ]
+         !  Cost of active uptake gC:gN 
+         cost_pactive           =>               veg_pf%cost_Pactive                    , & ! Output:  [real(r8) (:) ]
+         !  Cost of active uptake gC:gP       
+         cost_nretrans          =>                veg_nf%cost_Nretrans                   , & ! Output:  [real(r8) (:) ]
+         !  Cost of retranslocation gC:gN
+         cost_pretrans          =>                veg_pf%cost_Pretrans                   , & ! Output:  [real(r8) (:) ]
+         !  Cost of retranslocation gC:gP 
+         cost_nnonmyc          =>                veg_nf%cost_Nnonmyc                   , & ! Output:  [real(r8) (:) ]
+         !  Cost of nonmyc gC:gN
+         cost_pnonmyc          =>                veg_pf%cost_Pnonmyc                   , & ! Output:  [real(r8) (:) ]
+         !  Cost of nonmyc gC:gP
+         nuptake_npp_fraction_patch =>          veg_nf%nuptake_npp_fraction            , & ! Output:  [real(r8) (:)
+         !  ]  frac of NPP in NUPTAKE 
+         puptake_npp_fraction_patch =>          veg_pf%puptake_npp_fraction            , & ! Output:  [real(r8) (:)
+         !  ]  frac of NPP in PUPTAKE 
+        c_allometry            =>   cnstate_vars%c_allometry_patch          , & ! Output: [real(r8) (:)   ]  C
+         !  allocation index (DIM)    
+        n_allometry            =>    cnstate_vars%n_allometry_patch          , & ! Output: [real(r8) (:)   ]  N
+         !  allocation index (DIM)  
+        p_allometry            =>    cnstate_vars%p_allometry_patch          , & ! Output: [real(r8) (:)   ]  P
+         !  allocation index (DIM) 
+         leafn_storage          =>                veg_ns%leafn_storage                  , & ! Input:  [real(r8) (:)
+         !  ]  (gN/m2) leaf N store
+         leafp_storage          =>                veg_ps%leafp_storage                  , & ! Input:  [real(r8) (:)
+         !  ]  (gN/m2) leaf P store
+         nfix_to_sminn          =>                 col_nf%nfix_to_sminn                  , & ! Output:  [real(r8) (:)]
+         !  symbiotic/asymbiotic N fixation to soil mineral N (gN/m2
+         !  /s)
+         Nretrans               =>             veg_nf%Nretrans                      , & ! Output:  [real(r8) (:)
+         !  ]  Retranslocation N uptake (gN/m2/s)
+         Pretrans               =>             veg_pf%Pretrans                      , & ! Output:  [real(r8) (:)
+         !  ]  Retranslocation P uptake (gP/m2/s)
+         Nretrans_season        =>             veg_nf%Nretrans_season               , & ! Output:  [real(r8) (:)
+         !  ]  Retranslocation N uptake (gN/m2/s)
+         Pretrans_season        =>             veg_pf%Pretrans_season               , & ! Output:  [real(r8) (:)
+         !  ]  Retranslocation P uptake (gP/m2/s)
+         Nretrans_stress        =>             veg_nf%Nretrans_stress               , & ! Output:  [real(r8) (:)
+         !  ]  Retranslocation N uptake (gN/m2/s)
+         pretrans_stress        =>             veg_pf%Pretrans_stress               , & ! Output:  [real(r8) (:)
+         !  ]  Retranslocation P uptake (gP/m2/s)
+
+         Nuptake                =>             veg_nf%Nuptake                      , & ! Output:  [real(r8) (:)
+         !  ]  Total N uptake of FUN (gN/m2/s)
+        Puptake                =>             veg_pf%Puptake                      , & ! Output:  [real(r8) (:)
+         !  ]  Total P uptake of FUN-P (gP/m2/s)
+
+       retransn_to_npool      =>        veg_nf%retransn_to_npool             , & ! Output: [real(r8)
+         !  (:)   ]  deployment of retranslocated N (gN/m2/s)
+       retransp_to_ppool      =>        veg_pf%retransp_to_ppool             , & ! Output: [real(r8)
+         !  (:)   ]  deployment of retranslocated P (gP/m2/s)
+
+         free_retransn_to_npool =>     veg_nf%free_retransn_to_npool         , & ! Output: [real(r8)
+         ! uptake of free N from leaves (needed to allow RT during the night with no NPP
+         free_retransp_to_ppool =>     veg_pf%free_retransp_to_ppool         , & ! Output: [real(r8)
+         ! uptake of free P from leaves (needed to allow RT during the night with no NPP
+         sminn_to_plant_fun     => veg_nf%sminn_to_plant_fun              , & ! Output:
+         !  [real(r8) (:) ]  Total soil N uptake of FUN (gN/m2/s)
+         sminp_to_plant_fun     => veg_pf%sminp_to_plant_fun              , & ! Output:
+         !  [real(r8) (:) ]  Total soil P uptake of FUN (gP/m2/s)
+         sminn_to_plant_fun_vr  => veg_nf%sminn_to_plant_fun_vr           , & ! Output:
+         !  [real(r8) (:) ]  Total layer soil N uptake of FUN (gN/m2
+         !  /s) 
+         sminp_to_plant_fun_vr  => veg_pf%sminp_to_plant_fun_vr           , & ! Output:
+         !  [real(r8) (:) ]  Total layer soil P uptake of FUN (gP/m2
+         !  /s) 
+         sminn_to_plant_fun_no3_vr  => veg_nf%sminn_to_plant_fun_no3_vr   , & ! Output:  [real(r8)
+         !  (:) ]  Total layer no3 uptake of FUN (gN/m2/s)
+         sminn_to_plant_fun_nh4_vr  => veg_nf%sminn_to_plant_fun_nh4_vr   , & ! Output:  [real(r8)
+         !  (:) ]  Total layer nh4 uptake of FUN (gN/m2/s)
+        sminn_to_plant_vr      => col_nf%sminn_to_plant_vr      , & ! Output:  [real(r8) (:
+         ! ,:) ]
+        sminp_to_plant_vr      => col_pf%sminp_to_plant_vr      , & ! Output:  [real(r8) (:
+         ! ,:) ]
+        smin_no3_to_plant_vr   => col_nf%smin_no3_to_plant_vr     , & ! Output:  [real(r8) (:
+         ! ,:) ]
+       smin_nh4_to_plant_vr   => col_nf%smin_nh4_to_plant_vr     , & ! Output:  [real(r8) (:
+         ! ,:) ]
+       smin_vr_nh4                  => col_ns%smin_nh4_vr             , & ! Input:  [real(r8) (:,:) ]  (gN/m3) soil mineral
+         !  NH4              
+       smin_vr_no3                  => col_ns%smin_no3_vr             , & ! Input:  [real(r8) (:,:) ]  (gN/m3) soil mineral (?) OR smin_vr_no3                  => clm_bgc_data%smin_no3_vr_col             , & ! Input:  [real(r8) (:,:) ]  (gN/m3) soil mineral (?)
+         !  NO3  
+        smin_vr_pox                 => col_ps%sminp_vr             , & ! Input:  [real(r8) (:,:) ]  (gN/m3) soil mineral (?) OR     
+       solutionp_vr                 =>                     col_ps%solutionp_vr                   , & ! Input:  [real(r8) (:,:) ]  (gN/m3) soil soluble mineral P ready for plant uptake     
+         soilc_change           => veg_cf%soilc_change               , & ! Output:  [real(r8)
+         !  (:) ]  Used C from the soil (gC/m2/s)
+         soilc_change_p         => veg_cf%soilc_change_p               , & ! Output:  [real(r8)
+         !  (:) ]  Used C from the soil for P(gC/m2/s)
+       h2osoi_liq             => col_ws%h2osoi_liq                                , & ! Input:   [real(r8) (:,:)]
+         !   liquid water (kg/m2) (new) (-nlevsno+1:nlevgrnd) (?)
+       qflx_tran_veg          => veg_wf%qflx_tran_veg                        , & ! Input:   [real(r8) (:)  ]
+         !   vegetation transpiration (mm H2O/s) (+ = to atm) 
+         t_soisno                            =>    col_es%t_soisno                         , & ! Input:  [real(r8)  (:,:) ]  soil temperature (Kelvin)  (-nlevsno+1:nlevgrnd)
+       crootfr                => soilstate_vars%rootfr_patch                                    & ! Input:   [real(r8) (:,:)]
+         !   fraction of roots in each soil layer  (nlevgrnd)
+         ! But is it the same as for fraction of roots for carbon 
+         !in each soil layer?
+       
+         )
+
+
+
+        !perecm = (/1.00_r8, 1.00_r8, 1.00_r8, 1.00_r8, 0.0_r8, &
+        !           0.0_r8, 0.0_r8, 0.5_r8, 1.00_r8, 1.00_r8, &
+        !           1.00_r8, 1.00_r8, 1.00_r8, 0.0_r8, 0.0_r8, &
+        !           0.0_r8, 0.0_r8, 0.0_r8, 0.0_r8, 0.0_r8, &
+        !           0.0_r8, 0.0_r8, 0.0_r8, 0.0_r8, 0.0_r8/)
+
+        !perecm = (/0.99_r8, 0.99_r8, 0.99_r8, 0.01_r8, &
+        !           0.01_r8, 0.01_r8, 0.50_r8, 0.99_r8, 0.99_r8, &
+        !           0.99_r8, 0.99_r8, 0.99_r8, 0.01_r8, 0.01_r8, &
+        !           0.01_r8, 0.01_r8, 0.01_r8, 0.01_r8, 0.01_r8, &
+        !           0.01_r8, 0.01_r8, 0.01_r8, 0.01_r8, 0.01_r8, 0.99_r8/)
+
+        !write(iulog,*) 'perecm=', perecm 
+
+        !akc_active = (/0.0_r8, 0.06_r8, 0.06_r8, 0.06_r8, 0.06_r8, &
+        !               0.06_r8, 0.006_r8, 0.06_r8, 0.06_r8, 0.06_r8, &
+        !               0.06_r8, 0.06_r8, 0.06_r8, 0.06_r8, 0.6_r8, &
+        !               0.06_r8, 0.06_r8, 0.6_r8, 0.6_r8, 0.06_r8, &
+        !               0.06_r8, 0.06_r8, 0.06_r8, 0.06_r8, 0.06_r8/)
+
+        !akn_active = (/0.0_r8, 0.12_r8, 0.12_r8, 0.12_r8, 0.12_r8, &
+        !               0.12_r8, 0.012_r8, 0.12_r8, 0.12_r8, 0.12_r8, &
+        !               0.12_r8, 0.12_r8, 0.12_r8, 0.12_r8, 1.2_r8, &
+        !               0.12_r8, 0.12_r8, 1.2_r8, 1.2_r8, 0.12_r8, &
+        !               0.12_r8, 0.12_r8, 0.12_r8, 0.12_r8, 0.12_r8/)
+
+        !ekc_active = (/0.0_r8, 0.36_r8, 0.36_r8, 0.036_r8, 0.36_r8, &
+        !               0.36_r8, 0.036_r8, 0.36_r8, 0.36_r8, 0.36_r8, & 
+        !               0.36_r8, 0.36_r8, 0.36_r8, 0.36_r8, 3.6_r8, &
+        !               0.36_r8, 0.36_r8, 3.6_r8, 3.6_r8, 0.36_r8, &
+        !               0.36_r8, 0.36_r8, 0.36_r8, 0.36_r8, 0.36_r8/)
+
+        !ekn_active = (/0.0_r8, 0.06_r8, 0.06_r8, 0.006_r8, 0.06_r8, &
+        !               0.06_r8, 0.006_r8, 0.06_r8, 0.06_r8, 0.06_r8, &
+        !               0.06_r8, 0.06_r8, 0.06_r8, 0.06_r8, 0.6_r8, &
+        !               0.06_r8, 0.06_r8, 0.6_r8, 0.6_r8, 0.06_r8, &
+        !               0.06_r8, 0.06_r8, 0.06_r8, 0.06_r8, 0.06_r8/) 
+
+       !Following Kara Allen's FUN3 values
+
+       !ekc_active = (/0.0_r8, 0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8, &
+       !                0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8, & 
+       !                0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8, &
+       !                0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8, &
+       !                0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8/)
+
+        !ekn_active = (/0.0_r8, 0.1_r8, 0.1_r8, 0.1_r8, 0.1_r8, &
+        !               0.1_r8, 0.1_r8, 0.1_r8, 0.1_r8, 0.1_r8, &
+        !               0.1_r8, 0.1_r8, 0.1_r8, 0.1_r8, 0.1_r8, &
+        !               0.1_r8, 0.1_r8, 0.1_r8, 0.1_r8, 0.1_r8, &
+        !               0.1_r8, 0.1_r8, 0.1_r8, 0.1_r8, 0.1_r8/) 
+
+        !kc_nonmyc = (/0.0_r8, 0.72_r8, 0.72_r8, 0.72_r8, 0.72_r8, &
+        !              0.72_r8, 0.072_r8, 0.72_r8, 0.72_r8, 0.72_r8, &
+        !              0.72_r8, 0.72_r8, 0.72_r8, 0.72_r8, 7.2_r8, &
+        !              0.72_r8, 0.72_r8, 7.2_r8, 7.2_r8, 0.72_r8, &
+        !              0.72_r8, 0.72_r8, 0.72_r8,  0.72_r8, 0.72_r8/)
+
+        !kn_nonmyc = (/0.0_r8, 0.012_r8, 0.012_r8, 0.0012_r8, 0.012_r8, &
+        !              0.012_r8, 0.0012_r8, 0.012_r8, 0.012_r8, 0.012_r8, &
+        !              0.012_r8, 0.012_r8, 0.012_r8, 0.012_r8, 0.12_r8, &
+        !              0.012_r8, 0.012_r8, 0.12_r8, 0.12_r8, 0.012_r8, & 
+        !              0.012_r8, 0.012_r8, 0.012_r8, 0.012_r8, 0.012_r8/)
+
+        !FUN_fracfixers = (/0.25_r8, 0.25_r8, 0.25_r8, 0.25_r8, &
+        !                   0.25_r8, 0.25_r8, 0.25_r8, 0.25_r8, 0.25_r8, & 
+        !                   0.25_r8, 0.25_r8, 0.25_r8, 0.25_r8, 0.25_r8, &
+        !                   0.0_r8, 0.0_r8, 0.0_r8, 0.0_r8, 0.0_r8, &
+        !                   0.0_r8, 0.0_r8, 0.0_r8, 1.0_r8, 1.0_r8, 1.0_r8/)
+
+ !akcp_active = 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 
+ !   0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5 ;
+
+ !akp_active = 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 
+ !   0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1 ;
+
+ !ekcp_active = 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 
+ !   5, 5, 5, 5 ;
+
+ !ekp_active = 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 
+ !   0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 
+ !   0.07, 0.07, 0.07 ;
+
+         !kcp_nonmyc = (/0.0_r8, 0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8, &
+         !               0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8, & 
+         !               0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8, &
+         !               0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8, &
+         !               0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8, 0.3_r8/)
+
+         !kp_nonmyc = (/0.0_r8, 0.8_r8, 0.8_r8, 0.8_r8, 0.8_r8, &
+         !               0.8_r8, 0.8_r8, 0.8_r8, 0.8_r8, 0.8_r8, & 
+         !               0.8_r8, 0.8_r8, 0.8_r8, 0.8_r8, 0.8_r8, &
+         !               0.8_r8, 0.8_r8, 0.8_r8, 0.8_r8, 0.8_r8, &
+         !               0.8_r8, 0.8_r8, 0.8_r8, 0.8_r8, 0.8_r8/)
+
+   
+
+            !FUN 
+               !CHECKING THAT VARIABLES NEEDED FOR FUN ARE CORRECT
+           ! do fp=1,num_soilp
+           !    p = filter_soilp(fp)
+           !    c = veg_pp%column(p)
+
+               !write(iulog,*) 'Fixer fraction', FUN_fracfixers(ivt(p)), &
+               !               'perecm', perecm(ivt(p)), &
+           !                   'Soil N', smin_vr_no3(c,:)+smin_vr_nh4(c,:), &
+           !                   'Soil P', solutionp_vr(c,:), &
+           !                   'Fine Root Biomass', frootc(p), &
+           !                   'Frac Root nlevgrd', crootfr(p,:), &      
+           !                   'leaf N', leafn(p), &
+           !                   'leaf P', leafp(p), &
+           !                   'NPP0', availc(p), & !(?) 
+           !                   'plantcn', leafcn(ivt(p)), &
+           !                   'plantcp', leafcp(ivt(p)), &
+           !                   'plantnp', leafcp(ivt(p))/leafcn(ivt(p)), &
+           !                   'Soil water depth', h2osoi_liq(c,1), & 
+           !                   'Soil T', t_soisno(c,1), & 
+           !                   'ET', qflx_tran_veg(p), & !NaN
+                              !'c3psn', veg_vp%c3psn, &
+                  !            'ivt(p)', ivt(p)
+           !                  'perECM', perecm
+                              !'veg_vp%perECM',  &                             
+                              !'perECM', veg_vp%perecm, &
+                              !'akc_active',akc_active, &
+                              !'fun_cn_flex_a', fun_cn_flex_a
+              !1) Which available carbon?
+              !2) Physical variables before/after nutrients?
+              !3) Fixers and NonFixer as in CLM5.0.
+             !end do
+
+ 
+          
+
+  !--------------------------------------------------------------------
+  !-----------
+  ! Initialize output fluxes, which were also initialized in CNFUNMod.
+  !--------------------------------------------------------------------
+  !-----------
+
+  !No flexibleCN
+  !local_use_flexibleCN            = use_flexibleCN
+  !steppday                        = 48._r8
+  steppday                        = 24._r8
+  qflx_tran_veg_layer             = 0._r8
+  rootc_dens_step                 = 0._r8
+  plant_ndemand_pool              = 0._r8
+
+  if(use_funp)then
+     plant_pdemand_pool           = 0._r8
+  end if
+
+  call t_startf('CNFUNzeroarrays')
+  do fp = 1,num_soilp        ! PFT Starts
+     p = filter_soilp(fp)
+     availc_pool(p)                  = 0._r8
+     rootC(p)                        = 0._r8
+     litterfall_n(p)                 = 0._r8
+     burnedoff_carbon(p)             = 0._r8
+
+     if(use_funp)then
+        availc_pool_p(p)             = 0._r8
+        litterfall_p(p)              = 0._r8
+        burnedoff_carbon_p(p)        = 0._r8
+     end if
+
+  end do
+
+
+  do j = 1, nlevdecomp
+     do fp = 1,num_soilp        ! PFT Starts
+        p = filter_soilp(fp)
+        c = veg_pp%column(p)
+        rootc_dens(p,j)                 = 0._r8 
+        cost_retran(p,j)                = 0._r8
+        cost_fix(p,j)                   = 0._r8
+        cost_resis(p,j)                 = 0._r8
+        cost_res_resis(p,j)             = 0._r8
+        cost_active_no3(p,j)            = 0._r8
+        cost_active_nh4(p,j)            = 0._r8
+        cost_nonmyc_no3(p,j)            = 0._r8
+        cost_nonmyc_nh4(p,j)            = 0._r8
+   
+        sminn_no3_conc(c,j)             = 0._r8
+        sminn_no3_layer(c,j)            = 0._r8
+        sminn_nh4_conc(c,j)             = 0._r8
+        sminn_nh4_layer(c,j)            = 0._r8
+
+        if(use_funp)then 
+           cost_retran_p(p,j)           = 0._r8
+           cost_resis_p(p,j)            = 0._r8
+           cost_res_resis_p(p,j)        = 0._r8
+           cost_active_pox(p,j)         = 0._r8
+           cost_nonmyc_pox(p,j)         = 0._r8
+   
+           sminp_pox_conc(c,j)          = 0._r8
+           sminp_pox_layer(c,j)         = 0._r8
+        end if
+
+     end do
+  end do
+
+  do istp = 1, nstp
+     do fp = 1,num_soilp        ! PFT Starts
+        p = filter_soilp(fp)
+        npp_remaining(p,istp)           = 0._r8
+        permyc(p,istp)                  = 0._r8
+        plant_ndemand_pool_step(p,istp) = 0._r8
+        nt_uptake(p,istp)               = 0._r8
+        npp_uptake(p,istp)              = 0._r8
+        leafn_step(p,istp)              = 0._r8
+        leafn_retrans_step(p,istp)      = 0._r8
+        litterfall_n_step(p,istp)       = 0._r8
+        litterfall_c_step(p,istp)       = 0._r8
+
+        if(use_funp)then
+           npp_remaining_p(p,istp)         = 0._r8
+           plant_pdemand_pool_step(p,istp) = 0._r8
+           pt_uptake(p,istp)               = 0._r8
+           npp_uptake_p(p,istp)            = 0._r8
+           leafp_step(p,istp)              = 0._r8
+           leafp_retrans_step(p,istp)      = 0._r8
+           litterfall_p_step(p,istp)       = 0._r8
+           litterfall_c_step_p(p,istp)     = 0._r8
+        end if
+
+     end do
+     do j = 1, nlevdecomp
+        do fp = 1,num_soilp        ! PFT Starts
+           p = filter_soilp(fp)
+           sminn_no3_conc_step(p,j,istp)      = 0._r8
+           sminn_no3_layer_step(p,j,istp)     = 0._r8
+           sminn_no3_uptake(p,j,istp)         = 0._r8
+           sminn_nh4_conc_step(p,j,istp)      = 0._r8
+           sminn_nh4_layer_step(p,j,istp)     = 0._r8
+           sminn_nh4_uptake(p,j,istp)         = 0._r8
+
+           if(use_funp)then 
+              sminp_pox_conc_step(p,j,istp)   = 0._r8
+              sminp_pox_layer_step(p,j,istp)  = 0._r8
+              sminp_pox_uptake(p,j,istp)      = 0._r8
+           end if
+
+        end do
+     end do
+  end do
+
+  do icost = 1, ncost6
+     do j = 1, nlevdecomp
+        costNit(j,icost)                    = big_cost 
+     end do
+  end do
+
+  if(use_funp)then
+  do icost = 1, pcost3
+     do j = 1, nlevdecomp
+        costPho(j,icost)                    = big_cost 
+     end do
+  end do
+  end if
+
+  ! Time step of FUN
+  dt           =  real(get_step_size(), r8)
+  call t_stopf('CNFUNzeroarrays')
+  !--------------------------------------------------------------------
+  !----------------------------
+  ! Calculation starts
+  !--------------------------------------------------------------------
+  call t_startf('CNFUNcalcs1')
+  !----------------------------
+  do fp = 1,num_soilp        ! PFT Starts
+     p = filter_soilp(fp)
+
+     litterfall_n(p) =  (leafc_to_litter_fun(p) / leafcn_offset(p))  * dt
+     rootC(p)        =  frootc(p)
+
+     plantN(p)       =  leafn(p) + frootn(p) + livestemn(p) + livecrootn(p)
+     if (n_allometry(p).gt.0._r8) then 
+         plantCN(p)  = c_allometry(p)/n_allometry(p) !changed RF.
+         ! above code gives CN ratio too low. 
+     else
+         plantCN(p)  = 0._r8 
+     end if
+
+     if(use_funp)then
+        litterfall_p(p) =  (leafc_to_litter_funp(p) / leafcp_offset(p))  * dt
+
+        plantP(p)       =  leafp(p) + frootp(p) + livestemp(p) + livecrootp(p)
+     if (p_allometry(p).gt.0._r8) then 
+         plantCP(p)  = c_allometry(p)/p_allometry(p) 
+         ! above code gives CP ratio too low. 
+     else
+         plantCP(p)  = 0._r8 
+     end if
+     end if
+  end do   ! PFT ends
+  do istp = 1, nstp
+     do fp = 1,num_soilp        ! PFT Starts
+        p = filter_soilp(fp)
+
+
+        !perecm = (/0.99_r8, 0.99_r8, 0.99_r8, 0.01_r8, &
+        !           0.01_r8, 0.01_r8, 0.50_r8, 0.99_r8, 0.99_r8, &
+        !           0.99_r8, 0.99_r8, 0.99_r8, 0.01_r8, 0.01_r8, &
+        !           0.01_r8, 0.01_r8, 0.01_r8, 0.01_r8, 0.01_r8, &
+        !           0.01_r8, 0.01_r8, 0.01_r8, 0.01_r8, 0.01_r8, 0.99_r8/)
+       if(ivt(p).eq.0)then
+         perecm(ivt(p)) = 0.0_r8
+       else if(ivt(p).eq.1 .or.ivt(p).eq.2.or.ivt(p).eq.3.or.ivt(p).eq.8 .or.ivt(p).eq.9 .or.ivt(p).eq.10.or.ivt(p).eq.11.or.ivt(p).eq.12)then
+         perecm(ivt(p)) = 0.99_r8
+       else if(ivt(p).eq.7)then
+         perecm(ivt(p)) = 0.50_r8
+       else
+         perecm(ivt(p)) = 0.01_r8
+       end if
+
+
+
+
+        if (istp.eq.ecm_step) then
+
+           permyc(p,istp)      = perecm(ivt(p))
+           !kc_active(p,istp)   = ekc_active(ivt(p))
+           !kn_active(p,istp)   = ekn_active(ivt(p))
+ 
+          if(ivt(p).eq. 3.or. ivt(p).eq.6)then 
+             !Allen et al (2020) values 
+             kc_active(p,istp)   = 0.015_r8
+             kn_active(p,istp)   = 0.0025_r8
+             !CLM5 values 
+             !kc_active(p,istp)   = 0.036_r8
+             !kn_active(p,istp)   = 0.006_r8
+           else if(ivt(p).eq.14 .or. ivt(p).eq.17 .or. ivt(p).eq.18)then
+             !Allen et al (2020) values 
+             kc_active(p,istp)   = 1.5_r8/10._r8
+             kn_active(p,istp)   = 0.25_r8/10._r8
+            !CLM5 values
+             !kc_active(p,istp)   = 3.6_r8
+             !kn_active(p,istp)   = 0.6_r8
+           else  
+             !Allen et al (2020) values 
+             kc_active(p,istp)   = 0.15_r8
+             kn_active(p,istp)   = 0.025_r8
+             !CLM5 values 
+             !kc_active(p,istp)   = 0.36_r8
+             !kn_active(p,istp)   = 0.06_r8
+           end if
+ 
+         if(use_funp)then               
+          if(ivt(p).eq. 3.or. ivt(p).eq.6)then 
+              kcp_active(p,istp)  = (1.0_r8/10._r8)/scalex
+              kp_active(p,istp)   = (0.05_r8/10._r8)/scalex
+           else if(ivt(p).eq.14 .or. ivt(p).eq.17 .or. ivt(p).eq.18)then
+              kcp_active(p,istp)  = (1.0_r8*1._r8)/scalex
+              kp_active(p,istp)   = (0.05_r8*1._r8)/scalex
+           else  
+              !kcp_active(p,istp)  = ekcp_active(ivt(p))
+              !kp_active(p,istp)   = ekp_active(ivt(p))
+              kcp_active(p,istp)  = (1.0_r8)/scalex
+              kp_active(p,istp)   = (0.05_r8)/scalex
+           end if
+         end if
+
+        else
+           permyc(p,istp)      = 1._r8 - perecm(ivt(p))
+           !kc_active(p,istp)   = akc_active(ivt(p))
+           !kn_active(p,istp)   = akn_active(ivt(p))
+           if(ivt(p).eq.6)then 
+            !Allen et al (2020) values 
+             kc_active(p,istp)   = 0.0025_r8
+             kn_active(p,istp)   = 0.0050_r8
+             !CLM5 values 
+             !kc_active(p,istp)   = 0.006_r8
+             !kn_active(p,istp)   = 0.012_r8
+           else if(ivt(p).eq.14 .or. ivt(p).eq.7 .or. ivt(p).eq.18)then
+            !Allen et al (2020) values 
+             kc_active(p,istp)   = 0.25_r8/10._r8
+             kn_active(p,istp)   = 0.50_r8/10._r8
+             !CLM5 values 
+             !kc_active(p,istp)   = 0.6_r8
+             !kn_active(p,istp)   = 1.2_r8
+           else  
+             !Allen et al (2020) values 
+             kc_active(p,istp)   = 0.025_r8
+             kn_active(p,istp)   = 0.050_r8
+             !CLM5 values 
+             !kc_active(p,istp)   = 0.06_r8
+             !kn_active(p,istp)   = 0.12_r8
+           end if
+
+         if(use_funp)then
+           if(ivt(p).eq. 3.or. ivt(p).eq.6)then 
+              kcp_active(p,istp)  = (0.5_r8/10._r8)/scalex
+              kp_active(p,istp)   = (0.1_r8/10._r8)/scalex
+           else if(ivt(p).eq.14 .or. ivt(p).eq.17 .or. ivt(p).eq.18)then
+              kcp_active(p,istp)  = (0.5_r8*1._r8)/scalex
+              kp_active(p,istp)   = (0.1_r8*1._r8)/scalex
+           else
+              !kcp_active(p,istp)  = akcp_active(ivt(p))
+              !kp_active(p,istp)   = akp_active(ivt(p))
+              kcp_active(p,istp)  = (0.5_r8)/scalex
+              kp_active(p,istp)   =  (0.1_r8)/scalex
+           end if
+        end if
+       end if
+
+
+        if(leafc(p)>0.0_r8)then
+           ! N available in leaf which fell off in this timestep. Same fraction loss as C.    
+           litterfall_c_step(p,istp)         =   dt * permyc(p,istp) * leafc_to_litter_fun(p) 
+           litterfall_n_step(p,istp)         =   dt * permyc(p,istp) * leafn(p) * leafc_to_litter_fun(p)/leafc(p)
+           if (use_funp) then
+              litterfall_c_step_p(p,istp)         =   dt * permyc(p,istp) * leafc_to_litter_funp(p)
+              litterfall_p_step(p,istp)         =   dt * permyc(p,istp) * leafp(p) * leafc_to_litter_funp(p)/leafc(p)
+           endif 
+        endif 
+
+        if (season_decid(ivt(p)) == 1._r8.or.stress_decid(ivt(p)) == 1._r8) then
+          if (offset_flag(p) .ne. 1._r8) then
+            litterfall_n_step(p,istp) = 0.0_r8      
+            litterfall_c_step(p,istp) = 0.0_r8 
+            if(use_funp)then
+              litterfall_c_step_p(p,istp) = 0.0_r8
+              litterfall_p_step(p,istp) = 0.0_r8 
+            endif  
+          endif
+        endif
+
+     end do
+  end do     
+      
+  do j = 1, nlevdecomp
+     do fp = 1,num_soilp        ! PFT Starts
+       p = filter_soilp(fp)
+       c = veg_pp%column(p)
+       sminn_no3_layer(c,j)= smin_no3_to_plant_vr(c,j) * dzsoi_decomp(j) * dt
+       sminn_nh4_layer(c,j)= smin_nh4_to_plant_vr(c,j) * dzsoi_decomp(j) * dt
+       if(use_funp)then
+          sminp_pox_layer(c,j)= sminp_to_plant_vr(c,j) * dzsoi_decomp(j) * dt 
+       end if 
+       if (h2osoi_liq(c,j) < smallValue) then
+          sminn_no3_layer(c,j) = 0._r8
+          sminn_nh4_layer(c,j) = 0._r8
+       if(use_funp)then
+          sminp_pox_layer(c,j) = 0._r8 
+       end if
+       end if
+       sminn_no3_layer(c,j)    = max(sminn_no3_layer(c,j),0._r8)
+       sminn_nh4_layer(c,j)    = max(sminn_nh4_layer(c,j),0._r8)
+       if(use_funp)then
+          sminp_pox_layer(c,j)    = max(sminp_pox_layer(c,j),0._r8) 
+       end if
+       if (h2osoi_liq(c,j) > smallValue) then
+          sminn_no3_conc(c,j)  = sminn_no3_layer(c,j) / (h2osoi_liq(c,j) * 1000._r8) ! (gN/m2)/(gH2O/m2) (coverted from
+          !  kg2g)
+          sminn_nh4_conc(c,j)  = sminn_nh4_layer(c,j) / (h2osoi_liq(c,j) * 1000._r8) ! (gN/m2)/(gH2O/m2) (coverted from
+          !  kg2g)
+       if(use_funp)then
+          sminp_pox_conc(c,j)  = sminp_pox_layer(c,j) / (h2osoi_liq(c,j) * 1000._r8) ! (gP/m2)/(gH2O/m2) (coverted from
+          !  kg2g)
+       end if
+
+       else
+          sminn_no3_conc(c,j)  = 0._r8
+          sminn_nh4_conc(c,j)  = 0._r8
+       if(use_funp)then
+          sminp_pox_conc(c,j)  = 0._r8
+       end if
+
+       end if
+     end do
+  end do
+
+  do istp = 1, nstp
+     do j = 1, nlevdecomp
+        do fp = 1,num_soilp        ! PFT Starts
+           p = filter_soilp(fp)
+           c = veg_pp%column(p)
+
+           sminn_no3_layer_step(p,j,istp)  =   sminn_no3_layer(c,j) * permyc(p,istp)
+           sminn_nh4_layer_step(p,j,istp)  =   sminn_nh4_layer(c,j) * permyc(p,istp)
+           sminn_no3_conc_step(p,j,istp)   =   sminn_no3_conc(c,j)  * permyc(p,istp)
+           sminn_nh4_conc_step(p,j,istp)   =   sminn_nh4_conc(c,j)  * permyc(p,istp)
+
+       if(use_funp)then
+          sminp_pox_layer_step(p,j,istp)  =   sminp_pox_layer(c,j) * permyc(p,istp)
+          sminp_pox_conc_step(p,j,istp)   =   sminp_pox_conc(c,j)  * permyc(p,istp)
+       end if
+        end do
+     end do
+  end do
+  call t_stopf('CNFUNcalcs1')
+
+  call t_startf('CNFUNzeroarrays2')
+  do fp = 1,num_soilp        ! PFT Starts
+     p = filter_soilp(fp)
+     n_passive_acc(p)                = 0._r8
+     n_fix_acc_total(p)              = 0._r8
+     n_retrans_acc_total(p)          = 0._r8
+     npp_fix_acc_total(p)            = 0._r8
+     n_nonmyc_no3_retrans_total(p)   = 0._r8
+     n_nonmyc_nh4_retrans_total(p)   = 0._r8
+     npp_retrans_acc_total(p)        = 0._r8
+     n_am_no3_acc(p)                 = 0._r8
+     n_am_nh4_acc(p)                 = 0._r8
+     n_am_no3_retrans(p)             = 0._r8
+     n_am_nh4_retrans(p)             = 0._r8
+     n_ecm_no3_acc(p)                = 0._r8
+     n_ecm_nh4_acc(p)                = 0._r8
+     n_ecm_no3_retrans(p)            = 0._r8
+     n_ecm_nh4_retrans(p)            = 0._r8
+     n_active_no3_acc_total(p)       = 0._r8 
+     n_active_nh4_acc_total(p)       = 0._r8
+     n_active_no3_retrans_total(p)   = 0._r8 
+     n_active_nh4_retrans_total(p)   = 0._r8
+     n_nonmyc_no3_acc_total(p)       = 0._r8
+     n_nonmyc_nh4_acc_total(p)       = 0._r8
+     npp_active_no3_acc_total(p)     = 0._r8
+     npp_active_nh4_acc_total(p)     = 0._r8
+     npp_active_no3_retrans_total(p) = 0._r8
+     npp_active_nh4_retrans_total(p) = 0._r8
+     npp_nonmyc_no3_acc_total(p)     = 0._r8
+     npp_nonmyc_nh4_acc_total(p)     = 0._r8
+     npp_nonmyc_no3_retrans_total(p) = 0._r8
+     npp_nonmyc_nh4_retrans_total(p) = 0._r8
+     free_Nretrans(p)                = 0._r8
+
+     if(use_funp)then
+       p_passive_acc(p)                = 0._r8
+       p_retrans_acc_total(p)          = 0._r8
+       p_nonmyc_pox_retrans_total(p)   = 0._r8
+       npp_retrans_p_acc_total(p)      = 0._r8
+       p_am_pox_acc(p)                 = 0._r8
+       p_am_pox_retrans(p)             = 0._r8
+       p_ecm_pox_acc(p)                = 0._r8
+       p_ecm_pox_retrans(p)            = 0._r8
+       p_active_pox_acc_total(p)       = 0._r8 
+       p_active_pox_retrans_total(p)   = 0._r8 
+       p_nonmyc_pox_acc_total(p)       = 0._r8
+       npp_active_pox_acc_total(p)     = 0._r8
+       npp_active_pox_retrans_total(p) = 0._r8
+       npp_nonmyc_pox_acc_total(p)     = 0._r8
+       npp_nonmyc_pox_retrans_total(p) = 0._r8
+       free_Pretrans(p)                = 0._r8
+     end if
+  end do
+
+  do j = 1, nlevdecomp
+     do fp = 1,num_soilp        ! PFT Starts
+        p = filter_soilp(fp)
+        n_passive_no3_vr(p,j)           = 0._r8
+        n_passive_nh4_vr(p,j)           = 0._r8
+        n_active_no3_vr(p,j)            = 0._r8
+        n_nonmyc_no3_vr(p,j)            = 0._r8
+        n_active_nh4_vr(p,j)            = 0._r8
+        n_nonmyc_nh4_vr(p,j)            = 0._r8
+
+        if(use_funp)then
+          p_passive_pox_vr(p,j)         = 0._r8
+          p_active_pox_vr(p,j)          = 0._r8
+          p_nonmyc_pox_vr(p,j)          = 0._r8
+        end if
+
+     end do
+  end do
+  do istp = 1, nstp
+     do fp = 1,num_soilp        ! PFT Starts
+        p = filter_soilp(fp)
+        n_passive_step(p,istp)          = 0._r8
+        n_fix_acc(p,istp)               = 0._r8
+        n_retrans_acc(p,istp)           = 0._r8
+        npp_fix_acc(p,istp)             = 0._r8
+        npp_retrans_acc(p,istp)         = 0._r8
+        n_active_no3_acc(p,istp)        = 0._r8   
+        n_active_nh4_acc(p,istp)        = 0._r8  
+        n_active_no3_retrans(p,istp)    = 0._r8
+        n_active_nh4_retrans(p,istp)    = 0._r8
+        n_nonmyc_no3_acc(p,istp)        = 0._r8  
+        n_nonmyc_nh4_acc(p,istp)        = 0._r8  
+        n_nonmyc_no3_retrans(p,istp)    = 0._r8
+        n_nonmyc_nh4_retrans(p,istp)    = 0._r8
+        npp_active_no3_acc(p,istp)      = 0._r8
+        npp_active_nh4_acc(p,istp)      = 0._r8
+        npp_active_no3_retrans(p,istp)  = 0._r8
+        npp_active_nh4_retrans(p,istp)  = 0._r8
+        npp_nonmyc_no3_acc(p,istp)      = 0._r8
+        npp_nonmyc_nh4_acc(p,istp)      = 0._r8
+        npp_nonmyc_no3_retrans(p,istp)  = 0._r8
+        npp_nonmyc_nh4_retrans(p,istp)  = 0._r8
+
+        if(use_funp)then
+          p_passive_step(p,istp)          = 0._r8
+          p_retrans_acc(p,istp)           = 0._r8
+          npp_retrans_p_acc(p,istp)       = 0._r8
+          p_active_pox_acc(p,istp)        = 0._r8    
+          p_active_pox_retrans(p,istp)    = 0._r8
+          p_nonmyc_pox_acc(p,istp)        = 0._r8    
+          p_nonmyc_pox_retrans(p,istp)    = 0._r8
+          npp_active_pox_acc(p,istp)      = 0._r8
+          npp_active_pox_retrans(p,istp)  = 0._r8
+          npp_nonmyc_pox_acc(p,istp)      = 0._r8
+          npp_nonmyc_pox_retrans(p,istp)  = 0._r8
+          burned_off_carbon_p             = 0._r8 
+        end if
+     end do
+  end do
+
+  burned_off_carbon               = 0._r8 
+  call t_stopf('CNFUNzeroarrays2')
+
+  call t_startf('CNFUNcalcs')
+
+pft:do fp = 1,num_soilp        ! PFT Starts
+      p = filter_soilp(fp)
+      c = veg_pp%column(p)
+      excess_carbon_acc              = 0.0_r8
+      burned_off_carbon              = 0.0_r8
+     
+      sminn_to_plant_fun_nh4_vr(p,:) = 0._r8
+      sminn_to_plant_fun_no3_vr(p,:) = 0._r8  
+
+      if(use_funp)then
+          excess_carbon_acc_p        = 0.0_r8
+          burned_off_carbon_p        = 0.0_r8
+          sminp_to_plant_fun_vr(p,:) = 0._r8
+      end if    
+     
+      ! I have turned off this r etranslocation functionality for now. To
+      !  be rolled back in to a new version later on once the rest of
+      !   th
+      ! mode is working OK. RF
+
+      if (season_decid(ivt(p)) == 1._r8.or.stress_decid(ivt(p)) == 1._r8) then
+         if (onset_flag(p) == 1._r8) then
+            leafc_storage_xfer_acc(p) = leafc_storage_xfer_acc(p) + leafc_storage_to_xfer(p) * dt
+            leafn_storage_xfer_acc(p) = leafn_storage_xfer_acc(p) + leafn_storage_to_xfer(p) * dt
+         if(use_funp)then
+          leafp_storage_xfer_acc(p) = leafp_storage_xfer_acc(p) + leafp_storage_to_xfer(p) * dt
+         end if 
+         end if
+         if (offset_flag(p) == 1._r8) then
+            storage_cdemand(p)        = leafc_storage(p)          / (ndays_off * steppday)
+            storage_ndemand(p)        = leafn_storage_xfer_acc(p) / (ndays_off * steppday)
+            storage_ndemand(p)        = max(storage_ndemand(p),0._r8)
+        if(use_funp)then
+          storage_pdemand(p)        = leafp_storage_xfer_acc(p) / (ndays_off * steppday)
+          storage_pdemand(p)        = max(storage_pdemand(p),0._r8)
+        end if
+
+         else
+            storage_cdemand(p)        = 0._r8    
+            storage_ndemand(p)        = 0._r8  
+        if(use_funp)then
+            storage_pdemand(p)        = 0._r8
+        end if 
+         end if
+      else
+          storage_cdemand(p)          = 0._r8
+          storage_ndemand(p)          = 0._r8 
+        if(use_funp)then
+            storage_pdemand(p)        = 0._r8
+        end if 
+      end if   ! end for deciduous
+
+     
+      !---------How much carbon is provided, to be used for either growth
+      ! or Nitrogen uptake?-------------------
+      if(use_funp)then
+      !availc_pool(p)            =  availc(p)        *  dt * (1._r8 - plantCN(p)/plantCP(p))
+      !availc_pool_p(p)          =  scale_availc * availc(p) *  dt * (plantCN(p)/plantCP(p)) 
+      availc_pool(p)            =  availc(p)        *  dt * (plant_ndemand(p)*plantCN(p)/(plant_ndemand(p)*plantCN(p) + plant_pdemand(p)*plantCP(p)))
+      availc_pool_p(p)          =  availc(p) *  dt * (plant_pdemand(p)*plantCP(p)/(plant_ndemand(p)*plantCN(p) + plant_pdemand(p)*plantCP(p)))
+       !write(iulog,*) 'N req =',100.0_r8*(plant_ndemand(p)*plantCN(p)/(plant_ndemand(p)*plantCN(p) + plant_pdemand(p)*plantCP(p))), &
+       !               'P req =',100.0_r8*(plant_pdemand(p)*plantCP(p)/(plant_ndemand(p)*plantCN(p) + plant_pdemand(p)*plantCP(p)))
+      else  
+      availc_pool(p)            =  availc(p)        *  dt 
+      end if
+
+      if(use_funp)then
+        !grperc_n(p) = grperc(ivt(p)) * (1._r8 - plantCN(p)/plantCP(p))
+        !grperc_p(p) = grperc(ivt(p)) * (plantCN(p)/plantCP(p))  
+        grperc_n(p) = grperc(ivt(p)) * (plant_ndemand(p)*plantCN(p)/(plant_ndemand(p)*plantCN(p) + plant_pdemand(p)*plantCP(p)))
+        grperc_p(p) = grperc(ivt(p)) * (plant_pdemand(p)*plantCP(p)/(plant_ndemand(p)*plantCN(p) + plant_pdemand(p)*plantCP(p)))  
+      else
+        grperc_n(p) = grperc(ivt(p)) 
+      end if  
+
+      if (availc_pool(p) > 0._r8) then
+         do j = 1, nlevdecomp
+            rootc_dens(p,j)     =  crootfr(p,j) * rootC(p)
+         end do
+      end if
+
+      plant_ndemand_pool(p)     =  plant_ndemand(p) *  dt
+      plant_ndemand_pool(p)     =  max(plant_ndemand_pool(p),0._r8)
+      plant_ndemand_retrans(p)  =  storage_ndemand(p)
+
+      if(use_funp)then
+         plant_pdemand_pool(p)     =  plant_pdemand(p) *  dt
+         plant_pdemand_pool(p)     =  max(plant_pdemand_pool(p),0._r8)
+         plant_pdemand_retrans(p)  =  storage_pdemand(p)
+      end if 
+
+      !--------------------------------------------------------------------
+      !----------
+stp:  do istp = ecm_step, am_step        ! TWO STEPS
+         retrans_limit1              = 0._r8
+         dn                          = 0._r8
+         dnpp                        = 0._r8
+      
+         ! zero out all of the fluxes that get accumulated accross ISTP 
+         sminn_no3_diff              = 0._r8
+         sminn_nh4_diff              = 0._r8
+         active_no3_limit1           = 0._r8
+         active_nh4_limit1           = 0._r8
+
+         
+         n_from_active_no3(:)        = 0.0_r8
+         n_from_active_nh4(:)        = 0.0_r8
+         n_from_nonmyc_no3(:)        = 0.0_r8
+         n_from_nonmyc_nh4(:)        = 0.0_r8
+         n_from_fixation(:)          = 0.0_r8
+         n_from_retrans(:)           = 0.0_r8
+         
+         n_active_no3_acc(p,istp)    = 0.0_r8
+         n_active_nh4_acc(p,istp)    = 0.0_r8
+         n_nonmyc_no3_acc(p,istp)    = 0.0_r8
+         n_nonmyc_nh4_acc(p,istp)    = 0.0_r8
+         n_fix_acc(p,istp)           = 0.0_r8
+         n_retrans_acc(p,istp)       = 0.0_r8
+         free_nretrans_acc(p,istp)   = 0.0_r8
+ 
+         npp_active_no3_acc(p,istp)  = 0.0_r8
+         npp_active_nh4_acc(p,istp)  = 0.0_r8
+         npp_nonmyc_no3_acc(p,istp)  = 0.0_r8
+         npp_nonmyc_no3_acc(p,istp)  = 0.0_r8
+         npp_fix_acc(p,istp)         = 0.0_r8
+         npp_retrans_acc(p,istp)     = 0.0_r8
+         
+         npp_to_active_no3(:)        = 0.0_r8
+         npp_to_active_nh4(:)        = 0.0_r8
+         npp_to_nonmyc_no3(:)        = 0.0_r8
+         npp_to_nonmyc_nh4(:)        = 0.0_r8
+         npp_to_fixation(:)          = 0.0_r8
+         npp_to_retrans(:)           = 0.0_r8
+     
+  
+      
+         unmetDemand              = .TRUE.
+         plant_ndemand_pool_step(p,istp)   = plant_ndemand_pool(p)    * permyc(p,istp) 
+        
+         npp_remaining(p,istp)             = availc_pool(p)           * permyc(p,istp)  
+
+    
+    !write(iulog,*) 'Fixer fraction', FUN_fracfixers(ivt(p)), &
+    !                   'Soil N', smin_vr_no3(c,:)+smin_vr_nh4(c,:), &
+    !                          'Soil P', solutionp_vr(c,:), &
+    !                          'Fine Root Biomass', frootc(p), &
+    !                          'Frac Root nlevgrd', crootfr(p,:), &      
+    !                          'leaf N', leafn(p), &
+    !                          'leaf P', leafp(p), &
+    !                          'NPP0', availc(p), & !(?) 
+    !                          'plantcn', leafcn(ivt(p)), &
+    !                          'plantcp', leafcp(ivt(p)), &
+    !                          'plantnp', leafcp(ivt(p))/leafcn(ivt(p)), &
+    !                          'Soil water depth', h2osoi_liq(c,1), & 
+    !                          'Soil T', t_soisno(c,1), & 
+    !                          'ET', qflx_tran_veg(p), & !NaN
+    !                          'c3psn', veg_vp%c3psn, &
+    !                          'ivt(p)', ivt(p), &
+    !                         'perECM', perecm(ivt(p))
+         
+  
+         ! if (plant_ndemand_pool_step(p,istp) .gt. 0._r8) then   !
+            !  plant_ndemand_pool_step > 0.0
+            
+            do j = 1, nlevdecomp
+               tc_soisno(c,j)          = t_soisno(c,j)  -   tfrz
+               if(veg_vp%c3psn(veg_pp%itype(p)).eq.1)then
+                 fixer=1
+               else
+                 fixer=0
+               endif
+               costNit(j,icostFix)     = fun_cost_fix(fixer,a_fix(ivt(p)),b_fix(ivt(p))&
+               ,c_fix(ivt(p)) ,big_cost,crootfr(p,j),s_fix(ivt(p)),tc_soisno(c,j))
+            end do
+            cost_fix(p,1:nlevdecomp)      = costNit(:,icostFix)
+
+         if(use_funp)then
+         retrans_limit2              = 0._r8
+         dp                          = 0._r8
+         dnpp_p                      = 0._r8
+      
+         ! zero out all of the fluxes that get accumulated accross ISTP 
+         sminp_pox_diff              = 0._r8
+         active_pox_limit2           = 0._r8
+         
+         p_from_active_pox(:)        = 0.0_r8
+         p_from_nonmyc_pox(:)        = 0.0_r8
+         p_from_retrans(:)           = 0.0_r8
+         
+         p_active_pox_acc(p,istp)    = 0.0_r8
+         p_nonmyc_pox_acc(p,istp)    = 0.0_r8
+         p_retrans_acc(p,istp)       = 0.0_r8
+         free_pretrans_acc(p,istp)   = 0.0_r8
+ 
+         npp_active_pox_acc(p,istp)  = 0.0_r8
+         npp_nonmyc_pox_acc(p,istp)  = 0.0_r8
+         npp_retrans_p_acc(p,istp)   = 0.0_r8
+         
+         npp_to_active_pox(:)        = 0.0_r8
+         npp_to_nonmyc_pox(:)        = 0.0_r8
+         npp_to_retrans_p(:)         = 0.0_r8
+     
+  
+      
+         unmetDemandP              = .TRUE.
+         plant_pdemand_pool_step(p,istp)   = plant_pdemand_pool(p)    * permyc(p,istp) 
+         npp_remaining_p(p,istp)           = availc_pool_p(p)         * permyc(p,istp) 
+         end if
+            
+             
+            !--------------------------------------------------------------------
+            !------------
+            !         If passive uptake is insufficient, consider fixation,
+            !          mycorrhizal 
+            !         non-mycorrhizal, storage, and retranslocation.
+            !--------------------------------------------------------------------
+            !------------
+            !--------------------------------------------------------------------
+            !------------
+            !          Costs of active uptake.
+            !--------------------------------------------------------------------
+            !------------
+            !------Mycorrhizal Uptake Cost-----------------!
+            do j = 1,nlevdecomp
+               rootc_dens_step            = rootc_dens(p,j) *  permyc(p,istp)
+               costNit(j,icostActiveNO3)  = fun_cost_active(sminn_no3_layer_step(p,j,istp) &
+               ,big_cost,kc_active(p,istp),kn_active(p,istp) ,rootc_dens_step,crootfr(p,j),smallValue)
+               costNit(j,icostActiveNH4)  = fun_cost_active(sminn_nh4_layer_step(p,j,istp) &
+               ,big_cost,kc_active(p,istp),kn_active(p,istp) ,rootc_dens_step,crootfr(p,j),smallValue)
+               if(use_funp)then
+                  costPho(j,icostActivePOX)  = fun_cost_active(sminp_pox_layer_step(p,j,istp) &
+               ,big_cost,kcp_active(p,istp),kp_active(p,istp) ,rootc_dens_step,crootfr(p,j),smallValue)
+               end if            
+
+            end do
+            cost_active_no3(p,1:nlevdecomp)  = costNit(:,icostActiveNO3) 
+            cost_active_nh4(p,1:nlevdecomp)  = costNit(:,icostActiveNH4)
+            if(use_funp)then
+               cost_active_pox(p,1:nlevdecomp)  = costPho(:,icostActivePOX)
+            end if  
+            
+
+            !------Non-mycorrhizal Uptake Cost-------------!
+            do j = 1,nlevdecomp
+               rootc_dens_step             = rootc_dens(p,j)  *  permyc(p,istp)
+ 
+           if(ivt(p).eq.6)then 
+             !Allen et al (2020) values 
+             kc_nonmyc(ivt(p))   = 0.15_r8/10._r8
+             kn_nonmyc(ivt(p))   = 0.15_r8/10._r8 
+            !CLM5 values 
+             !kc_nonmyc(ivt(p))   = 0.072_r8
+             !kn_nonmyc(ivt(p))   = 0.0012_r8
+           else if(ivt(p).eq.3)then
+             !Allen et al (2020) values 
+             kc_nonmyc(ivt(p))   = 0.15_r8
+             kn_nonmyc(ivt(p))   = 0.15_r8/10._r8 
+            !CLM5 values 
+             !kc_nonmyc(ivt(p))   = 0.72_r8
+             !kn_nonmyc(ivt(p))   = 0.0012_r8
+           else if(ivt(p).eq.14 .or. ivt(p).eq.17 .or. ivt(p).eq.18)then
+             !Allen et al (2020) values 
+             kc_nonmyc(ivt(p))   = 0.15_r8*1._r8
+             kn_nonmyc(ivt(p))   = 0.15_r8*1._r8
+             !CLM5 values 
+             !kc_nonmyc(ivt(p))   = 7.2_r8
+             !kn_nonmyc(ivt(p))   = 0.12_r8
+           else  
+             !Allen et al (2020) values
+             kc_nonmyc(ivt(p))   = 0.15_r8
+             kn_nonmyc(ivt(p))   = 0.15_r8 
+             !kc_nonmyc(ivt(p))   = 0.01_r8
+             !kn_nonmyc(ivt(p))   = 0.90_r8
+             !CLM5 values 
+             !kc_nonmyc(p,istp)   = 0.72_r8
+             !kn_nonmyc(p,istp)   = 0.012_r8
+           end if
+
+               costNit(j,icostnonmyc_no3)   = fun_cost_nonmyc(sminn_no3_layer_step(p,j,istp) &
+               ,big_cost,kc_nonmyc(ivt(p)),kn_nonmyc(ivt(p)),rootc_dens_step,crootfr(p,j),smallValue)
+               costNit(j,icostnonmyc_nh4)   = fun_cost_nonmyc(sminn_nh4_layer_step(p,j,istp) &
+               ,big_cost,kc_nonmyc(ivt(p)),kn_nonmyc(ivt(p)),rootc_dens_step,crootfr(p,j),smallValue)
+
+          if(use_funp)then
+           if(ivt(p).eq.6)then 
+             kcp_nonmyc(ivt(p))  = (0.03_r8/10._r8)/scalex
+             kp_nonmyc(ivt(p))   = (0.08_r8/10._r8)/scalex
+           else if(ivt(p).eq.3)then
+             kcp_nonmyc(ivt(p))  = (0.03_r8)/scalex
+             kp_nonmyc(ivt(p))   = (0.08_r8/10._r8)/scalex
+           else if(ivt(p).eq.14 .or. ivt(p).eq.17 .or. ivt(p).eq.18)then
+             kcp_nonmyc(ivt(p))  = (0.03_r8*1._r8)/scalex
+             kp_nonmyc(ivt(p))   = (0.08_r8*1._r8)/scalex
+           else  
+             !Allen et al (2020) values 
+             kcp_nonmyc(ivt(p))  = (0.03_r8)/scalex
+             kp_nonmyc(ivt(p))   = (0.08_r8)/scalex
+           end if
+   
+                costPho(j,icostnonmyc_pox)  = fun_cost_nonmyc(sminp_pox_layer_step(p,j,istp) &
+               ,big_cost,kcp_nonmyc(ivt(p)),kp_nonmyc(ivt(p)) ,rootc_dens_step,crootfr(p,j),smallValue)
+              end if   
+           end do
+
+            cost_nonmyc_no3(p,1:nlevdecomp)   = costNit(:,icostnonmyc_no3)
+            cost_nonmyc_nh4(p,1:nlevdecomp)   = costNit(:,icostnonmyc_nh4)
+            if(use_funp)then
+              cost_nonmyc_pox(p,1:nlevdecomp)   = costPho(:,icostnonmyc_pox)
+            end if  
+
+            ! Remove C required to pair with N from passive uptake
+            !  from the available pool. 
+            npp_remaining(p,istp)  =   npp_remaining(p,istp) - n_passive_step(p,istp)*plantCN(p)
+
+            if(use_funp)then
+            ! Remove C required to pair with P from passive uptake
+            !  from the available pool and the one used to acquire N
+              npp_remaining_p(p,istp)  =   npp_remaining_p(p,istp) - p_passive_step(p,istp)*plantCP(p) 
+            end if
+
+
+              
+fix_loop:   do FIX =plants_are_fixing, plants_not_fixing !loop around percentages of fixers and non
+               ! fixers, with differnt costs. 
+
+        !FUN_fracfixers = (/0.25_r8, 0.25_r8, 0.25_r8, 0.25_r8, &
+        !                   0.25_r8, 0.25_r8, 0.25_r8, 0.25_r8, 0.25_r8, & 
+        !                   0.25_r8, 0.25_r8, 0.25_r8, 0.25_r8, 0.25_r8, &
+        !                   0.0_r8, 0.0_r8, 0.0_r8, 0.0_r8, 0.0_r8, &
+        !                   0.0_r8, 0.0_r8, 0.0_r8, 1.0_r8, 1.0_r8, 1.0_r8/)
+
+       if(ivt(p).eq.0)then
+         FUN_fracfixers(ivt(p)) = 1.0_r8
+       else if(ivt(p).le.14 )then
+         FUN_fracfixers(ivt(p)) = 0.25_r8
+       else if(ivt(p).ge.23)then
+         FUN_fracfixers(ivt(p)) = 1.0_r8
+       else
+         FUN_fracfixers(ivt(p)) = 0.0_r8
+       end if
+
+           !write(iulog,*) 'ivt(p)', ivt(p), &
+           !       'FUN_fracfixers(ivt(p))',FUN_fracfixers(ivt(p))
+
+
+               if(FIX==plants_are_fixing)then ! How much of the carbon in this PFT can in principle be used for fixation? 
+                 ! This is analagous to fixing the % of fixers for a given PFT - may not be realistic in the long run
+                 ! but prevents wholesale switching to fixer dominance during e.g. CO2 fertilization.  
+                 fixerfrac = FUN_fracfixers(ivt(p))
+                 fixerfrac_p = 0.0_r8
+               else
+                 fixerfrac = 1.0_r8 - FUN_fracfixers(ivt(p))
+                 fixerfrac_p = 1.0_r8
+               endif 
+               npp_to_spend = npp_remaining(p,istp)  * fixerfrac !put parameter here.
+
+
+
+               n_from_active_no3(1:nlevdecomp) = 0._r8
+               n_from_active_nh4(1:nlevdecomp) = 0._r8
+               n_from_nonmyc_no3(1:nlevdecomp) = 0._r8
+               n_from_nonmyc_nh4(1:nlevdecomp) = 0._r8
+
+            if(use_funp)then
+               npp_to_spend_p = npp_remaining_p(p,istp)  * fixerfrac_p !put ??? parameter here.
+               p_from_active_pox(1:nlevdecomp) = 0._r8
+               p_from_nonmyc_pox(1:nlevdecomp) = 0._r8
+            end if
+
+               !--------------------------------------------------------------------
+               !-----------
+               !           Calculate Integrated Resistance OF WHOLE SOIL COLUMN
+               !--------------------------------------------------------------------
+               !----------- 
+
+               sum_n_acquired      = 0.0_r8
+               total_N_conductance = 0.0_r8
+            if(use_funp)then
+               sum_p_acquired      = 0.0_r8
+               total_P_conductance = 0.0_r8
+            end if
+
+               do j = 1, nlevdecomp
+                  !----------!
+                  ! Method changed from FUN-resistors method to a method which 
+                  ! allocates fluxs based on conductance. rosief
+                  !----------!
+             
+                  ! Sum the conductances             
+                  total_N_conductance  = total_N_conductance + 1._r8/ &
+                                         cost_active_no3(p,j) + 1._r8/cost_active_nh4(p,j) &
+                                         + 1._r8/cost_nonmyc_no3(p,j)      &
+                                         + 1._r8/cost_nonmyc_nh4(p,j) 
+            if(use_funp)then
+               total_P_conductance  = total_P_conductance + 1._r8/ &
+                                         cost_active_pox(p,j) &
+                                       + 1._r8/cost_nonmyc_pox(p,j)
+            end if
+
+                  if(FIX==plants_are_fixing)then
+                      total_N_conductance  = total_N_conductance  + 1.0_r8 * 1._r8/cost_fix(p,j)
+                  end if 
+                      
+                end do 
+             
+                do j = 1, nlevdecomp     
+                  ! Calculate npp allocation to pathways proportional to their exchange rate (N/C) 
+                
+                  npp_frac_to_active_nh4(j) = (1._r8/cost_active_nh4(p,j)) / total_N_conductance
+                  npp_frac_to_nonmyc_nh4(j) = (1._r8/cost_nonmyc_nh4(p,j)) / total_N_conductance
+                  npp_frac_to_active_no3(j) = (1._r8/cost_active_no3(p,j)) / total_N_conductance
+                  npp_frac_to_nonmyc_no3(j) = (1._r8/cost_nonmyc_no3(p,j)) / total_N_conductance
+                  if(use_funp)then
+                     npp_frac_to_active_pox(j) = (1._r8/cost_active_pox(p,j)) / total_P_conductance
+                     npp_frac_to_nonmyc_pox(j) = (1._r8/cost_nonmyc_pox(p,j)) / total_P_conductance
+                  end if
+
+                  if(FIX==plants_are_fixing)then
+                    npp_frac_to_fixation(j)   = (1.0_r8 * 1._r8/cost_fix(p,j)) / total_N_conductance
+                  else
+                    npp_frac_to_fixation(j)   = 0.0_r8 
+                  end if
+                     
+                  ! Calculate hypothetical N uptake from each source   
+                  if(FIX==plants_are_fixing)then
+                    n_exch_fixation(j)   = npp_frac_to_fixation(j)   / cost_fix(p,j)
+                  else
+                    n_exch_fixation(j)   = 0.0_r8 
+                  end if                   
+              
+                  n_exch_active_nh4(j) = npp_frac_to_active_nh4(j) / cost_active_nh4(p,j) 
+                  n_exch_nonmyc_nh4(j) = npp_frac_to_nonmyc_nh4(j) / cost_nonmyc_nh4(p,j) 
+                  n_exch_active_no3(j) = npp_frac_to_active_no3(j) / cost_active_no3(p,j) 
+                  n_exch_nonmyc_no3(j) = npp_frac_to_nonmyc_no3(j) / cost_nonmyc_no3(p,j) 
+
+                  if(use_funp)then
+                     p_exch_active_pox(j) = npp_frac_to_active_pox(j) / cost_active_pox(p,j) 
+                     p_exch_nonmyc_pox(j) = npp_frac_to_nonmyc_pox(j) / cost_nonmyc_pox(p,j) 
+                  end if
+               
+                  ! Total N aquired from one unit of carbon  (N/C)
+                  sum_n_acquired        =  sum_n_acquired  + n_exch_active_nh4(j) +&
+                                        n_exch_nonmyc_nh4(j)+ n_exch_active_no3(j) + n_exch_nonmyc_no3(j)
+
+                  if(use_funp)then
+                  ! Total P aquired from one unit of carbon  (P/C)
+                  sum_p_acquired        =  sum_p_acquired  + p_exch_active_pox(j) +&
+                                        p_exch_nonmyc_pox(j)
+                  end if
+                                          
+                  if(FIX==plants_are_fixing)then
+                    sum_n_acquired= sum_n_acquired +  n_exch_fixation(j)
+                  end if 
+                                                                           
+               end do !nlevdecomp
+            
+               total_N_resistance = 1.0_r8/sum_n_acquired
+               if(use_funp)then
+                  total_P_resistance = 1.0_r8/sum_p_acquired 
+               end if
+
+               !-------------------------------------------------------------------------------
+               !           Calculate appropriate degree of retranslocation
+               !-------------------------------------------------------------------------------
+      
+               if(leafc(p).gt.0.0_r8.and.litterfall_n_step(p,istp)* fixerfrac>0.0_r8.and.ivt(p) <npcropmin)then
+                  call fun_retranslocation(p,dt,npp_to_spend,&
+                                litterfall_c_step(p,istp)* fixerfrac,&
+                                litterfall_n_step(p,istp)* fixerfrac,&
+                                total_n_resistance, total_c_spent_retrans,total_c_accounted_retrans, &
+                                free_n_retrans,paid_for_n_retrans, leafcn(ivt(p)), & 
+                                grperc_n(p), plantCN(p))
+
+              
+                                 
+               else
+                   total_c_accounted_retrans = 0.0_r8
+                   total_c_spent_retrans     = 0.0_r8
+                   total_c_accounted_retrans = 0.0_r8
+                   paid_for_n_retrans        = 0.0_r8
+                   free_n_retrans            = 0.0_r8
+
+               endif
+   
+        if(use_funp)then    
+               if(leafc(p).gt.0.0_r8.and.litterfall_p_step(p,istp)* fixerfrac_p>0.0_r8.and.ivt(p) <npcropmin)then
+
+   
+                !call fun_retranslocation(p,dt,npp_to_spend_p,&
+                !                litterfall_c_step_p(p,istp)* fixerfrac_p,&
+                !                litterfall_p_step(p,istp)* fixerfrac_p,&
+                !                total_p_resistance, total_c_spent_retrans_p,total_c_accounted_retrans_p, &
+                !                free_p_retrans,paid_for_p_retrans, leafcp(ivt(p)), & 
+                !                grperc_p(p), plantCP(p))
+
+                !write(iulog,*) 'p=',p,&
+                !               'dt=',dt,&
+                !               'npp_to_spend_p=',npp_to_spend_p,&
+                !               'litterfall_c_step_p(p,istp)* fixerfrac_p=', litterfall_c_step_p(p,istp)* fixerfrac_p,&
+                !                'litterfall_p_step(p,istp)* fixerfrac_p=',litterfall_p_step(p,istp)* fixerfrac_p,&
+                !                'total_p_resistance=',total_p_resistance, &
+!'total_c_spent_retrans_p=',total_c_spent_retrans_p,&
+
+!'total_c_accounted_retrans_p=', total_c_accounted_retrans_p,&
+!                                'free_p_retrans=',free_p_retrans,&
+!'paid_for_p_retrans=',paid_for_p_retrans,&
+
+! 'leafcp(ivt(p))=',leafcp(ivt(p)), & 
+!                          'grperc(ivt(p))=',       grperc(ivt(p)),&
+! 'plantCP(p)=', plantCP(p)
+
+                 call fun_retranslocation_p(p,dt,npp_to_spend_p,&
+                                litterfall_c_step_p(p,istp)* fixerfrac_p,&
+                                litterfall_p_step(p,istp)* fixerfrac_p,&
+                                total_p_resistance, total_c_spent_retrans_p,total_c_accounted_retrans_p, &
+                                free_p_retrans,paid_for_p_retrans, leafcp(ivt(p)), & 
+                                grperc_p(p), plantCP(p),smallValue,big_cost)
+               
+                 else
+
+  
+                     total_c_accounted_retrans_p = 0.0_r8
+                     total_c_spent_retrans_p     = 0.0_r8
+                     total_c_accounted_retrans_p = 0.0_r8
+                     paid_for_p_retrans          = 0.0_r8
+                     free_p_retrans              = 0.0_r8
+                   end if
+          end if
+  
+               !---------- add retrans fluxes in to total budgets. --------
+               ! remove C from available pool, both directly spent and accounted for by N uptake
+               total_c_spent_retrans = max(total_c_spent_retrans,0.0_r8)       
+               total_c_accounted_retrans = max(total_c_accounted_retrans,0.0_r8)    
+               npp_to_spend  = npp_to_spend - total_c_spent_retrans - total_c_accounted_retrans
+
+               npp_to_spend = max(npp_to_spend,0.0_r8)  
+
+               npp_retrans_acc(p,istp) = npp_retrans_acc(p,istp) + total_c_spent_retrans 
+               ! add to to C spent pool    
+
+               paid_for_n_retrans = max(paid_for_n_retrans,0.0_r8)                            
+               n_retrans_acc(p,istp)     = n_retrans_acc(p,istp)     + paid_for_n_retrans
+               free_nretrans_acc(p,istp) = free_nretrans_acc(p,istp) + free_n_retrans
+               ! add N to the acquired from retrans pool 
+               if(use_funp)then
+               ! remove C from available pool, both directly spent and accounted for by P uptake
+                  total_c_spent_retrans_p = max(total_c_spent_retrans_p,0.0_r8)       
+                  total_c_accounted_retrans_p = max(total_c_accounted_retrans_p,0.0_r8)    
+
+                 npp_to_spend_p  = npp_to_spend_p - total_c_spent_retrans_p - total_c_accounted_retrans_p 
+
+                 npp_to_spend_p = max(npp_to_spend_p,0.0_r8)    
+
+
+                 npp_retrans_p_acc(p,istp) = npp_retrans_p_acc(p,istp) + total_c_spent_retrans_p 
+
+            
+               ! add to to C spent pool
+               
+                paid_for_p_retrans = max(paid_for_p_retrans,0.0_r8)          
+
+                 p_retrans_acc(p,istp)     = p_retrans_acc(p,istp)     + paid_for_p_retrans
+                 free_pretrans_acc(p,istp) = free_pretrans_acc(p,istp) + free_p_retrans
+               ! add P to the acquired from retrans pool 
+               end if
+  
+            
+               !-------------------------------------------------------------------------------
+               !           Spend C on extracting N.
+               !-------------------------------------------------------------------------------
+               if (plant_ndemand_pool_step(p,istp) .gt. 0._r8) then    ! unmet demand
+  
+                 !if(local_use_flexiblecn)then   !(Comment FlexCN bit)
+                 !    if (leafn(p) == 0.0_r8) then   ! to avoid division by zero
+                 !      delta_CN = fun_cn_flex_c(ivt(p))   ! Max CN ratio over standard
+                 !    else
+                 !      delta_CN = (leafc(p)+leafc_storage(p))/(leafn(p)+leafn_storage(p)) - leafcn(ivt(p)) ! leaf CN ratio                                                              
+                 !    end if
+                     ! C used for uptake is reduced if the cost of N is very high                
+                 !    frac_ideal_C_use = max(0.0_r8,1.0_r8 - (total_N_resistance-fun_cn_flex_a(ivt(p)))/fun_cn_flex_b(ivt(p)) )
+                     ! then, if the plant is very much in need of N, the C used for uptake is increased accordingly.                  
+                 !    if(delta_CN .gt.0.and. frac_ideal_C_use.lt.1.0)then           
+                 !      frac_ideal_C_use = frac_ideal_C_use + (1.0_r8-frac_ideal_C_use)*min(1.0_r8, delta_CN/fun_cn_flex_c(ivt(p)))
+                 !    end if    
+                     ! If we have too much N (e.g. from free N retranslocation) then make frac_ideal_c_use even lower.    
+                     ! For a CN delta of fun_cn_flex_c, then we reduce C expendiure to the minimum of 0.5. 
+                     ! This seems a little intense? 
+                 !    if(delta_CN.lt.0.0)then
+                 !       frac_ideal_C_use = frac_ideal_C_use + 0.5_r8*(1.0_r8*delta_CN/fun_cn_flex_c(ivt(p)))
+                 !    endif 
+                 !    frac_ideal_C_use = max(min(1.0_r8,frac_ideal_C_use),0.5_r8) 
+                     ! don't let this go above 1 or below an arbirtray minimum (to prevent zero N uptake). 
+                 !else
+                     frac_ideal_C_use= 1.0_r8
+                 !end if (Comment FlexCN bit)
+                 
+               
+                 excess_carbon = npp_to_spend * (1.0_r8-frac_ideal_c_use)
+                 if(excess_carbon*(1.0_r8+grperc_n(p)).gt.npp_to_spend)then !prevent negative dnpp
+                      excess_carbon =  npp_to_spend/(1.0_r8+grperc_n(p))
+                 endif
+                
+
+                 excess_carbon_acc             = excess_carbon_acc + excess_carbon
+
+                 ! spend less C than you have to to meet the target, thus allowing C:N ratios to rise. 
+                 npp_to_spend         = npp_to_spend - excess_carbon*(1.0_r8 + grperc_n(p))
+            
+                 ! This is the main equation of FUN, which figures out how much C to spend on uptake to remain at the target CN ratio. 
+                 ! nb. This term assumes that cost of N is constant through the timestep, because we don't have 
+                 ! a concept of Michealis Menten kinetics. 
+                 ! 
+                 !Calculate the hypothetical amount of NPP that we should use to extract N over whole profile
+                 !This calculation is based on the simulataneous solution of the uptake and extraction N balance. 
+                 !It satisfies the criteria (spentC+growthC=availC AND spentC/cost=growthC/plantCN
+                 !Had to add growth respiration here to balance carbon pool. 
+
+               
+                 dnpp  = npp_to_spend / ( (1.0_r8+grperc_n(p))*(plantCN(p) / total_N_resistance) + 1._r8)  
+                 dnpp  = dnpp * frac_ideal_C_use
+           
+                 !hypothetical amount of N acquired. 
+                 dn    = dnpp / total_N_resistance
+
+                 do j = 1,nlevdecomp
+                        
+                     ! RF How much of this NPP carbon do we allocate to the different pathways? fraction x gC/m2/s?
+                     ! Could this code now be put in a matrix? 
+
+                     npp_to_active_nh4(j) = npp_frac_to_active_nh4(j) * dNPP
+                     npp_to_nonmyc_nh4(j) = npp_frac_to_nonmyc_nh4(j) * dNPP
+                     npp_to_active_no3(j) = npp_frac_to_active_no3(j) * dNPP
+                     npp_to_nonmyc_no3(j) = npp_frac_to_nonmyc_no3(j) * dNPP 
+
+                  
+                     
+                     if(FIX==plants_are_fixing)then
+                       npp_to_fixation(j) = npp_frac_to_fixation(j) * dNPP
+                     else
+                       npp_to_fixation(j) = 0.0_r8
+                     end if    
+
+                     n_from_active_nh4(j) = npp_to_active_nh4(j)  / cost_active_nh4(p,j)
+                     n_from_nonmyc_nh4(j) = npp_to_nonmyc_nh4(j)  / cost_nonmyc_nh4(p,j)
+                     n_from_active_no3(j) = npp_to_active_no3(j)  / cost_active_no3(p,j)
+                     n_from_nonmyc_no3(j) = npp_to_nonmyc_no3(j)  / cost_nonmyc_no3(p,j)
+
+                   
+                
+                     if(FIX==plants_are_fixing)then
+                       n_from_fixation(j) = npp_to_fixation(j)    / cost_fix(p,j)
+                     else
+                       n_from_fixation(j) = 0.0_r8
+                     end if
+                                                                     
+                 end do
+              
+                 ! did we exceed the limits of uptake for any of these pools?
+                 do j = 1,nlevdecomp    
+                  
+                       ! --------------------ACTIVE UPTAKE NO3 UPTAKE LIMIT------------------------!  
+                       active_no3_limit1          = sminn_no3_layer_step(p,j,istp) * fixerfrac 
+                  
+                        ! trying to remove too much nh4 from soil. 
+                        if (n_from_active_no3(j) + n_from_nonmyc_no3(j).gt.active_no3_limit1) then 
+                           sminn_no3_diff          = n_from_active_no3(j) + n_from_nonmyc_no3(j) - active_no3_limit1
+                           temp_n_flux = n_from_active_no3(j)
+                           ! divide discrepancy between sources
+                           n_from_active_no3(j)     = n_from_active_no3(j) - sminn_no3_diff &
+                                                      * (n_from_active_no3(j) /(n_from_active_no3(j) + n_from_nonmyc_no3(j)))
+                           n_from_nonmyc_no3(j)     = n_from_nonmyc_no3(j) - sminn_no3_diff &
+                                                 * (n_from_nonmyc_no3(j) /(temp_n_flux + n_from_nonmyc_no3(j)))
+                           npp_to_active_no3(j)     = n_from_active_no3(j) * cost_active_no3(p,j) 
+                           npp_to_nonmyc_no3(j)     = n_from_nonmyc_no3(j) * cost_nonmyc_no3(p,j)
+                                      
+                       end if
+                  
+                       ! --------------------ACTIVE UPTAKE NH4 UPTAKE LIMIT------------------------!  
+                       active_nh4_limit1          = sminn_nh4_layer_step(p,j,istp) *fixerfrac
+                  
+                      
+                       ! trying to remove too much nh4 from soil. 
+                       if (n_from_active_nh4(j) + n_from_nonmyc_nh4(j).gt.active_nh4_limit1) then 
+                    
+                          sminn_nh4_diff          = n_from_active_nh4(j) + n_from_nonmyc_nh4(j) - active_nh4_limit1
+                          temp_n_flux = n_from_active_nh4(j)
+                          ! divide discrepancy between sources
+                          n_from_active_nh4(j)  = n_from_active_nh4(j)    - (sminn_nh4_diff &
+                                                   * n_from_active_nh4(j) /(n_from_active_nh4(j) + n_from_nonmyc_nh4(j)))
+                          n_from_nonmyc_nh4(j)  = n_from_nonmyc_nh4(j)    - (sminn_nh4_diff &
+                                                   * n_from_nonmyc_nh4(j) /(temp_n_flux+ n_from_nonmyc_nh4(j)))
+                          npp_to_active_nh4(j)  = n_from_active_nh4(j)    * cost_active_nh4(p,j) 
+                          npp_to_nonmyc_nh4(j)  = n_from_nonmyc_nh4(j)    * cost_nonmyc_nh4(p,j)    
+                                 
+                       end if
+
+                     
+                                                               
+                       ! How much N did we end up with
+                       N_acquired                    =  n_from_active_no3(j)+n_from_nonmyc_no3(j) &
+                                                       + n_from_active_nh4(j)+n_from_nonmyc_nh4(j)
+                  
+                  
+                       ! How much did it actually cost? 
+                       C_spent                       =   npp_to_active_no3(j)+npp_to_nonmyc_no3(j) &
+                                                       + npp_to_active_nh4(j)+npp_to_nonmyc_nh4(j)
+
+                      
+                                                  
+                       if(FIX==plants_are_fixing)then
+                          N_acquired = N_acquired + n_from_fixation(j)
+                          C_spent    = C_spent + npp_to_fixation(j) 
+                       end if
+                  
+                  
+
+                       ! How much C did we allocate or spend in this layer? 
+                       npp_to_spend                 = npp_to_spend   - C_spent - (N_acquired &
+                                                       * plantCN(p)*(1.0_r8+ grperc_n(p)))
+
+
+                      
+                  
+                       ! Accumulate those fluxes
+                       nt_uptake(p,istp)             = nt_uptake(p,istp)       + N_acquired
+                       npp_uptake(p,istp)            = npp_uptake(p,istp)      + C_spent
+                  
+                                 
+                  
+                                                                                 
+                       !-------------------- N flux accumulation------------!
+                       n_active_no3_acc(p,istp)      = n_active_no3_acc(p,istp) + n_from_active_no3(j)
+                       n_active_nh4_acc(p,istp)      = n_active_nh4_acc(p,istp) + n_from_active_nh4(j)
+                       n_nonmyc_no3_acc(p,istp)      = n_nonmyc_no3_acc(p,istp) + n_from_nonmyc_no3(j)
+                       n_nonmyc_nh4_acc(p,istp)      = n_nonmyc_nh4_acc(p,istp) + n_from_nonmyc_nh4(j)                 
+            
+                       !-------------------- C flux accumulation------------!
+                       npp_active_no3_acc(p,istp) = npp_active_no3_acc(p,istp)  + npp_to_active_no3(j)
+                       npp_active_nh4_acc(p,istp) = npp_active_nh4_acc(p,istp)  + npp_to_active_nh4(j)
+                       npp_nonmyc_no3_acc(p,istp) = npp_nonmyc_no3_acc(p,istp)  + npp_to_nonmyc_no3(j)
+                       npp_nonmyc_nh4_acc(p,istp) = npp_nonmyc_nh4_acc(p,istp)  + npp_to_nonmyc_nh4(j) 
+
+                                    
+                  
+                       if(FIX == plants_are_fixing)then
+                         n_fix_acc(p,istp)          = n_fix_acc(p,istp)         + n_from_fixation(j)
+                         npp_fix_acc(p,istp)        = npp_fix_acc(p,istp)       + npp_to_fixation(j)
+                       end if
+                  
+                 end do    ! j
+             
+             
+                 ! check that we get the right amount of N...
+             
+            
+             
+                 ! Occasionally, the algorithm will want to extract a high fraction of NPP from a pool (eg leaves) that                               
+                 ! quickly empties. One solution to this is to iterate round all the calculations starting from                                       
+                 ! the cost functions. The other is to burn off the extra carbon and hope this doesn't happen very often...                     
+
+                 if (npp_to_spend .ge. 1.e-13_r8)then
+                       burned_off_carbon =  burned_off_carbon + npp_to_spend
+                     !write(iulog,*) 'burned_off_carbon=', burned_off_carbon
+                 end if
+
+                 
+             
+                      
+                 ! add vertical fluxes to patch arrays 
+                 do j = 1,nlevdecomp
+                       n_active_no3_vr(p,j)      =  n_active_no3_vr(p,j)      + n_from_active_no3(j)
+                       n_active_nh4_vr(p,j)      =  n_active_nh4_vr(p,j)      + n_from_active_nh4(j)
+                       n_nonmyc_no3_vr(p,j)      =  n_nonmyc_no3_vr(p,j)      + n_from_nonmyc_no3(j)
+                       n_nonmyc_nh4_vr(p,j)      =  n_nonmyc_nh4_vr(p,j)      + n_from_nonmyc_nh4(j) 
+
+                     
+                 end do
+               end if !unmet demand`
+
+           if(use_funp)then
+              !-------------------------------------------------------------------------------
+               !           Spend C on extracting P.
+               !-------------------------------------------------------------------------------
+               if (plant_pdemand_pool_step(p,istp) .gt. 0._r8) then    ! unmet demand
+  
+                 !if(local_use_flexiblecn)then   !(Comment FlexCN bit)
+                 !    if (leafn(p) == 0.0_r8) then   ! to avoid division by zero
+                 !      delta_CN = fun_cn_flex_c(ivt(p))   ! Max CN ratio over standard
+                 !    else
+                 !      delta_CN = (leafc(p)+leafc_storage(p))/(leafn(p)+leafn_storage(p)) - leafcn(ivt(p)) ! leaf CN ratio                                                              
+                 !    end if
+                     ! C used for uptake is reduced if the cost of N is very high                
+                 !    frac_ideal_C_use = max(0.0_r8,1.0_r8 - (total_N_resistance-fun_cn_flex_a(ivt(p)))/fun_cn_flex_b(ivt(p)) )
+                     ! then, if the plant is very much in need of N, the C used for uptake is increased accordingly.                  
+                 !    if(delta_CN .gt.0.and. frac_ideal_C_use.lt.1.0)then           
+                 !      frac_ideal_C_use = frac_ideal_C_use + (1.0_r8-frac_ideal_C_use)*min(1.0_r8, delta_CN/fun_cn_flex_c(ivt(p)))
+                 !    end if    
+                     ! If we have too much N (e.g. from free N retranslocation) then make frac_ideal_c_use even lower.    
+                     ! For a CN delta of fun_cn_flex_c, then we reduce C expendiure to the minimum of 0.5. 
+                     ! This seems a little intense? 
+                 !    if(delta_CN.lt.0.0)then
+                 !       frac_ideal_C_use = frac_ideal_C_use + 0.5_r8*(1.0_r8*delta_CN/fun_cn_flex_c(ivt(p)))
+                 !    endif 
+                 !    frac_ideal_C_use = max(min(1.0_r8,frac_ideal_C_use),0.5_r8) 
+                     ! don't let this go above 1 or below an arbirtray minimum (to prevent zero N uptake). 
+                 !else
+                     frac_ideal_C_use= 1.0_r8
+                 !end if (Comment FlexCN bit)
+                 
+               
+              
+               
+                   
+                       !frac_ideal_C_use= 1.0_r8
+                       !end if (Comment FlexCN bit)
+               
+                       excess_carbon_p = npp_to_spend_p * (1.0_r8-frac_ideal_c_use)
+                       
+                       if (excess_carbon_p*(1.0_r8+grperc_p(p)) .gt. npp_to_spend_p) then !prevent negative dnpp
+                          excess_carbon_p =  npp_to_spend_p/(1.0_r8 + grperc_p(p))
+                       end if
+                   
+                
+                 !END Phosphorus
+
+              
+                 ! This is the main equation of FUN, which figures out how much C to spend on uptake to remain at the target CN ratio. 
+                 ! nb. This term assumes that cost of N is constant through the timestep, because we don't have 
+                 ! a concept of Michealis Menten kinetics. 
+                 ! 
+                 !Calculate the hypothetical amount of NPP that we should use to extract N over whole profile
+                 !This calculation is based on the simulataneous solution of the uptake and extrction N balance. 
+                 !It satisfies the criteria (spentC+growthC=availC AND spentC/cost=growthC/plantCN
+                 !Had to add growth respiration here to balance carbon pool. 
+
+         
+               
+                   excess_carbon_acc_p             = excess_carbon_acc_p + excess_carbon_p
+
+                   ! spend less C than you have to to meet the target, thus allowing C:P ratios to rise. 
+                   npp_to_spend_p         = npp_to_spend_p - excess_carbon_p*(1.0_r8+grperc_p(p))
+
+                   dnpp_p  = npp_to_spend_p / ( (1.0_r8+grperc_p(p))*(plantCP(p) / total_P_resistance) + 1._r8)  
+
+                   dnpp_p  = dnpp_p * frac_ideal_C_use
+                   
+           
+                   !hypothetical amount of P acquired. 
+                   dp    = dnpp_p / total_P_resistance
+                
+
+                 do j = 1,nlevdecomp
+                        
+                     ! RF How much of this NPP carbon do we allocate to the different pathways? fraction x gC/m2/s?
+                     ! Could this code now be put in a matrix? 
+
+                     
+
+                    
+                      npp_to_active_pox(j) = npp_frac_to_active_pox(j) * dnpp_p
+                      npp_to_nonmyc_pox(j) = npp_frac_to_nonmyc_pox(j) * dnpp_p
+                    
+                     
+                    
+       
+                   
+                      p_from_active_pox(j) = npp_to_active_pox(j)  / cost_active_pox(p,j)
+                      p_from_nonmyc_pox(j) = npp_to_nonmyc_pox(j)  / cost_nonmyc_pox(p,j)
+                    
+                
+                                                            
+                 end do
+              
+                 ! did we exceed the limits of uptake for any of these pools?
+                 do j = 1,nlevdecomp    
+                  
+                     
+                  
+                     
+                     
+                      
+! --------------------ACTIVE UPTAKE POX UPTAKE LIMIT------------------------!  
+                       active_pox_limit2          = sminp_pox_layer_step(p,j,istp) *fixerfrac_p
+                  
+                      
+                       ! trying to remove too much pox from soil. 
+                       if (p_from_active_pox(j) + p_from_nonmyc_pox(j).gt.active_pox_limit2) then 
+                    
+                          sminp_pox_diff          = p_from_active_pox(j) + p_from_nonmyc_pox(j) - active_pox_limit2
+                          temp_p_flux = p_from_active_pox(j)
+                          ! divide discrepancy between sources
+                          p_from_active_pox(j)  = p_from_active_pox(j)    - (sminp_pox_diff &
+                                                   * p_from_active_pox(j) /(p_from_active_pox(j) + p_from_nonmyc_pox(j)))
+                          p_from_nonmyc_pox(j)  = p_from_nonmyc_pox(j)    - (sminp_pox_diff &
+                                                   * p_from_nonmyc_pox(j) /(temp_p_flux+ p_from_nonmyc_pox(j)))
+                          npp_to_active_pox(j)  = p_from_active_pox(j)    * cost_active_pox(p,j) 
+                          npp_to_nonmyc_pox(j)  = p_from_nonmyc_pox(j)    * cost_nonmyc_pox(p,j)    
+                                 
+                       end if
+                      
+                                                               
+                      
+                  
+                     
+                       ! How much P did we end up with
+                       P_acquired                    =  p_from_active_pox(j)+p_from_nonmyc_pox(j) 
+                  
+                 
+                       ! How much did it actually cost? 
+                       C_spentP                       =   npp_to_active_pox(j)+ npp_to_nonmyc_pox(j) 
+
+   
+                       ! How much C did we allocate or spend in this layer? 
+                      
+                      
+                          npp_to_spend_p                 = npp_to_spend_p   - C_spentP - (P_acquired &
+                                                       * plantCP(p)*(1.0_r8+ grperc_p(p)))
+
+                     
+                         ! Accumulate those fluxes
+                         pt_uptake(p,istp)             = pt_uptake(p,istp)       + P_acquired
+                         npp_uptake_p(p,istp)            = npp_uptake_p(p,istp)      + C_spentP
+                                  
+                       
+                       !-------------------- P flux accumulation------------!
+                       p_active_pox_acc(p,istp)      = p_active_pox_acc(p,istp) + p_from_active_pox(j)
+                       p_nonmyc_pox_acc(p,istp)      = p_nonmyc_pox_acc(p,istp) + p_from_nonmyc_pox(j)
+                 
+            
+                       !-------------------- C flux accumulation------------!
+                       npp_active_pox_acc(p,istp) = npp_active_pox_acc(p,istp)  + npp_to_active_pox(j)
+                       npp_nonmyc_pox_acc(p,istp) = npp_nonmyc_pox_acc(p,istp)  + npp_to_nonmyc_pox(j)
+ 
+                                    
+                  
+                  
+                 end do    ! j
+             
+             
+                 ! check that we get the right amount of N...
+             
+            
+             
+                 ! Occasionally, the algorithm will want to extract a high fraction of NPP from a pool (eg leaves) that                               
+                 ! quickly empties. One solution to this is to iterate round all the calculations starting from                                       
+                 ! the cost functions. The other is to burn off the extra carbon and hope this doesn't happen very often...                     
+
+               
+
+                       
+                   if (npp_to_spend_p .ge. 1.e-13_r8)then
+                       burned_off_carbon_p =  burned_off_carbon_p + npp_to_spend_p
+                    !write(iulog,*) 'burned_off_carbon_P=', burned_off_carbon_p
+                   
+                 end if   
+             
+                      
+                 ! add vertical fluxes to patch arrays 
+                 do j = 1,nlevdecomp
+ 
+                         p_active_pox_vr(p,j)      =  p_active_pox_vr(p,j)      + p_from_active_pox(j)
+                         p_nonmyc_pox_vr(p,j)      =  p_nonmyc_pox_vr(p,j)      + p_from_nonmyc_pox(j) 
+                      
+                 end do
+               end if !unmet demand`
+             end if !FUNP
+            
+            end do fix_loop ! FIXER. 
+             
+            if (istp.eq.ecm_step) then
+               n_ecm_no3_acc(p)          =  n_active_no3_acc(p,istp)
+               n_ecm_nh4_acc(p)          =  n_active_nh4_acc(p,istp)
+               if(use_funp)then
+                 p_ecm_pox_acc(p)        =  p_active_pox_acc(p,istp)
+               end if
+            else
+               n_am_no3_acc(p)           =  n_active_no3_acc(p,istp)
+               n_am_nh4_acc(p)           =  n_active_nh4_acc(p,istp)
+               if(use_funp)then
+                 p_am_pox_acc(p)         =  p_active_pox_acc(p,istp)
+               end if
+            end if
+            
+            ! Accumulate total column N fluxes over istp
+            n_active_no3_acc_total(p)    =  n_active_no3_acc_total(p)    + n_active_no3_acc(p,istp)
+            n_active_nh4_acc_total(p)    =  n_active_nh4_acc_total(p)    + n_active_nh4_acc(p,istp)
+            n_nonmyc_no3_acc_total(p)    =  n_nonmyc_no3_acc_total(p)    + n_nonmyc_no3_acc(p,istp)
+            n_nonmyc_nh4_acc_total(p)    =  n_nonmyc_nh4_acc_total(p)    + n_nonmyc_nh4_acc(p,istp)
+            n_fix_acc_total(p)           =  n_fix_acc_total(p)           + n_fix_acc(p,istp)
+            n_retrans_acc_total(p)       =  n_retrans_acc_total(p)       + n_retrans_acc(p,istp)
+            free_nretrans(p)             =  free_nretrans(p)            + free_nretrans_acc(p,istp)
+      
+            ! Accumulate total column C fluxes over istp
+            npp_active_no3_acc_total(p)  =  npp_active_no3_acc_total(p)  + npp_active_no3_acc(p,istp)
+            npp_active_nh4_acc_total(p)  =  npp_active_nh4_acc_total(p)  + npp_active_nh4_acc(p,istp)
+            npp_nonmyc_no3_acc_total(p)  =  npp_nonmyc_no3_acc_total(p)  + npp_nonmyc_no3_acc(p,istp)
+            npp_nonmyc_nh4_acc_total(p)  =  npp_nonmyc_nh4_acc_total(p)  + npp_nonmyc_nh4_acc(p,istp)
+            npp_fix_acc_total(p)         =  npp_fix_acc_total(p)         + npp_fix_acc(p,istp)
+            npp_retrans_acc_total(p)     =  npp_retrans_acc_total(p)     + npp_retrans_acc(p,istp) 
+
+            if(use_funp)then
+              ! Accumulate total column P fluxes over istp
+              p_active_pox_acc_total(p)    =  p_active_pox_acc_total(p)    + p_active_pox_acc(p,istp)
+              p_nonmyc_pox_acc_total(p)    =  p_nonmyc_pox_acc_total(p)    + p_nonmyc_pox_acc(p,istp)
+              p_retrans_acc_total(p)       =  p_retrans_acc_total(p)       + p_retrans_acc(p,istp)
+              free_pretrans(p)             =  free_pretrans(p)            + free_pretrans_acc(p,istp)
+      
+              ! Accumulate total column C fluxes over istp
+              npp_active_pox_acc_total(p)  =  npp_active_pox_acc_total(p)  + npp_active_pox_acc(p,istp)
+              npp_nonmyc_pox_acc_total(p)  =  npp_nonmyc_pox_acc_total(p)  + npp_nonmyc_pox_acc(p,istp)
+              npp_retrans_p_acc_total(p)   =  npp_retrans_p_acc_total(p)     + npp_retrans_p_acc(p,istp) 
+            end if
+                   
+         !end if  ! plant_ndemand_pool_step > 0._r8
+      end do stp ! NSTEP 
+
+   
+      !-------------------------------------------------------------------------------
+      ! Turn step level quantities back into fluxes per second. 
+      !-------------------------------------------------------------------------------
+
+      !---------------------------N fluxes--------------------!
+      Npassive(p)               = n_passive_acc(p)/dt
+      Nfix(p)                   = n_fix_acc_total(p)/dt                   
+      retransn_to_npool(p)      = n_retrans_acc_total(p)/dt
+      free_retransn_to_npool(p) = free_nretrans(p)/dt
+      ! this is the N that comes off leaves. 
+      Nretrans(p)               = retransn_to_npool(p) + free_retransn_to_npool(p)
+
+      if(use_funp)then
+        !---------------------------P fluxes--------------------!
+        Ppassive(p)               = p_passive_acc(p)/dt                  
+        retransp_to_ppool(p)      = p_retrans_acc_total(p)/dt
+        free_retransp_to_ppool(p) = free_pretrans(p)/dt
+        ! this is the P that comes off leaves. 
+        Pretrans(p)               = retransp_to_ppool(p) + free_retransp_to_ppool(p)
+      end if
+      
+      
+      
+      
+      !Extract active uptake N from soil pools. 
+      do j = 1, nlevdecomp
+         !RF change. The N fixed doesn't actually come out of the soil mineral pools, it is 'new'... 
+         sminn_to_plant_fun_no3_vr(p,j)    = (n_passive_no3_vr(p,j)  + n_active_no3_vr(p,j) &
+                                             + n_nonmyc_no3_vr(p,j))/(dzsoi_decomp(j)*dt)
+         sminn_to_plant_fun_nh4_vr(p,j)    = (n_passive_nh4_vr(p,j)  + n_active_nh4_vr(p,j) &
+                                             + n_nonmyc_nh4_vr(p,j))/(dzsoi_decomp(j)*dt)
+
+      if(use_funp)then
+        sminp_to_plant_fun_vr(p,j)    = (p_passive_pox_vr(p,j)  + p_active_pox_vr(p,j) &
+                                             + p_nonmyc_pox_vr(p,j))/(dzsoi_decomp(j)*dt)
+         
+      end if
+         
+      end do
+      
+     
+      
+      Nactive_no3(p)            = n_active_no3_acc_total(p)/dt   + n_active_no3_retrans_total(p)/dt
+      Nactive_nh4(p)            = n_active_nh4_acc_total(p)/dt   + n_active_nh4_retrans_total(p)/dt  
+      
+      
+    
+      Necm_no3(p)               = n_ecm_no3_acc(p)/dt            + n_ecm_no3_retrans(p)/dt
+      Necm_nh4(p)               = n_ecm_nh4_acc(p)/dt            + n_ecm_nh4_retrans(p)/dt      
+      Necm(p)                   = Necm_no3(p) + Necm_nh4(p)
+      Nam_no3(p)                = n_am_no3_acc(p)/dt             + n_am_no3_retrans(p)/dt
+      Nam_nh4(p)                = n_am_nh4_acc(p)/dt             + n_am_nh4_retrans(p)/dt
+      Nam(p)                    = Nam_no3(p) + Nam_nh4(p)
+      Nnonmyc_no3(p)            = n_nonmyc_no3_acc_total(p)/dt   + n_nonmyc_no3_retrans_total(p)/dt
+      Nnonmyc_nh4(p)            = n_nonmyc_nh4_acc_total(p)/dt   + n_nonmyc_nh4_retrans_total(p)/dt
+      Nnonmyc(p)                = Nnonmyc_no3(p) + Nnonmyc_nh4(p)
+      plant_ndemand_retrans(p)  = plant_ndemand_retrans(p)/dt
+      Nuptake(p)                = Nactive_no3(p) + Nactive_nh4(p) + Nnonmyc_no3(p) &
+                                  + Nnonmyc_nh4(p) + Nfix(p) + Npassive(p) + &
+                                  retransn_to_npool(p)+free_retransn_to_npool(p) 
+      Nactive(p)                = Nactive_no3(p)  + Nactive_nh4(p) !+ Nnonmyc_no3(p) + Nnonmyc_nh4(p)
+                                   
+     ! free N goes straight to the npool, not throught Nuptake...
+      sminn_to_plant_fun(p)     = Nactive_no3(p) + Nactive_nh4(p) + Nnonmyc_no3(p) + Nnonmyc_nh4(p) + Nfix(p) + Npassive(p)
+ 
+ 
+      soil_n_extraction = ( sum(n_active_no3_vr(p,1: nlevdecomp))+sum(n_nonmyc_no3_vr(p,1: nlevdecomp))+&
+      sum(n_active_nh4_vr(p,1: nlevdecomp)) + sum(n_nonmyc_nh4_vr(p,1: nlevdecomp)))
+
+     if(use_funp)then
+      Pactive(p)            = p_active_pox_acc_total(p)/dt   + p_active_pox_retrans_total(p)/dt
+  
+           
+    
+      Pecm(p)               = p_ecm_pox_acc(p)/dt            + p_ecm_pox_retrans(p)/dt
+      
+      Pam(p)                = p_am_pox_acc(p)/dt             + p_am_pox_retrans(p)/dt
+
+      Pnonmyc(p)            = p_nonmyc_pox_acc_total(p)/dt   + p_nonmyc_pox_retrans_total(p)/dt
+  
+      plant_pdemand_retrans(p)  = plant_pdemand_retrans(p)/dt
+      Puptake(p)                = Pactive(p) + Pnonmyc(p) &
+                                  + Ppassive(p)  &
+                                  + retransp_to_ppool(p) &
+                                  + free_retransp_to_ppool(p) 
+      Pactive(p)                = Pactive(p) !+ Pnonmyc(p) 
+                                   
+     ! free P goes straight to the ppool, not throught Puptake...
+      sminp_to_plant_fun(p)     = Pactive(p) + Pnonmyc(p) + Ppassive(p)
+ 
+ 
+      soil_p_extraction =  sum(p_active_pox_vr(p,1: nlevdecomp))  +sum(p_nonmyc_pox_vr(p,1: nlevdecomp))
+     
+
+     end if
+      
+      !---------------------------C fluxes--------------------!
+
+      npp_Nactive_no3(p)        = npp_active_no3_acc_total(p)/dt + npp_active_no3_retrans_total(p)/dt
+      npp_Nactive_nh4(p)        = npp_active_nh4_acc_total(p)/dt + npp_active_nh4_retrans_total(p)/dt
+   
+
+
+      npp_Nnonmyc_no3(p)        = npp_nonmyc_no3_acc_total(p)/dt + npp_nonmyc_no3_retrans_total(p)/dt
+      npp_Nnonmyc_nh4(p)        = npp_nonmyc_nh4_acc_total(p)/dt + npp_nonmyc_nh4_retrans_total(p)/dt
+      npp_Nactive(p)            = npp_Nactive_no3(p) + npp_Nactive_nh4(p) !+ npp_Nnonmyc_no3(p) + npp_Nnonmyc_nh4(p)
+      npp_Nnonmyc(p)            = npp_Nnonmyc_no3(p) + npp_Nnonmyc_nh4(p)              
+      npp_Nfix(p)               = npp_fix_acc_total(p)/dt      
+      npp_Nretrans(p)           = npp_retrans_acc_total(p)/dt  
+
+      if(use_funp)then
+        !---------------------------C fluxes--------------------!
+
+        npp_Pactive(p)        = npp_active_pox_acc_total(p)/dt + npp_active_pox_retrans_total(p)/dt
+      
+        npp_Pnonmyc(p)        = npp_nonmyc_pox_acc_total(p)/dt + npp_nonmyc_pox_retrans_total(p)/dt
+      
+        npp_Pactive(p)            = npp_Pactive(p) !+ npp_Pnonmyc(p)
+
+        npp_Pnonmyc(p)            = npp_Pnonmyc(p)
+         
+        npp_Pretrans(p)           = npp_retrans_p_acc_total(p)/dt
+  
+      end if
+     
+
+      if (use_funp)then
+      !---------------------------Extra Respiration--------------------! 
+      !---------------------------Fluxes--------------------!      
+      !---------------------------Nitrogen--------------------!
+
+     soilc_change(p)           = (npp_active_no3_acc_total(p)      + npp_active_nh4_acc_total(p) &
+                                    + npp_nonmyc_no3_acc_total(p)     &  
+                                    + npp_nonmyc_nh4_acc_total(p)     + npp_fix_acc_total(p))/dt      &
+                                    + npp_Nretrans(p) 
+
+      soilc_change(p)           = soilc_change(p) + burned_off_carbon / dt
+
+      burnedoff_carbon(p)       = burned_off_carbon/dt    
+    
+      npp_Nuptake(p)            = soilc_change(p)
+ 
+      
+      ! how much carbon goes to growth of tissues?  
+      npp_growth(p)             = (Nuptake(p)- free_retransn_to_npool(p))*plantCN(p)+(excess_carbon_acc/dt) 
+ !does not include gresp, since this is calculated from growth
+      !---------------------------Phosphorus--------------------!
+      soilc_change_p(p)           = (npp_active_pox_acc_total(p)   + &
+                                    npp_nonmyc_pox_acc_total(p)     &  
+                                    )/dt      &
+                                    + npp_Pretrans(p)
+
+      soilc_change_p(p)           = soilc_change_p(p) + (burned_off_carbon_p / dt)   
+
+      soilc_change_p(p)           = soilc_change_p(p)/scale_availc  
+
+     !?????? Should we add the costs of nitrogen ?
+      !soilc_change(p)           = soilc_change(p) + soilc_change_p(p)      
+  
+      burnedoff_carbon_p(p)       = (burned_off_carbon_p/dt)/scale_availc   
+         
+      npp_Puptake(p)              = soilc_change_p(p)
+
+      ! how much carbon goes to growth of tissues?
+      npp_growth_p(p)             = (Puptake(p)- free_retransp_to_ppool(p))*plantCP(p)+((excess_carbon_acc_p/dt))/scale_availc   
+      !?????? Should we add the costs of nitrogen ?
+      !npp_growth(p) = npp_growth(p) + npp_growth_p(p)
+      else 
+      !---------------------------Extra Respiration Fluxes--------------------!      
+      soilc_change(p)           = (npp_active_no3_acc_total(p)      + npp_active_nh4_acc_total(p) &
+                                    + npp_nonmyc_no3_acc_total(p)     &  
+                                    + npp_nonmyc_nh4_acc_total(p)     + npp_fix_acc_total(p))/dt      &
+                                    + npp_Nretrans(p)
+      soilc_change(p)           = soilc_change(p) + burned_off_carbon / dt                 
+      burnedoff_carbon(p)       = burned_off_carbon/dt          
+      npp_Nuptake(p)            = soilc_change(p)
+      ! how much carbon goes to growth of tissues?  
+      npp_growth(p)             = (Nuptake(p)- free_retransn_to_npool(p))*plantCN(p)+(excess_carbon_acc/dt) !does not include gresp, since this is calculated from growth
+      end if
+
+     
+      !-----------------------Diagnostic Fluxes------------------------------!
+      if(availc(p).gt.0.0_r8)then !what happens in the night? 
+        nuptake_npp_fraction_patch(p) = npp_Nuptake(p)/availc(p)
+      else
+        nuptake_npp_fraction_patch(p) = 0.0_r8
+      endif 
+      if(npp_Nfix(p).gt.0.0_r8)then
+        cost_nfix(p) = Nfix(p)/npp_Nfix(p)
+      else
+        cost_nfix(p) = 0.0_r8
+      endif 
+      if(npp_Nactive(p).gt.0.0_r8)then
+        cost_nactive(p) = Nactive(p)/npp_Nactive(p)
+      else
+        cost_nactive(p) = 0.0_r8
+      endif 
+      if(npp_Nretrans(p).gt.0.0_r8)then
+        cost_nretrans(p) = Nretrans(p)/npp_Nretrans(p)
+      else
+        cost_nretrans(p) = 0.0_r8
+      endif 
+     if(npp_Nnonmyc(p).gt.0.0_r8)then
+        cost_nnonmyc(p) = Nnonmyc(p)/npp_Nnonmyc(p)
+      else
+        cost_nnonmyc(p) = 0.0_r8
+      endif 
+
+ 
+
+
+
+     if(use_funp)then
+      !-----------------------Diagnostic Fluxes------------------------------!
+      if(availc(p).gt.0.0_r8)then !what happens in the night? 
+        puptake_npp_fraction_patch(p) = npp_Puptake(p)/(scale_availc*availc(p))
+      else
+        puptake_npp_fraction_patch(p) = 0.0_r8
+      endif 
+      if(npp_Pactive(p).gt.0.0_r8)then
+        cost_pactive(p) = Pactive(p)/npp_Pactive(p)
+      else
+        cost_pactive(p) = 0.0_r8
+      endif 
+      if(npp_Pretrans(p).gt.0.0_r8)then
+        cost_pretrans(p) = Pretrans(p)/npp_Pretrans(p)
+      else
+        cost_pretrans(p) = 0.0_r8
+      endif 
+      if(npp_Pnonmyc(p).gt.0.0_r8)then
+        cost_pnonmyc(p) = Pnonmyc(p)/npp_Pnonmyc(p)
+      else
+        cost_pnonmyc(p) = 0.0_r8
+      endif 
+
+
+     end if
+       
+       
+  end do pft ! PFT Ends 
+
+  call t_stopf('CNFUNcalcs')
+
+  call p2c(bounds, num_soilc, filter_soilc,               &
+           veg_cf%soilc_change(bounds%begp:bounds%endp),  &
+           col_cf%soilc_change(bounds%begc:bounds%endc))
+           
+  call p2c(bounds, num_soilc, filter_soilc,               &
+           veg_nf%Nfix(bounds%begp:bounds%endp),          &
+           col_nf%nfix_to_sminn(bounds%begc:bounds%endc))
+
+  if(use_funp)then
+  call p2c(bounds, num_soilc, filter_soilc,               &
+           veg_cf%soilc_change_p(bounds%begp:bounds%endp),  &
+           col_cf%soilc_change_p(bounds%begc:bounds%endc))
+
+  end if
+    end associate
+
+  end subroutine CNFUN
+
+!=========================================================================================
+  real(r8) function fun_cost_fix(fixer,a_fix,b_fix,c_fix,big_cost,crootfr,s_fix, tc_soisno)
+
+! Description:
+!   Calculate the cost of fixing N by nodules.
+! Code Description:
+!   This code is written to CLM4CN by Mingjie Shi on 06/27/2013
+
+  implicit none
+!--------------------------------------------------------------------------
+! Function result.
+!--------------------------------------------------------------------------
+! real(r8) , intent(out) :: cost_of_n   !!! cost of fixing N (kgC/kgN)
+!--------------------------------------------------------------------------
+! Scalar arguments with intent(in).
+!--------------------------------------------------------------------------
+  integer,  intent(in) :: fixer     ! flag indicating if plant is a fixer
+                                    ! 1=yes, otherwise no.
+  real(r8), intent(in) :: a_fix     ! As in Houlton et al. (Nature) 2008
+  real(r8), intent(in) :: b_fix     ! As in Houlton et al. (Nature) 2008
+  real(r8), intent(in) :: c_fix     ! As in Houlton et al. (Nature) 2008
+  real(r8), intent(in) :: big_cost  ! an arbitrary large cost (gC/gN)
+  real(r8), intent(in) :: crootfr   ! fraction of roots for carbon that are in this layer
+  real(r8), intent(in) :: s_fix     ! Inverts Houlton et al. 2008 and constrains between 7.5 and 12.5
+  real(r8), intent(in) :: tc_soisno ! soil temperature (degrees Celsius)
+
+  if (fixer == 1 .and. crootfr > 1.e-6_r8) then
+     fun_cost_fix  = s_fix * (exp(a_fix + b_fix * tc_soisno * (1._r8 - 0.5_r8 * tc_soisno / c_fix)) - 2._r8)
+     
+     
+     ! New term to directly account for Ben Houlton's temperature response function. 
+     ! Assumes s_fix is -6.  (RF, Jan 2015)  
+     ! 1.25 converts from the Houlton temp response function to a 0-1 limitation factor. 
+     ! The cost of N should probably be 6 gC/gN (or 9, including maintenance costs of nodules) 
+     ! for 'optimal' temperatures. This cost should increase in a way that mirrors 
+     ! Houlton et al's observations of temperautre limitations on the mirboial fixation rates. 
+     ! We don't actually simulate the rate of fixation (and assume that N uptake is instantaneous) 
+     ! here, so instead the limitation term is here rolled into the cost function.  
+     
+     ! Here we invert the 'cost' to give the optimal N:C ratio (1/6 gN/gC)  The amount of N 
+     ! you get for a given C goes down as it gets colder, so this can be multiplied by 
+     ! the temperature function to give a temperature-limited N:C of  f/6. This number 
+     ! can then be inverted to give a temperature limited C:N, as 1/(f/6). Which is the 
+     ! same as 6/f, given here" 
+     !fun_cost_fix  = (-1*s_fix) * 1.0_r8 / (1.25_r8* (exp(a_fix + b_fix * tc_soisno * (1._r8 - 0.5_r8 * tc_soisno / c_fix)) ))
+
+     fun_cost_fix  = (-1*(-30.0_r8)) * 1.0_r8 / (1.25_r8* (exp((-3.62_r8) + (-0.27_r8) * tc_soisno * (1._r8 - 0.5_r8 * tc_soisno / (25.14_r8))) ))
+  else
+     fun_cost_fix = big_cost
+  end if    ! ends up with the fixer or non-fixer decision
+  
+  end function fun_cost_fix
+!=========================================================================================
+  real(r8) function fun_cost_active(sminn_layer,big_cost,kc_active,kn_active,rootc_dens,crootfr,smallValue)         
+
+! Description:
+!    Calculate the cost of active uptake of N frm the soil.
+! Code Description:
+!   This code is written to CLM4 by Mingjie Shi.
+
+  implicit none
+!--------------------------------------------------------------------------
+! Function result.
+!--------------------------------------------------------------------------
+  real(r8), intent(in) :: sminn_layer   !  Amount of N (as NH4 or NO3) in the soil that is available to plants (gN/m2).
+  real(r8), intent(in) :: big_cost      !  An arbitrary large cost (gC/gN).
+  real(r8), intent(in) :: kc_active     !  Constant for cost of active uptake (gC/m2).
+  real(r8), intent(in) :: kn_active     !  Constant for cost of active uptake (gC/m2).
+  real(r8), intent(in) :: rootc_dens    !  Root carbon density in layer (gC/m3).
+  real(r8), intent(in) :: crootfr        !  Fraction of roots that are in this layer.
+  real(r8), intent(in) :: smallValue    !  A small number.
+
+  if (rootc_dens > 1.e-6_r8.and.sminn_layer > smallValue) then
+     fun_cost_active =  kn_active/sminn_layer + kc_active/rootc_dens 
+  else
+!    There are very few roots in this layer. Set a high cost.
+     fun_cost_active =  big_cost
+  end if
+ 
+  end function fun_cost_active
+!=========================================================================================
+  real(r8) function fun_cost_nonmyc(sminn_layer,big_cost,kc_nonmyc,kn_nonmyc,rootc_dens,crootfr,smallValue)         
+
+! Description:
+!    Calculate the cost of nonmyc uptake of N frm the soil.
+! Code Description:
+!   This code is written to CLM4 by Mingjie Shi.
+
+  implicit none
+!--------------------------------------------------------------------------
+! Function result.
+!--------------------------------------------------------------------------
+  real(r8), intent(in) :: sminn_layer   !  Amount of N (as NH4 or NO3) in the soil that is available to plants (gN/m2).
+  real(r8), intent(in) :: big_cost      !  An arbitrary large cost (gC/gN).
+  real(r8), intent(in) :: kc_nonmyc     !  Constant for cost of nonmyc uptake (gC/m2).
+  real(r8), intent(in) :: kn_nonmyc     !  Constant for cost of nonmyc uptake (gC/m2).
+  real(r8), intent(in) :: rootc_dens   !  Root carbon density in layer (gC/m3).
+  real(r8), intent(in) :: crootfr        !  Fraction of roots that are in this layer.
+  real(r8), intent(in) :: smallValue    !  A small number.
+
+  if (rootc_dens > 1.e-6_r8.and.sminn_layer > smallValue) then
+    fun_cost_nonmyc =  kn_nonmyc / sminn_layer + kc_nonmyc / rootc_dens 
+  else
+!   There are very few roots in this layer. Set a high cost.
+    fun_cost_nonmyc = big_cost
+  end if
+
+  end function fun_cost_nonmyc
+
+!==========================================================================
+
+ subroutine fun_retranslocation(p,dt,npp_to_spend,total_falling_leaf_c,         &
+               total_falling_leaf_n, total_n_resistance, total_c_spent_retrans, &
+               total_c_accounted_retrans, free_n_retrans, paid_for_n_retrans,   &
+               target_leafcn, grperc, plantCN)
+!
+! Description:
+! This subroutine (should it be a function?) calculates the amount of N absorbed and C spent 
+! during retranslocation. 
+! Rosie Fisher. April 2016. 
+! !USES:
+  implicit none 
+
+! !ARGUMENTS:
+  real(r8), intent(IN) :: total_falling_leaf_c  ! INPUT  gC/m2/timestep
+  real(r8), intent(IN) :: total_falling_leaf_n  ! INPUT  gC/m2/timestep
+  real(r8), intent(IN) :: total_n_resistance    ! INPUT  gC/gN
+  real(r8), intent(IN) :: npp_to_spend          ! INPUT  gN/m2/timestep
+  real(r8), intent(IN) :: target_leafcn         ! INPUT  gC/gN
+  real(r8), intent(IN) :: dt                    ! INPUT  seconds
+  real(r8), intent(IN) :: grperc                ! INPUT growth respiration fraction
+  real(r8), intent(IN) :: plantCN               ! INPUT plant CN ratio
+  integer, intent(IN)  :: p                     ! INPUT  patch index
+
+  real(r8), intent(OUT) :: total_c_spent_retrans     ! OUTPUT gC/m2/timestep
+  real(r8), intent(OUT) :: total_c_accounted_retrans ! OUTPUT gC/m2/timestep
+  real(r8), intent(OUT) :: paid_for_n_retrans        ! OUTPUT gN/m2/timestep
+  real(r8), intent(OUT) :: free_n_retrans            ! OUTPUT gN/m2/timestep
+
+  !
+  ! !LOCAL VARIABLES:
+  real(r8) :: kresorb               ! INTERNAL used factor
+  real(r8) :: falling_leaf_c        ! INTERNAL gC/m2/timestep
+  real(r8) :: falling_leaf_n        ! INTERNAL gN/m2/timestep
+  real(r8) :: falling_leaf_cn       ! INTERNAL gC/gN
+  real(r8) :: cost_retrans_temp     ! INTERNAL gC/gN
+  real(r8) :: leaf_n_ext            ! INTERNAL gN/m2/timestep
+  real(r8) :: c_spent_retrans       ! INTERNAL gC/m2/timestep
+  real(r8) :: c_accounted_retrans   ! INTERNAL gC/m2/timestep
+  real(r8) :: npp_to_spend_temp     ! INTERNAL gC/m2/timestep
+  real(r8) :: max_falling_leaf_cn   ! INTERNAL gC/gN
+  real(r8) :: min_falling_leaf_cn   ! INTERNAL gC/gN
+  real(r8) :: cost_escalation       ! INTERNAL cost function parameter
+  integer  :: iter                  ! INTERNAL
+  integer  :: exitloop              ! INTERNAL
+  ! ------------------------------------------------------------------------------- 
+
+
+   ! ------------------ Initialize total fluxes. ------------------!
+   total_c_spent_retrans = 0.0_r8
+   total_c_accounted_retrans = 0.0_r8
+   c_accounted_retrans   = 0.0_r8
+   paid_for_n_retrans    = 0.0_r8
+   npp_to_spend_temp     = npp_to_spend
+
+   ! ------------------ Initial C and N pools in falling leaves. ------------------!
+   falling_leaf_c       =  total_falling_leaf_c      
+   falling_leaf_n       =  total_falling_leaf_n 
+
+   !  ------------------ PARAMETERS ------------------ 
+   max_falling_leaf_cn = target_leafcn * 3.0_r8 
+   min_falling_leaf_cn = target_leafcn * 1.5_r8
+   cost_escalation     = 1.3_r8
+
+   !  ------------------ Free uptake ------------------ 
+   free_n_retrans  = max(falling_leaf_n -  (falling_leaf_c/min_falling_leaf_cn),0.0_r8)
+   
+   falling_leaf_n = falling_leaf_n -  free_n_retrans 
+
+   ! ------------------ Initial CN ratio and costs ------------------!  
+   falling_leaf_cn      = falling_leaf_c/falling_leaf_n 
+   kresorb =  (1.0_r8/target_leafcn)
+   cost_retrans_temp    = kresorb / ((1.0_r8/falling_leaf_cn )**1.3_r8)
+
+   ! ------------------ Iteration loops to figure out extraction limit ------------!
+   iter = 0
+   exitloop = 0
+   do while(exitloop==0.and.cost_retrans_temp .lt. total_n_resistance.and. &
+            falling_leaf_n.ge.0.0_r8.and.npp_to_spend.gt.0.0_r8)
+      ! ------------------ Spend some C on removing N ------------!
+      ! spend enough C to increase leaf C/N by 1 unit. 
+      c_spent_retrans   = cost_retrans_temp * (falling_leaf_n - falling_leaf_c / &
+                          (falling_leaf_cn + 1.0_r8))
+      ! don't spend more C than you have  
+      c_spent_retrans   = min(npp_to_spend_temp, c_spent_retrans) 
+      ! N extracted, per this amount of C expenditure
+      leaf_n_ext        = c_spent_retrans / cost_retrans_temp     
+      ! Do not empty N pool 
+      leaf_n_ext        = min(falling_leaf_n, leaf_n_ext)    
+      !How much C do you need to account for the N that got taken up? 
+      c_accounted_retrans = leaf_n_ext * plantCN * (1.0_r8 + grperc)      
+
+      ! ------------------ Update leafCN, recalculate costs ------------!
+      falling_leaf_n    = falling_leaf_n - leaf_n_ext          ! remove N from falling leaves pool 
+      if(falling_leaf_n.gt.0.0_r8)then
+         falling_leaf_cn   = falling_leaf_c/falling_leaf_n     ! C/N ratio
+         cost_retrans_temp = kresorb /((1.0_r8/falling_leaf_cn)**1.3_r8) ! cost function. PARAMETER
+      else
+         exitloop=1
+      endif 
+ 
+      ! ------------------ Accumulate total fluxes ------------!
+      total_c_spent_retrans     = total_c_spent_retrans + c_spent_retrans 
+      total_c_accounted_retrans = total_c_accounted_retrans + c_accounted_retrans 
+      paid_for_n_retrans    = paid_for_n_retrans    + leaf_n_ext
+      npp_to_spend_temp     = npp_to_spend_temp     - c_spent_retrans  - c_accounted_retrans
+      iter = iter+1
+   
+      ! run out of C or N
+      if(npp_to_spend_temp.le.0.0_r8)then
+         exitloop=1
+         ! if we made a solving error on this (expenditure and n uptake should 
+         ! really be solved simultaneously)
+         ! then remove the error from the expenditure. This changes the notional cost, 
+         ! but only by a bit and prevents cpool errors. 
+
+         total_c_spent_retrans  = total_c_spent_retrans + npp_to_spend_temp 
+      endif 
+      ! leaf CN is too high
+      if(falling_leaf_cn.ge.max_falling_leaf_cn)then
+         exitloop=1
+      endif
+      ! safety check to prevent hanging code
+      if(iter.ge.150)then
+          exitloop=1
+      endif 
+   end do
+
+ end subroutine fun_retranslocation
+
+!==========================================================================
+
+!==========================================================================
+
+ subroutine fun_retranslocation_p(p,dt,npp_to_spend_p,total_falling_leaf_c,         &
+               total_falling_leaf_p, total_p_resistance, total_c_spent_retrans, &
+               total_c_accounted_retrans, free_p_retrans, paid_for_p_retrans,   &
+               target_leafcp, grperc, plantCP,smallValue,big_cost)
+!
+! Description:
+! This subroutine (should it be a function?) calculates the amount of P absorbed and C spent 
+! during retranslocation. 
+! Renato Braghiere.May 2020. 
+! !USES:
+  implicit none 
+
+! !ARGUMENTS:
+  real(r8), intent(IN) :: total_falling_leaf_c  ! INPUT  gC/m2/timestep
+  real(r8), intent(IN) :: total_falling_leaf_p  ! INPUT  gC/m2/timestep
+  real(r8), intent(IN) :: total_p_resistance    ! INPUT  gC/gP
+  real(r8), intent(IN) :: npp_to_spend_p        ! INPUT  gP/m2/timestep
+  real(r8), intent(IN) :: target_leafcp         ! INPUT  gC/gP
+  real(r8), intent(IN) :: dt                    ! INPUT  seconds
+  real(r8), intent(IN) :: grperc                ! INPUT growth respiration fraction
+  real(r8), intent(IN) :: plantCP               ! INPUT plant CP ratio
+  integer, intent(IN)  :: p                     ! INPUT  patch index
+  real(r8), intent(IN) :: big_cost              !  An arbitrary large cost (gC/gN).
+  real(r8), intent(IN) :: smallValue            !  A small number.
+
+  real(r8), intent(OUT) :: total_c_spent_retrans     ! OUTPUT gC/m2/timestep
+  real(r8), intent(OUT) :: total_c_accounted_retrans ! OUTPUT gC/m2/timestep
+  real(r8), intent(OUT) :: paid_for_p_retrans        ! OUTPUT gP/m2/timestep
+  real(r8), intent(OUT) :: free_p_retrans            ! OUTPUT gP/m2/timestep
+
+  !
+  ! !LOCAL VARIABLES:
+  real(r8) :: kresorb               ! INTERNAL used factor
+  real(r8) :: falling_leaf_c        ! INTERNAL gC/m2/timestep
+  real(r8) :: falling_leaf_p        ! INTERNAL gP/m2/timestep
+  real(r8) :: falling_leaf_cp       ! INTERNAL gC/gP
+  real(r8) :: cost_retrans_temp     ! INTERNAL gC/gP
+  real(r8) :: leaf_p_ext            ! INTERNAL gN/m2/timestep
+  real(r8) :: c_spent_retrans       ! INTERNAL gC/m2/timestep
+  real(r8) :: c_accounted_retrans   ! INTERNAL gC/m2/timestep
+  real(r8) :: npp_to_spend_temp     ! INTERNAL gC/m2/timestep
+  real(r8) :: max_falling_leaf_cp   ! INTERNAL gC/gP
+  real(r8) :: min_falling_leaf_cp   ! INTERNAL gC/gP
+  real(r8) :: cost_escalation       ! INTERNAL cost function parameter
+  integer  :: iter                  ! INTERNAL
+  integer  :: exitloop              ! INTERNAL
+  ! ------------------------------------------------------------------------------- 
+
+
+
+
+   ! ------------------ Initialize total fluxes. ------------------!
+   total_c_spent_retrans = 0.0_r8
+   total_c_accounted_retrans = 0.0_r8
+   c_accounted_retrans   = 0.0_r8
+   paid_for_p_retrans    = 0.0_r8
+   npp_to_spend_temp     = npp_to_spend_p
+
+   ! ------------------ Initial C and P pools in falling leaves. ------------------!
+   falling_leaf_c       =  total_falling_leaf_c      
+   falling_leaf_p       =  total_falling_leaf_p 
+
+   !  ------------------ PARAMETERS ------------------ 
+   max_falling_leaf_cp = target_leafcp * 3.0_r8 
+   min_falling_leaf_cp = target_leafcp * 1.5_r8
+   cost_escalation     = 1.3_r8
+
+   !  ------------------ Free uptake ------------------ 
+   free_p_retrans  = max(falling_leaf_p -  (falling_leaf_c/min_falling_leaf_cp),0.0_r8)
+   falling_leaf_p = falling_leaf_p -  free_p_retrans 
+
+   ! ------------------ Initial CP ratio and costs ------------------! 
+   falling_leaf_cp      = falling_leaf_c/falling_leaf_p 
+   kresorb = (1.0_r8/target_leafcp)
+   cost_retrans_temp = kresorb /((1.0_r8/falling_leaf_cp)**cost_escalation) ! cost function. PARAMETER
+   cost_retrans_temp =  cost_retrans_temp! cost function. PARAMETER
+
+  !kresorb = 0.005 !From Allen et al. (2020)
+  !if (total_falling_leaf_p  > smallValue) then
+  ! cost_retrans_temp    = kresorb / falling_leaf_p 
+  !else
+!   Little P available. Set cost to an arbitrary high value.
+  ! cost_retrans_temp = big_cost
+  !end if
+ 
+  ! ------------------ Iteration loops to figure out extraction limit ------------!
+   iter = 0
+   exitloop = 0
+   do while(exitloop==0.and.cost_retrans_temp .lt. total_p_resistance.and. &
+            falling_leaf_p.ge.0.0_r8.and.npp_to_spend_p.gt.0.0_r8)
+      ! ------------------ Spend some C on removing P ------------!
+      ! spend enough C to increase leaf C/P by 1 unit. 
+      c_spent_retrans   = cost_retrans_temp * (falling_leaf_p - falling_leaf_c/ &
+                          (falling_leaf_cp + 1.0_r8))
+      ! don't spend more C than you have  
+      c_spent_retrans   = min(npp_to_spend_temp, c_spent_retrans) 
+      ! N extracted, per this amount of C expenditure
+      leaf_p_ext        = c_spent_retrans / cost_retrans_temp     
+      ! Do not empty N pool 
+      leaf_p_ext        = min(falling_leaf_p, leaf_p_ext)    
+      !How much C do you need to account for the N that got taken up? 
+      c_accounted_retrans = leaf_p_ext * plantCP * (1.0_r8 + grperc)      
+
+      ! ------------------ Update leafCP, recalculate costs ------------!
+      falling_leaf_p    = falling_leaf_p - leaf_p_ext          ! remove P from falling leaves pool 
+      if(falling_leaf_p.gt.0.0_r8)then
+         falling_leaf_cp   = falling_leaf_c/falling_leaf_p     ! C/P ratio
+         cost_retrans_temp = kresorb /((1.0_r8/falling_leaf_cp)**cost_escalation) ! cost function. PARAMETER
+         cost_retrans_temp =  cost_retrans_temp! cost function. PARAMETER
+         !if (total_falling_leaf_p  .gt. smallValue) then
+         !  cost_retrans_temp    = kresorb / total_falling_leaf_p 
+         !else
+         !   Little P available. Set cost to an arbitrary high value.
+         !  cost_retrans_temp = big_cost
+         !end if
+      else
+         exitloop=1
+      endif 
+ 
+      ! ------------------ Accumulate total fluxes ------------!
+      total_c_spent_retrans     = total_c_spent_retrans + c_spent_retrans 
+      total_c_accounted_retrans = total_c_accounted_retrans + c_accounted_retrans 
+      paid_for_p_retrans    = paid_for_p_retrans    + leaf_p_ext
+      npp_to_spend_temp     = npp_to_spend_temp     - c_spent_retrans  - c_accounted_retrans
+      iter = iter+1
+   
+      ! run out of C or P
+      if(npp_to_spend_temp.le.0.0_r8)then
+         exitloop=1
+         ! if we made a solving error on this (expenditure and p uptake should 
+         ! really be solved simultaneously)
+         ! then remove the error from the expenditure. This changes the notional cost, 
+         ! but only by a bit and prevents cpool errors. 
+
+         total_c_spent_retrans  = total_c_spent_retrans + npp_to_spend_temp 
+      endif 
+      ! leaf CN is too high
+      if(falling_leaf_cp.ge.max_falling_leaf_cp)then
+         exitloop=1
+      endif
+      ! safety check to prevent hanging code
+      if(iter.ge.150)then
+          exitloop=1
+      endif 
+   end do
+
+ end subroutine fun_retranslocation_p
+
+
+!==========================================================================
+end module CNFUNMod 
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CNNitrogenFluxType.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CNNitrogenFluxType.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CNNitrogenFluxType.F90	2020-06-10 13:57:17.295178878 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CNNitrogenFluxType.F90	2020-07-23 20:35:04.105820476 -0400
@@ -12,7 +12,7 @@
   use abortutils             , only : endrun
   use LandunitType           , only : lun_pp                
   use ColumnType             , only : col_pp                
-  use VegetationType              , only : veg_pp
+  use VegetationType         , only : veg_pp
   ! bgc interface & pflotran:
   use clm_varctl             , only : use_clm_interface, use_pflotran, pf_cmode, pf_hmode, use_vertsoilc
   ! 
@@ -151,7 +151,8 @@
      real(r8), pointer :: frootn_to_litter_patch                    (:)     ! patch fine root N litterfall (gN/m2/s)
 
      ! allocation fluxes
-     real(r8), pointer :: retransn_to_npool_patch                   (:)     ! patch deployment of retranslocated N (gN/m2/s)       
+     real(r8), pointer :: retransn_to_npool_patch                   (:)     ! patch deployment of retranslocated N (gN/m2/s) 
+     real(r8), pointer :: free_retransn_to_npool_patch                   (:)     ! patch deployment of free retranslocated N (gN/m2/s) 
      real(r8), pointer :: sminn_to_npool_patch                      (:)     ! patch deployment of soil mineral N uptake (gN/m2/s)
      real(r8), pointer :: npool_to_grainn_patch                     (:)     ! patch allocation to grain N for prognostic crop (gN/m2/s)
      real(r8), pointer :: npool_to_grainn_storage_patch             (:)     ! patch allocation to grain N storage for prognostic crop (gN/m2/s)
@@ -195,7 +196,8 @@
 
      ! deposition fluxes
      real(r8), pointer :: ndep_to_sminn_col                         (:)     ! col atmospheric N deposition to soil mineral N (gN/m2/s)
-     real(r8), pointer :: nfix_to_sminn_col                         (:)     ! col symbiotic/asymbiotic N fixation to soil mineral N (gN/m2/s) 
+     real(r8), pointer :: nfix_to_sminn_col                         (:)     ! col symbiotic/asymbiotic N fixation to soil mineral N (gN/m2/s)
+     real(r8), pointer :: ffix_to_sminn_col                         (:)     ! col free living N fixation to soil mineral N (gN/m2/s)
      real(r8), pointer :: nfix_to_plantn_patch                      (:)     ! nitrogen fixation goes to plant
      real(r8), pointer :: nfix_to_ecosysn_col                       (:)     ! total nitrogen fixation
      real(r8), pointer :: fert_to_sminn_col                         (:)     ! col fertilizer N to soil mineral N (gN/m2/s)
@@ -224,7 +226,12 @@
      real(r8), pointer :: actual_immob_vr_col                       (:,:)   ! col vertically-resolved actual N immobilization (gN/m3/s) at each level
      real(r8), pointer :: actual_immob_col                          (:)     ! col vert-int (diagnostic) actual N immobilization (gN/m2/s)
      real(r8), pointer :: sminn_to_plant_vr_col                     (:,:)   ! col vertically-resolved plant uptake of soil mineral N (gN/m3/s)
+     !FUN module variables
+     real(r8), pointer :: sminn_to_plant_fun_vr_col                     (:,:)   ! col total layer soil mineral N uptake of FUN (gN/m2/s)
+     real(r8), pointer :: sminn_to_plant_fun_no3_vr_col                     (:,:)   ! col total layer soil mineral NO3 uptake of FUN (gN/m2/s)
+     real(r8), pointer :: sminn_to_plant_fun_nh4_vr_col                     (:,:)   ! col total layer soil mineral NH4 uptake of FUN (gN/m2/s)
      real(r8), pointer :: sminn_to_plant_col                        (:)     ! col vert-int (diagnostic) plant uptake of soil mineral N (gN/m2/s)
+     real(r8), pointer :: sminn_to_plant_fun_col                        (:)     ! col vert-int (diagnostic) plant uptake of soil mineral N (gN/m2/s)
      real(r8), pointer :: supplement_to_sminn_vr_col                (:,:)   ! col vertically-resolved supplemental N supply (gN/m3/s)
      real(r8), pointer :: supplement_to_sminn_col                   (:)     ! col vert-int (diagnostic) supplemental N supply (gN/m2/s)
      real(r8), pointer :: gross_nmin_vr_col                         (:,:)   ! col vertically-resolved gross rate of N mineralization (gN/m3/s)
@@ -360,6 +367,41 @@
      real(r8), pointer :: avail_retransn_patch                      (:)     ! N flux available from retranslocation pool (gN/m2/s)
      real(r8), pointer :: plant_nalloc_patch                        (:)     ! total allocated N flux (gN/m2/s)
 
+     ! Variables used by FUN
+     real(r8), pointer :: plant_ndemand_retrans_patch               (:)     ! The N demand pool generated for FUN2.0; mainly used for deciduous trees (gN/m2/s)
+     real(r8), pointer :: plant_ndemand_season_patch                (:)     ! The N demand pool for seasonal deciduous (gN/m2/s)
+     real(r8), pointer :: plant_ndemand_stress_patch                (:)     ! The N demand pool for stress deciduous   (gN/m2/s)
+     real(r8), pointer :: Nactive_patch                             (:)     ! N acquired by mycorrhizal uptake  (gN/m2/s)
+     real(r8), pointer :: Nnonmyc_patch                             (:)     ! N acquired by non-myc uptake      (gN/m2/s)
+     real(r8), pointer :: Nam_patch                                 (:)     ! N acquired by AM plant            (gN/m2/s)
+     real(r8), pointer :: Necm_patch                                (:)     ! N acquired by ECM plant           (gN/m2/s)
+     real(r8), pointer :: Nactive_no3_patch                         (:)     ! N acquired by mycorrhizal uptake  (gN/m2/s)
+     real(r8), pointer :: Nactive_nh4_patch                         (:)     ! N acquired by mycorrhizal uptake  (gN/m2/s)
+     real(r8), pointer :: Nnonmyc_no3_patch                         (:)     ! N acquired by non-myc             (gN/m2/s)
+     real(r8), pointer :: Nnonmyc_nh4_patch                         (:)     ! N acquired by non-myc             (gN/m2/s)
+     real(r8), pointer :: Nam_no3_patch                             (:)     ! N acquired by AM plant            (gN/m2/s)
+     real(r8), pointer :: Nam_nh4_patch                             (:)     ! N acquired by AM plant            (gN/m2/s)
+     real(r8), pointer :: Necm_no3_patch                            (:)     ! N acquired by ECM plant           (gN/m2/s)
+     real(r8), pointer :: Necm_nh4_patch                            (:)     ! N acquired by ECM plant           (gN/m2/s)
+     real(r8), pointer :: Nfix_patch                                (:)     ! N acquired by Symbiotic BNF       (gN/m2/s)
+     real(r8), pointer :: Npassive_patch                            (:)     ! N acquired by passive uptake      (gN/m2/s)
+     real(r8), pointer :: Nretrans_patch                            (:)     ! N acquired by retranslocation     (gN/m2/s)
+     real(r8), pointer :: Nretrans_org_patch                        (:)     ! N acquired by retranslocation     (gN/m2/s)
+     real(r8), pointer :: Nretrans_season_patch                     (:)     ! N acquired by retranslocation     (gN/m2/s)
+     real(r8), pointer :: Nretrans_stress_patch                     (:)     ! N acquired by retranslocation     (gN/m2/s)
+     real(r8), pointer :: Nuptake_patch                             (:)     ! Total N uptake of FUN             (gN/m2/s)
+     real(r8), pointer :: sminn_to_plant_fun_patch                  (:)     ! Total soil N uptake of FUN        (gN/m2/s)
+     real(r8), pointer :: sminn_to_plant_fun_vr_patch               (:,:)   ! Total layer soil N uptake of FUN  (gN/m2/s)
+
+     real(r8), pointer :: sminn_to_plant_fun_no3_vr_patch           (:,:)   ! Total layer no3 uptake of FUN     (gN/m2/s)
+     real(r8), pointer :: sminn_to_plant_fun_nh4_vr_patch           (:,:)   ! Total layer nh4 uptake of FUN     (gN/m2/s)
+     real(r8), pointer :: cost_nfix_patch                           (:)     ! Average cost of fixation          (gN/m2/s)
+     real(r8), pointer :: cost_nactive_patch                        (:)     ! Average cost of active uptake     (gN/m2/s)
+     real(r8), pointer :: cost_nretrans_patch                       (:)     ! Average cost of retranslocation   (gN/m2/s)
+     real(r8), pointer :: cost_nnonmyc_patch                        (:)     ! Average cost of non-mycorrhizal uptake (gN/m2/s)
+     real(r8), pointer :: nuptake_npp_fraction_patch                  (:)    ! frac of npp spent on N acquisition   (gN/m2/s)
+
+
      ! bgc interface/pflotran
      !------------------------------------------------------------------------
      real(r8), pointer :: plant_ndemand_col                         (:)     ! col N flux required to support initial GPP (gN/m2/s)
@@ -564,6 +606,7 @@
     allocate(this%frootn_to_retransn_patch                  (begp:endp)) ; this%frootn_to_retransn_patch                  (:) = nan
     allocate(this%frootn_to_litter_patch                    (begp:endp)) ; this%frootn_to_litter_patch                    (:) = nan
     allocate(this%retransn_to_npool_patch                   (begp:endp)) ; this%retransn_to_npool_patch                   (:) = nan
+    allocate(this%free_retransn_to_npool_patch              (begp:endp)) ; this%free_retransn_to_npool_patch              (:) = nan
     allocate(this%sminn_to_npool_patch                      (begp:endp)) ; this%sminn_to_npool_patch                      (:) = nan
 
     allocate(this%npool_to_leafn_patch              (begp:endp)) ; this%npool_to_leafn_patch              (:) = nan
@@ -606,6 +649,7 @@
 
     allocate(this%ndep_to_sminn_col             (begc:endc))    ; this%ndep_to_sminn_col	     (:) = nan
     allocate(this%nfix_to_sminn_col             (begc:endc))    ; this%nfix_to_sminn_col	     (:) = nan
+    allocate(this%ffix_to_sminn_col             (begc:endc))    ; this%ffix_to_sminn_col	     (:) = nan
     allocate(this%nfix_to_ecosysn_col           (begc:endc))    ; this%nfix_to_ecosysn_col           (:) = nan
     allocate(this%fert_to_sminn_col             (begc:endc))    ; this%fert_to_sminn_col	     (:) = nan
     allocate(this%soyfixn_to_sminn_col          (begc:endc))    ; this%soyfixn_to_sminn_col          (:) = nan
@@ -613,6 +657,7 @@
     allocate(this%hrv_deadstemn_to_prod100n_col (begc:endc))    ; this%hrv_deadstemn_to_prod100n_col (:) = nan
     allocate(this%hrv_cropn_to_prod1n_col       (begc:endc))    ; this%hrv_cropn_to_prod1n_col       (:) = nan
     allocate(this%sminn_to_plant_col            (begc:endc))    ; this%sminn_to_plant_col	     (:) = nan
+    allocate(this%sminn_to_plant_fun_col        (begc:endc))    ; this%sminn_to_plant_fun_col        (:) = nan
     allocate(this%potential_immob_col           (begc:endc))    ; this%potential_immob_col           (:) = nan
     allocate(this%actual_immob_col              (begc:endc))    ; this%actual_immob_col              (:) = nan
     allocate(this%gross_nmin_col                (begc:endc))    ; this%gross_nmin_col                (:) = nan
@@ -638,6 +683,12 @@
     allocate(this%potential_immob_vr_col     (begc:endc,1:nlevdecomp_full)) ; this%potential_immob_vr_col     (:,:) = nan
     allocate(this%actual_immob_vr_col        (begc:endc,1:nlevdecomp_full)) ; this%actual_immob_vr_col        (:,:) = nan
     allocate(this%sminn_to_plant_vr_col      (begc:endc,1:nlevdecomp_full)) ; this%sminn_to_plant_vr_col      (:,:) = nan
+    !FUN module variables
+    allocate(this%sminn_to_plant_fun_vr_col      (begc:endc,1:nlevdecomp_full)) ; this%sminn_to_plant_fun_vr_col      (:,:) = nan
+    allocate(this%sminn_to_plant_fun_no3_vr_col      (begc:endc,1:nlevdecomp_full)) ; this%sminn_to_plant_fun_no3_vr_col      (:,:) = nan
+    allocate(this%sminn_to_plant_fun_nh4_vr_col      (begc:endc,1:nlevdecomp_full)) ; this%sminn_to_plant_fun_nh4_vr_col      (:,:) = nan
+   !!!!
+
     allocate(this%supplement_to_sminn_vr_col (begc:endc,1:nlevdecomp_full)) ; this%supplement_to_sminn_vr_col (:,:) = nan
     allocate(this%gross_nmin_vr_col          (begc:endc,1:nlevdecomp_full)) ; this%gross_nmin_vr_col          (:,:) = nan
     allocate(this%net_nmin_vr_col            (begc:endc,1:nlevdecomp_full)) ; this%net_nmin_vr_col            (:,:) = nan
@@ -790,6 +841,43 @@
     allocate(this%plant_ndemand_patch         (begp:endp)) ;    this%plant_ndemand_patch         (:) = nan
     allocate(this%avail_retransn_patch        (begp:endp)) ;    this%avail_retransn_patch        (:) = nan
     allocate(this%plant_nalloc_patch          (begp:endp)) ;    this%plant_nalloc_patch          (:) = nan
+    !Variables used by FUN
+    allocate(this%plant_ndemand_retrans_patch (begp:endp)) ;    this%plant_ndemand_retrans_patch (:) = nan
+    allocate(this%plant_ndemand_season_patch  (begp:endp)) ;    this%plant_ndemand_season_patch  (:) = nan
+    allocate(this%plant_ndemand_stress_patch  (begp:endp)) ;    this%plant_ndemand_stress_patch  (:) = nan
+    allocate(this%Nactive_patch               (begp:endp)) ;    this%Nactive_patch               (:) = nan 
+    allocate(this%Nnonmyc_patch               (begp:endp)) ;    this%Nnonmyc_patch               (:) = nan
+    allocate(this%Nam_patch                   (begp:endp)) ;    this%Nam_patch                   (:) = nan
+    allocate(this%Necm_patch                  (begp:endp)) ;    this%Necm_patch                  (:) = nan
+    allocate(this%Nactive_no3_patch           (begp:endp)) ;    this%Nactive_no3_patch           (:) = nan
+    allocate(this%Nactive_nh4_patch           (begp:endp)) ;    this%Nactive_nh4_patch           (:) = nan
+    allocate(this%Nnonmyc_no3_patch           (begp:endp)) ;    this%Nnonmyc_no3_patch           (:) = nan
+    allocate(this%Nnonmyc_nh4_patch           (begp:endp)) ;    this%Nnonmyc_nh4_patch           (:) = nan
+    allocate(this%Nam_no3_patch               (begp:endp)) ;    this%Nam_no3_patch               (:) = nan
+    allocate(this%Nam_nh4_patch               (begp:endp)) ;    this%Nam_nh4_patch               (:) = nan
+    allocate(this%Necm_no3_patch              (begp:endp)) ;    this%Necm_no3_patch              (:) = nan
+    allocate(this%Necm_nh4_patch              (begp:endp)) ;    this%Necm_nh4_patch              (:) = nan
+    allocate(this%Npassive_patch              (begp:endp)) ;    this%Npassive_patch              (:) = nan
+    allocate(this%Nfix_patch                  (begp:endp)) ;    this%Nfix_patch                  (:) = nan
+    allocate(this%Nretrans_patch              (begp:endp)) ;    this%Nretrans_patch              (:) = nan
+    allocate(this%Nretrans_org_patch          (begp:endp)) ;    this%Nretrans_org_patch          (:) = nan
+    allocate(this%Nretrans_season_patch       (begp:endp)) ;    this%Nretrans_season_patch       (:) = nan
+    allocate(this%Nretrans_stress_patch       (begp:endp)) ;    this%Nretrans_stress_patch       (:) = nan 
+    allocate(this%Nuptake_patch               (begp:endp)) ;    this%Nuptake_patch               (:) = nan
+    allocate(this%sminn_to_plant_fun_patch    (begp:endp)) ;    this%sminn_to_plant_fun_patch    (:) = nan
+    allocate(this%sminn_to_plant_fun_vr_patch (begp:endp,    1:nlevdecomp_full)) 
+    this%sminn_to_plant_fun_vr_patch          (:,:) = nan
+    allocate(this%sminn_to_plant_fun_no3_vr_patch (begp:endp,1:nlevdecomp_full))  
+    this%sminn_to_plant_fun_no3_vr_patch      (:,:) = nan
+    allocate(this%sminn_to_plant_fun_nh4_vr_patch (begp:endp,1:nlevdecomp_full))  
+    this%sminn_to_plant_fun_nh4_vr_patch      (:,:) = nan
+    allocate(this%cost_nfix_patch              (begp:endp)) ;    this%cost_nfix_patch            (:) = nan
+    allocate(this%cost_nactive_patch           (begp:endp)) ;    this%cost_nactive_patch         (:) = nan
+    allocate(this%cost_nretrans_patch          (begp:endp)) ;    this%cost_nretrans_patch        (:) = nan
+    allocate(this%cost_nnonmyc_patch            (begp:endp)) ;    this%cost_nnonmyc_patch         (:) = nan
+
+    allocate(this%nuptake_npp_fraction_patch   (begp:endp)) ;    this%nuptake_npp_fraction_patch            (:) = nan
+
 
     ! bgc interface & pflotran
     !------------------------------------------------------------------------
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CNNitrogenStateType.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CNNitrogenStateType.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/CNNitrogenStateType.F90	2020-06-10 13:56:35.057392052 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/CNNitrogenStateType.F90	2020-05-10 20:09:52.127086516 -0400
@@ -40,6 +40,8 @@
      real(r8), pointer :: leafn_patch                  (:)     ! patch (gN/m2) leaf N 
      real(r8), pointer :: leafn_storage_patch          (:)     ! patch (gN/m2) leaf N storage
      real(r8), pointer :: leafn_xfer_patch             (:)     ! patch (gN/m2) leaf N transfer
+     real(r8), pointer :: leafn_storage_xfer_acc_patch (:)     ! patch (gN/m2) Accmulated leaf N transfer
+     real(r8), pointer :: storage_ndemand_patch        (:)     ! patch (gN/m2) N use from the N storage pool
      real(r8), pointer :: frootn_patch                 (:)     ! patch (gN/m2) fine root N
      real(r8), pointer :: frootn_storage_patch         (:)     ! patch (gN/m2) fine root N storage
      real(r8), pointer :: frootn_xfer_patch            (:)     ! patch (gN/m2) fine root N transfer
@@ -254,7 +256,9 @@
     allocate(this%grainn_xfer_patch        (begp:endp))                   ; this%grainn_xfer_patch        (:)   = nan     
     allocate(this%leafn_patch              (begp:endp))                   ; this%leafn_patch              (:)   = nan
     allocate(this%leafn_storage_patch      (begp:endp))                   ; this%leafn_storage_patch      (:)   = nan     
-    allocate(this%leafn_xfer_patch         (begp:endp))                   ; this%leafn_xfer_patch         (:)   = nan     
+    allocate(this%leafn_xfer_patch         (begp:endp))                   ; this%leafn_xfer_patch         (:)   = nan 
+    allocate(this%leafn_storage_xfer_acc_patch         (begp:endp))                   ; this%leafn_storage_xfer_acc_patch         (:)   = nan
+    allocate(this%storage_ndemand_patch         (begp:endp))                   ; this%storage_ndemand_patch         (:)   = nan  
     allocate(this%frootn_patch             (begp:endp))                   ; this%frootn_patch             (:)   = nan
     allocate(this%frootn_storage_patch     (begp:endp))                   ; this%frootn_storage_patch     (:)   = nan     
     allocate(this%frootn_xfer_patch        (begp:endp))                   ; this%frootn_xfer_patch        (:)   = nan     
@@ -516,6 +520,10 @@
           end if
 
           this%leafn_xfer_patch(p)        = 0._r8
+          this%leafn_storage_xfer_acc_patch(p)  = 0._r8
+          this%storage_ndemand_patch(p)   = 0._r8
+
+
           if ( crop_prog )then
              this%grainn_patch(p)            = 0._r8
              this%grainn_storage_patch(p)    = 0._r8
@@ -756,6 +764,8 @@
        this%leafn_patch(i)              = value_patch
        this%leafn_storage_patch(i)      = value_patch
        this%leafn_xfer_patch(i)         = value_patch
+       this%leafn_storage_xfer_acc_patch(i)  = value_patch
+       this%storage_ndemand_patch(i)    = value_patch
        this%frootn_patch(i)             = value_patch
        this%frootn_storage_patch(i)     = value_patch
        this%frootn_xfer_patch(i)        = value_patch
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/EcosystemBalanceCheckMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/EcosystemBalanceCheckMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/EcosystemBalanceCheckMod.F90	2020-06-10 13:56:35.096391855 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/EcosystemBalanceCheckMod.F90	2020-08-23 14:12:25.125882324 -0400
@@ -1,3 +1,4 @@
+
 module EcosystemBalanceCheckMod
 
   !-----------------------------------------------------------------------
@@ -21,6 +22,7 @@
   use clm_varcon          , only : dzsoi_decomp
   use clm_varctl          , only : nu_com
   use clm_varctl          , only : ECA_Pconst_RGspin
+  use clm_varctl          , only : use_fun, use_funp
 
   use CNDecompCascadeConType , only : decomp_cascade_con
   use clm_varpar          , only: ndecomp_cascade_transitions
@@ -205,6 +207,9 @@
          totcolc                   =>    col_cs%totcolc                  , & ! Input:  [real(r8) (:) ]  (gC/m2)   total column carbon, incl veg and cpool
          gpp                       =>    col_cf%gpp                       , & ! Input:  [real(r8) (:) ]  (gC/m2/s) gross primary production
          er                        =>    col_cf%er                        , & ! Input:  [real(r8) (:) ]  (gC/m2/s) total ecosystem respiration, autotrophic + heterotrophic
+         ar                        =>    col_cf%ar                        , & ! Input:  [real(r8) (:) ]  (gC/m2/s)  autotrophic 
+         soilc_change              =>    col_cf%soilc_change                        , & ! Input:  [real(r8) (:) ]  (gC/m2/s)  chaneg in soil carbon caused by FUN
+         soilc_change_p              =>    col_cf%soilc_change_p                     , & ! Input:  [real(r8) (:) ]  (gC/m2/s)  chaneg in soil carbon caused by FUN-P
          col_fire_closs            =>    col_cf%fire_closs                , & ! Input:  [real(r8) (:) ]  (gC/m2/s) total column-level fire C loss
          col_prod1c_loss           =>    col_cf%prod1c_loss               , & ! Input:  [real(r8) (:) ]  (gC/m2/s) crop leafc harvested
          col_prod10c_loss          =>    col_cf%prod10c_loss              , & ! Input:  [real(r8) (:) ]  (gC/m2/s) 10-year wood C harvested
@@ -261,14 +266,23 @@
          end if
 
          ! check for significant errors
-         if (abs(col_errcb(c)) > 1e-8_r8) then
+         if (abs(col_errcb(c)) > 1e-7_r8) then
+         !if (abs(col_errcb(c)) > 1e-2_r8) then
             err_found = .true.
             err_index = c
          end if
+         if(.not.use_fun)then
+         !if (abs(col_errcb(c)) > 1e-8_r8) then
+         if (abs(col_errcb(c)) > 1e-3_r8) then
+            write(iulog,*) 'cbalance warning',c,col_errcb(c),col_endcb(c)
+         end if
+         end if
+
       end do ! end of columns loop
       
       ! Consider adapting this check to be fates compliant (rgk 04-2017)
-      if (.not. use_fates) then
+      if (.not. use_fun ) then
+       if (.not. use_fates ) then
          if (err_found) then
             c = err_index
             write(iulog,*)'column cbalance error = ', col_errcb(c), c
@@ -276,6 +290,9 @@
             write(iulog,*)'input                 = ',col_cinputs(c)*dt
             write(iulog,*)'output                = ',col_coutputs(c)*dt
             write(iulog,*)'er                    = ',er(c)*dt,col_cf%hr(c)*dt
+            write(iulog,*)'ar                    = ',ar(c)*dt
+            write(iulog,*)'soilc_change          = ',soilc_change(c)*dt
+            write(iulog,*)'soilc_change_p        = ',soilc_change_p(c)*dt
             write(iulog,*)'fire                  = ',col_fire_closs(c)*dt
             write(iulog,*)'hrv_to_atm            = ',col_hrv_xsmrpool_to_atm(c)*dt
             write(iulog,*)'leach                 = ',som_c_leached(c)*dt
@@ -290,10 +307,14 @@
             if (use_pflotran .and. pf_cmode) then
                write(iulog,*)'pf_delta_decompc      = ',col_decompc_delta(c)*dt
             end if
-
-            call endrun(msg=errMsg(__FILE__, __LINE__))
+            if(.not.use_fun)then
+            !call endrun(msg=errMsg(__FILE__, __LINE__))
+            else 
+            write(iulog,*)'FUN ON! column cbalance error = ', col_errcb(c), c
+            end if
          end if
-      end if !use_fates
+       end if !use_fates
+      end if !use_fun
 
     end associate
 
@@ -332,6 +353,7 @@
          totcoln                   =>    col_ns%totcoln                  , & ! Input:  [real(r8) (:)]  (gN/m2) total column nitrogen, incl veg
          ndep_to_sminn             =>    col_nf%ndep_to_sminn             , & ! Input:  [real(r8) (:)]  atmospheric N deposition to soil mineral N (gN/m2/s)
          nfix_to_sminn             =>    col_nf%nfix_to_sminn             , & ! Input:  [real(r8) (:)]  symbiotic/asymbiotic N fixation to soil mineral N (gN/m2/s)
+         ffix_to_sminn             =>    col_nf%ffix_to_sminn             , & ! Input:  [real(r8) (:)]  free living N fixation to soil mineral N (gN/m2/s)
          nfix_to_ecosysn           =>    col_nf%nfix_to_ecosysn           , &
          fert_to_sminn             =>    col_nf%fert_to_sminn             , & ! Input:  [real(r8) (:)]
          soyfixn_to_sminn          =>    col_nf%soyfixn_to_sminn          , & ! Input:  [real(r8) (:)]
@@ -376,6 +398,10 @@
             col_ninputs(c) = ndep_to_sminn(c) + nfix_to_sminn(c) + supplement_to_sminn(c)
          end if
 
+         if(use_fun)then
+           col_ninputs(c) = col_ninputs(c) + ffix_to_sminn(c) !For FUN, free living fixation is a separate flux. RB.
+         endif
+
          if (crop_prog) col_ninputs(c) = col_ninputs(c) + &
               fert_to_sminn(c) + soyfixn_to_sminn(c)
 
@@ -441,12 +467,24 @@
             ! here is '-' adjustment. It says that the adding to PF decomp n pools was less.
          end if
 
-         if (abs(col_errnb(c)) > 1e-8_r8) then
+         if (abs(col_errnb(c)) > 1e-3_r8) then
+         !if (abs(col_errnb(c)) > 1e-1_r8) then
             err_found = .true.
             err_index = c
          end if
+
+       if(.not.use_fun)then
+         !if (abs(col_errnb(c)) > 1e-7_r8) then
+         if (abs(col_errnb(c)) > 1e-2_r8) then
+            write(iulog,*) 'nbalance warning',c,col_errnb(c),col_endnb(c)
+            write(iulog,*)'inputs,ffix,nfix,ndep = ',ffix_to_sminn(c)*dt,nfix_to_sminn(c)*dt,ndep_to_sminn(c)*dt
+            write(iulog,*)'outputs,lch,roff,dnit = ',smin_no3_leached(c)*dt, smin_no3_runoff(c)*dt,f_n2o_nit(c)*dt
+         end if
+       end if
+
       end do ! end of columns loop
 
+     if( .not. use_fun) then
       if (err_found) then
          c = err_index
          write(iulog,*)'column nbalance error = ',col_errnb(c), c, get_nstep()
@@ -464,6 +502,7 @@
          write(iulog,*)'ndep                  = ',ndep_to_sminn(c)*dt
          write(iulog,*)'nfix                  = ',nfix_to_sminn(c)*dt
          write(iulog,*)'nsup                  = ',supplement_to_sminn(c)*dt
+         write(iulog,*)'ffix                  = ',ffix_to_sminn(c)*dt
          if(crop_prog) then
             write(iulog,*)'fertm                 = ',fert_to_sminn(c)*dt
             write(iulog,*)'soyfx                 = ',soyfixn_to_sminn(c)*dt
@@ -477,10 +516,14 @@
          if (use_pflotran .and. pf_cmode) then
             write(iulog,*)'pf_delta_decompn      = ',col_decompn_delta(c)*dt
          end if
-         call endrun(msg=errMsg(__FILE__, __LINE__))
-
+         if(.not.use_fun)then
+           !call endrun(msg=errMsg(__FILE__, __LINE__))
+         else
+         write(iulog,*)'FUN ON! column nbalance error = ',col_errnb(c), c, get_nstep()
+         end if
 
       end if
+     end if !use
 
     end associate
 
@@ -652,13 +695,14 @@
          col_errpb(c) = (col_pinputs(c) - col_poutputs(c))*dt - &
               (col_endpb(c) - col_begpb(c))
 
-         if (abs(col_errpb(c)) > 1e-8_r8) then
+         !if (abs(col_errpb(c)) > 1e-3_r8) then
+         if (abs(col_errpb(c)) > 1e-1_r8) then
             err_found = .true.
             err_index = c
          end if
       end do ! end of columns loop
 
-
+     if( .not. use_funp) then
       if (err_found) then
          c = err_index
          write(iulog,*)'column pbalance error = ', col_errpb(c), c
@@ -673,8 +717,14 @@
             write(iulog,*)'SOP erosion = ',som_p_yield(c)*dt
             write(iulog,*)'SIP erosion = ',(labilep_yield(c)+secondp_yield(c)+occlp_yield(c)+primp_yield(c))*dt
          end if
-         call endrun(msg=errMsg(__FILE__, __LINE__))
+         if(.not.use_fun)then
+          !call endrun(msg=errMsg(__FILE__, __LINE__))
+         else
+          write(iulog,*)'FUNP ON!column pbalance error = ', col_errpb(c), c
+         end if
+         
       end if
+     end if !use_funp
 
     end associate
 
@@ -832,6 +882,7 @@
 
       end do
 
+     if(.not.use_funp)then
       if (err_found) then
          g = err_index
          write(iulog,*)'Grid cbalance error   = ',errcb_grc(g), g
@@ -844,6 +895,7 @@
          write(iulog,*)'delta store           = ',endcb_grc(g)-begcb_grc(g)
          call endrun(msg=errMsg(__FILE__, __LINE__))
       end if
+     end if !use_funp
 
     end associate
 
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/EcosystemDynMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/EcosystemDynMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/EcosystemDynMod.F90	2020-06-10 13:56:35.099391840 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/EcosystemDynMod.F90	2020-05-10 20:09:52.037087041 -0400
@@ -8,6 +8,7 @@
   use shr_kind_mod        , only : r8 => shr_kind_r8
   use shr_sys_mod         , only : shr_sys_flush
   use clm_varctl          , only : use_c13, use_c14, use_fates, use_dynroot
+  use clm_varctl          , only : use_fun
   use decompMod           , only : bounds_type
   use perf_mod            , only : t_startf, t_stopf
   use spmdMod             , only : masterproc
@@ -43,6 +44,7 @@
   use VegetationDataType  , only : veg_cf, c13_veg_cf, c14_veg_cf
   use VegetationDataType  , only : veg_ns, veg_nf
   use VegetationDataType  , only : veg_ps, veg_pf
+  use CNFUNMod            , only : CNFUNInit
   
   ! bgc interface & pflotran
   use clm_varctl          , only : use_clm_interface, use_clm_bgc, use_pflotran, pf_cmode, pf_hmode
@@ -269,6 +271,7 @@
   subroutine EcosystemDynNoLeaching1(bounds,                          &
        num_soilc, filter_soilc,                                         &
        num_soilp, filter_soilp,                                         &
+       num_pcropp, filter_pcropp, doalb,                                &
        cnstate_vars, carbonflux_vars, carbonstate_vars,                 &
        c13_carbonflux_vars,                                             &
        c14_carbonflux_vars,                                             &
@@ -290,11 +293,12 @@
     ! stays synchronized with albedo calculations.
     !
     ! !USES:
-    use NitrogenDynamicsMod         , only: NitrogenDeposition,NitrogenFixation, NitrogenFert, CNSoyfix
+    use clm_varpar                  , only:  nlevdecomp_full
+    use NitrogenDynamicsMod         , only: NitrogenDeposition,NitrogenFixation, NitrogenFert, CNSoyfix, FreeLivingFixation
     use PhosphorusDynamicsMod           , only: PhosphorusDeposition   
     use MaintenanceRespMod             , only: MaintenanceResp
 !    use SoilLittDecompMod            , only: SoilLittDecompAlloc
-!    use PhenologyMod         , only: Phenology
+    use PhenologyMod         , only: Phenology
 !    use GrowthRespMod             , only: GrowthResp
 !    use CarbonStateUpdate1Mod     , only: CarbonStateUpdate1,CarbonStateUpdate0
 !    use NitrogenStateUpdate1Mod     , only: NitrogenStateUpdate1
@@ -329,9 +333,9 @@
     integer                  , intent(in)    :: filter_soilc(:)   ! filter for soil columns
     integer                  , intent(in)    :: num_soilp         ! number of soil patches in filter
     integer                  , intent(in)    :: filter_soilp(:)   ! filter for soil patches
-!    integer                  , intent(in)    :: num_pcropp        ! number of prog. crop patches in filter
-!    integer                  , intent(in)    :: filter_pcropp(:)  ! filter for prognostic crop patches
-!    logical                  , intent(in)    :: doalb             ! true = surface albedo calculation time step
+    integer                  , intent(in)    :: num_pcropp        ! number of prog. crop patches in filter
+    integer                  , intent(in)    :: filter_pcropp(:)  ! filter for prognostic crop patches
+    logical                  , intent(in)    :: doalb             ! true = surface albedo calculation time step
     type(cnstate_type)       , intent(inout) :: cnstate_vars
     type(carbonflux_type)    , intent(inout) :: carbonflux_vars
     type(carbonstate_type)   , intent(inout) :: carbonstate_vars
@@ -347,7 +351,7 @@
     type(canopystate_type)   , intent(in)    :: canopystate_vars
     type(soilstate_type)     , intent(inout) :: soilstate_vars
     type(temperature_type)   , intent(inout) :: temperature_vars
-    type(crop_type)          , intent(in)    :: crop_vars
+    type(crop_type)          , intent(inout) :: crop_vars
     type(ch4_type)           , intent(in)    :: ch4_vars
     type(photosyns_type)     , intent(in)    :: photosyns_vars
 !    type(soilhydrology_type) , intent(in)    :: soilhydrology_vars
@@ -399,28 +403,40 @@
        call t_stopf('CNDeposition')
 
        if (.not. nu_com_nfix) then 
+
+        if(use_fun)then
+         call t_startf('CNFLivFixation')
+         call FreeLivingFixation( num_soilc, filter_soilc, &
+            waterflux_vars, carbonflux_vars, nitrogenflux_vars)
+         call t_stopf('CNFLivFixation')
+       else
           call t_startf('CNFixation')
           call NitrogenFixation( num_soilc, filter_soilc, &
                waterflux_vars, carbonflux_vars, nitrogenflux_vars)
           call t_stopf('CNFixation')
+       end if
        else
+
           ! nu_com_nfix is true
+ 
           call t_startf('CNFixation')
           call NitrogenFixation_balance( num_soilc, filter_soilc, &
                cnstate_vars, carbonflux_vars, nitrogenstate_vars, nitrogenflux_vars, &
                temperature_vars, waterstate_vars, carbonstate_vars, phosphorusstate_vars)
           call t_stopf('CNFixation')
+ 
        end if
 
        call t_startf('MaintenanceResp')
        if (crop_prog) then
           call NitrogenFert(bounds, num_soilc,filter_soilc, &
                nitrogenflux_vars)
-
+          if (.not. use_fun) then  ! if FUN is active, then soy fixation handled by FUN
           call CNSoyfix(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
                waterstate_vars, crop_vars, cnstate_vars, &
                nitrogenstate_vars, nitrogenflux_vars)
        end if
+      end if
        call MaintenanceResp(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
             canopystate_vars, soilstate_vars, temperature_vars, photosyns_vars, &
             carbonflux_vars, carbonstate_vars, nitrogenstate_vars)
@@ -473,6 +489,26 @@
        call decomp_vertprofiles(bounds,                      &
            num_soilc, filter_soilc, num_soilp, filter_soilp, &
            soilstate_vars, canopystate_vars, cnstate_vars)
+
+       if ( use_fun ) then
+          call t_startf('CNPhenology_phase1')
+          call Phenology(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            num_pcropp, filter_pcropp, doalb, atm2lnd_vars, &
+            waterstate_vars, temperature_vars, crop_vars, &
+            canopystate_vars, soilstate_vars, &
+            cnstate_vars, carbonstate_vars, carbonflux_vars, &
+            nitrogenstate_vars, nitrogenflux_vars,&
+            phosphorusstate_vars,phosphorusflux_vars, &
+            leaf_prof_patch=cnstate_vars%leaf_prof_patch(bounds%begp:bounds%endp,1:nlevdecomp_full), &
+            froot_prof_patch=cnstate_vars%froot_prof_patch(bounds%begp:bounds%endp,1:nlevdecomp_full), &
+            phase=1)
+          call t_stopf('CNPhenology_phase1')
+
+          call t_startf('CNFUNInit')
+          call CNFUNInit(bounds,cnstate_vars,carbonstate_vars, &
+            nitrogenstate_vars,phosphorusstate_vars)
+          call t_stopf('CNFUNInit')
+       end if
        !-------------------------------------------------------------------------------------------------
        ! Allocation1 is always called (w/ or w/o use_clm_interface)
        ! pflotran: call 'Allocation1' to obtain potential N demand for support initial GPP
@@ -518,6 +554,7 @@
 !    use NitrogenDynamicsMod         , only: NitrogenDeposition,NitrogenFixation, NitrogenFert, CNSoyfix
 !    use MaintenanceRespMod             , only: MaintenanceResp
 !    use SoilLittDecompMod            , only: SoilLittDecompAlloc
+    use clm_varpar                , only:  nlevdecomp_full
     use PhenologyMod         , only: Phenology, CNLitterToColumn
     use GrowthRespMod             , only: GrowthResp
     use CarbonStateUpdate1Mod     , only: CarbonStateUpdate1,CarbonStateUpdate0
@@ -529,6 +566,7 @@
     use PhosphorusStateUpdate2Mod       , only: PhosphorusStateUpdate2, PhosphorusStateUpdate2h
     use FireMod              , only: FireArea, FireFluxes
     use ErosionMod           , only: ErosionFluxes
+    use CNFUNMod             , only: CNFUNInit
     use CarbonStateUpdate3Mod     , only: CarbonStateUpdate3
     use CarbonIsoFluxMod          , only: CarbonIsoFlux1, CarbonIsoFlux2, CarbonIsoFlux2h, CarbonIsoFlux3
     use C14DecayMod          , only: C14Decay, C14BombSpike
@@ -598,7 +636,9 @@
                        cnstate_vars, ch4_vars,                      &
                        carbonstate_vars, carbonflux_vars,           &
                        nitrogenstate_vars, nitrogenflux_vars,       &
-                       phosphorusstate_vars,phosphorusflux_vars)
+                       phosphorusstate_vars,phosphorusflux_vars,    &
+                c13_carbonflux_vars, c14_carbonflux_vars, crop_vars, &
+                soilhydrology_vars, waterflux_vars)
        end if !if(.not.use_clm_interface)
        !----------------------------------------------------------------
        ! SoilLittDecompAlloc2 is called by both clm-bgc & pflotran
@@ -609,7 +649,8 @@
                 waterstate_vars, cnstate_vars, ch4_vars,                                        &
                 carbonstate_vars, carbonflux_vars, c13_carbonflux_vars, c14_carbonflux_vars,    &
                 nitrogenstate_vars, nitrogenflux_vars, crop_vars, atm2lnd_vars,                 &
-                phosphorusstate_vars,phosphorusflux_vars)
+                phosphorusstate_vars,phosphorusflux_vars, &
+       soilhydrology_vars, waterflux_vars)
 
        !----------------------------------------------------------------
        call t_stopf('SoilLittDecompAlloc')
@@ -624,13 +665,37 @@
        ! litterfall timestep in deciduous systems
 
        call t_startf('Phenology')
-       call Phenology(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+       if ( .not. use_fun ) then
+       call Phenology(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
+            num_pcropp, filter_pcropp, doalb, atm2lnd_vars, &
+            waterstate_vars, temperature_vars, crop_vars, canopystate_vars, soilstate_vars, &
+            cnstate_vars, carbonstate_vars, carbonflux_vars, &
+            nitrogenstate_vars, nitrogenflux_vars,&
+            phosphorusstate_vars,phosphorusflux_vars, &
+            leaf_prof_patch=cnstate_vars%leaf_prof_patch(bounds%begp:bounds%endp,1:nlevdecomp_full), &
+            froot_prof_patch=cnstate_vars%froot_prof_patch(bounds%begp:bounds%endp,1:nlevdecomp_full), &
+            phase=1)
+       end if
+       call Phenology(bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
             num_pcropp, filter_pcropp, doalb, atm2lnd_vars, &
             waterstate_vars, temperature_vars, crop_vars, canopystate_vars, soilstate_vars, &
             cnstate_vars, carbonstate_vars, carbonflux_vars, &
             nitrogenstate_vars, nitrogenflux_vars,&
-            phosphorusstate_vars,phosphorusflux_vars)
+            phosphorusstate_vars,phosphorusflux_vars, &
+            leaf_prof_patch=cnstate_vars%leaf_prof_patch(bounds%begp:bounds%endp,1:nlevdecomp_full), &
+            froot_prof_patch=cnstate_vars%froot_prof_patch(bounds%begp:bounds%endp,1:nlevdecomp_full), &
+            phase=2)
        call t_stopf('Phenology')
+       !call t_startf('Phenology')
+       !call Phenology(num_soilc, filter_soilc, num_soilp, filter_soilp, &
+       !     num_pcropp, filter_pcropp, doalb, atm2lnd_vars, &
+       !     waterstate_vars, temperature_vars, crop_vars, canopystate_vars, soilstate_vars, &
+       !     cnstate_vars, carbonstate_vars, carbonflux_vars, &
+       !     nitrogenstate_vars, nitrogenflux_vars,&
+       !     phosphorusstate_vars,phosphorusflux_vars)
+       !call t_stopf('Phenology')
+
+
 
        !--------------------------------------------
        ! Growth respiration
@@ -688,8 +753,12 @@
          call t_stopf('phenology_flux_limiter')
        endif
        call t_startf('CNLitterToColumn')
-       call CNLitterToColumn(num_soilc, filter_soilc, &
-         cnstate_vars, carbonflux_vars, nitrogenflux_vars,phosphorusflux_vars)
+        
+       call CNLitterToColumn(bounds, num_soilc, filter_soilc, &
+         cnstate_vars, carbonflux_vars, nitrogenflux_vars,phosphorusflux_vars, &
+           leaf_prof_patch=cnstate_vars%leaf_prof_patch(bounds%begp:bounds%endp,1:nlevdecomp_full), froot_prof_patch=cnstate_vars%froot_prof_patch(bounds%begp:bounds%endp,1:nlevdecomp_full))
+       !call CNLitterToColumn(num_soilc, filter_soilc, &
+       !  cnstate_vars, carbonflux_vars, nitrogenflux_vars,phosphorusflux_vars)
 
        call t_stopf('CNLitterToColumn')
        !--------------------------------------------
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/MaintenanceRespMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/MaintenanceRespMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/MaintenanceRespMod.F90	2020-06-10 13:56:35.120391734 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/MaintenanceRespMod.F90	2020-06-04 22:44:58.268014300 -0400
@@ -25,17 +25,21 @@
   use ColumnDataType      , only : col_es
   use VegetationType      , only : veg_pp                
   use VegetationDataType  , only : veg_es, veg_cs, veg_cf, veg_ns
+  use clm_varcon          , only : spval
+  use clm_varctl          , only : use_fun
   !
   implicit none
   save
   private
   !
   ! !PUBLIC MEMBER FUNCTIONS:
+  public :: MaintenanceRespReadNML       ! Read in namelist (CALL FIRST!)
   public :: MaintenanceResp
   public :: readMaintenanceRespParams
 
   type, private :: MaintenanceRespParamsType
      real(r8):: br_mr        !base rate for maintenance respiration(gC/gN/s)
+     real(r8):: br_root      ! base rate for maintenance respiration for roots (gC/gN/s)
   end type MaintenanceRespParamsType
 
   type(MaintenanceRespParamsType),private ::  MaintenanceRespParamsInst
@@ -44,6 +48,67 @@
 contains
 
   !-----------------------------------------------------------------------
+  subroutine MaintenanceRespReadNML( NLFilename )
+    !
+    ! !DESCRIPTION:
+    ! Read the namelist for CNMResp (MUST BE CALLED BEFORE readParams!!!)
+    !
+    ! !USES:
+    use fileutils      , only : getavu, relavu, opnfil
+    use shr_nl_mod     , only : shr_nl_find_group_name
+    use spmdMod        , only : masterproc, mpicom
+    use shr_mpi_mod    , only : shr_mpi_bcast
+    use clm_varctl     , only : iulog
+    !
+    ! !ARGUMENTS:
+    character(len=*), intent(in) :: NLFilename ! Namelist filename
+    !
+    ! !LOCAL VARIABLES:
+    integer :: ierr                 ! error code
+    integer :: unitn                ! unit for namelist file
+
+    character(len=*), parameter :: subname = 'MaintenanceRespReadNML'
+    character(len=*), parameter :: nmlname = 'cnmresp_inparm'
+    real(r8) :: br_root = spval ! base rate for maintenance respiration for roots (gC/gN/s)
+    !-----------------------------------------------------------------------
+
+    namelist /cnmresp_inparm/ br_root
+
+    ! Initialize options to default values, in case they are not specified in
+    ! the namelist
+
+    if (masterproc) then
+       unitn = getavu()
+       write(iulog,*) 'Read in '//nmlname//'  namelist'
+       call opnfil (NLFilename, unitn, 'F')
+       call shr_nl_find_group_name(unitn, nmlname, status=ierr)
+       if (ierr == 0) then
+          read(unitn, nml=cnmresp_inparm, iostat=ierr)
+          if (ierr /= 0) then
+             call endrun(msg="ERROR reading "//nmlname//"namelist"//errmsg(__FILE__, __LINE__))
+          end if
+       else
+          call endrun(msg="ERROR finding "//nmlname//"namelist"//errmsg(__FILE__, __LINE__))
+       end if
+       call relavu( unitn )
+    end if
+
+    call shr_mpi_bcast (br_root, mpicom)
+
+    MaintenanceRespParamsInst%br_root = br_root
+
+    if (masterproc) then
+       write(iulog,*) ' '
+       write(iulog,*) nmlname//' settings:'
+       write(iulog,nml=cnmresp_inparm)
+       write(iulog,*) ' '
+    end if
+
+  end subroutine MaintenanceRespReadNML
+  !-----------------------------------------------------------------------
+
+
+  !-----------------------------------------------------------------------
   subroutine readMaintenanceRespParams ( ncid )
     !
     ! !DESCRIPTION:
@@ -69,6 +134,10 @@
     if ( .not. readv ) call endrun(msg=trim(errCode)//trim(tString)//errMsg(__FILE__, __LINE__))
     MaintenanceRespParamsInst%br_mr=tempr
 
+    if ( MaintenanceRespParamsInst%br_root == spval ) then
+       MaintenanceRespParamsInst%br_root = MaintenanceRespParamsInst%br_mr
+    end if
+
   end subroutine readMaintenanceRespParams
 
   !-----------------------------------------------------------------------
@@ -80,6 +149,7 @@
        carbonflux_vars, carbonstate_vars, nitrogenstate_vars)
     !
     ! !DESCRIPTION:
+    use clm_varcon  , only : tfrz
     !
     ! !USES:
     !
@@ -102,6 +172,7 @@
     integer :: fp    ! soil filter patch index
     integer :: fc    ! soil filter column index
     real(r8):: br_mr ! base rate (gC/gN/s)
+    real(r8):: br_root ! root base rate (gC/gN/s)
     real(r8):: q10   ! temperature dependence
     real(r8):: tc    ! temperature correction, 2m air temp (unitless)
     real(r8):: tcsoi(bounds%begc:bounds%endc,nlevgrnd) ! temperature correction by soil layer (unitless)
@@ -119,10 +190,9 @@
 
          t_soisno       =>    col_es%t_soisno         , & ! Input:  [real(r8) (:,:) ]  soil temperature (Kelvin)  (-nlevsno+1:nlevgrnd)
          t_ref2m        =>    veg_es%t_ref2m          , & ! Input:  [real(r8) (:)   ]  2 m height surface air temperature (Kelvin)       
-
+         t10            =>    veg_es%t_a10            , & ! Input:  [real(r8) (:) ]  10-day running mean of the 2 m temperature (K)
          lmrsun         =>    photosyns_vars%lmrsun_patch           , & ! Input:  [real(r8) (:)   ]  sunlit leaf maintenance respiration rate (umol CO2/m**2/s)
          lmrsha         =>    photosyns_vars%lmrsha_patch           , & ! Input:  [real(r8) (:)   ]  shaded leaf maintenance respiration rate (umol CO2/m**2/s)
-
          cpool          =>    veg_cs%cpool          , & ! Input: [real(r8) (:)   ]   plant carbon pool (gC m-2)
 
          leaf_mr        =>    veg_cf%leaf_mr         , & ! Output: [real(r8) (:)   ]                                                    
@@ -145,6 +215,13 @@
       ! Conversion by molecular weights of C and N gives 2.525e-6 gC/(gN s)
       ! set constants
       br_mr = MaintenanceRespParamsInst%br_mr
+      !br_root = MaintenanceRespParamsInst%br_root
+
+      if(.not.use_fun)then
+         br_root = 1.1678e-06_r8
+      else
+         br_root = 2.525e-06_r8
+      end if
 
       ! Peter Thornton: 3/13/09 
       ! Q10 was originally set to 2.0, an arbitrary choice, but reduced to 1.5 as part of the tuning
@@ -175,6 +252,15 @@
 
          tc = Q10**((t_ref2m(p)-SHR_CONST_TKFRZ - 20.0_r8)/10.0_r8)
 
+         !RF: acclimation of root and stem respiration fluxes
+         ! n.b. we do not yet know if this is defensible scientifically (awaiting data analysis)
+         ! turning this on will increase R and decrease productivity in boreal forests, A LOT. :)
+
+         !if(use_fun)then 
+         !  br_mr   = br_mr   * 10._r8**(-0.00794_r8*((t10(p)-tfrz)-25._r8))
+         !  br_root = br_root * 10._r8**(-0.00794_r8*((t10(p)-tfrz)-25._r8))
+         !end if
+
          if (frac_veg_nosno(p) == 1) then
 
             leaf_mr(p) = lmrsun(p) * laisun(p) * 12.011e-6_r8 + &
@@ -188,7 +274,8 @@
 
          if (woody(ivt(p)) == 1) then
             livestem_mr(p) = livestemn(p)*br_mr*tc
-            livecroot_mr(p) = livecrootn(p)*br_mr*tc
+            livecroot_mr(p) = livecrootn(p)*br_root*tc
+            !livecroot_mr(p) = livecrootn(p)*br_mr*tc
          else if (ivt(p) >= npcropmin .and. livestemn(p) .gt. 0._r8) then
             livestem_mr(p) = livestemn(p)*br_mr*tc
             grain_mr(p) = grainn(p)*br_mr*tc
@@ -219,7 +306,12 @@
             ! to estimate the total fine root maintenance respiration as a
             ! function of temperature and N content.
 
-            froot_mr(p) = froot_mr(p) + frootn(p)*br_mr*tcsoi(c,j)*rootfr(p,j)
+            !if(use_fun)then
+            !   br_root = br_root * 10._r8**(-0.00794_r8*((t10(p)-tfrz)-25._r8))
+            !end if
+            froot_mr(p) = froot_mr(p) + frootn(p)*br_root*tcsoi(c,j)*rootfr(p,j)
+
+            !froot_mr(p) = froot_mr(p) + frootn(p)*br_mr*tcsoi(c,j)*rootfr(p,j)
          end do
       end do
 
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/NitrogenDynamicsMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/NitrogenDynamicsMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/NitrogenDynamicsMod.F90	2020-06-10 13:56:35.124391714 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/NitrogenDynamicsMod.F90	2020-06-03 16:05:12.656148700 -0400
@@ -11,7 +11,7 @@
   use shr_kind_mod        , only : r8 => shr_kind_r8
   use decompMod           , only : bounds_type
   use clm_varcon          , only : dzsoi_decomp, zisoi
-  use clm_varctl          , only : use_nitrif_denitrif, use_vertsoilc
+  use clm_varctl          , only : use_nitrif_denitrif, use_vertsoilc, use_fun
   use subgridAveMod       , only : p2c
   use atm2lndType         , only : atm2lnd_type
   use CNCarbonFluxType    , only : carbonflux_type
@@ -30,7 +30,7 @@
   use CNCarbonStateType   , only : carbonstate_type
   use TemperatureType     , only : temperature_type
   use PhosphorusStateType , only : phosphorusstate_type
-  use clm_varctl          , only : NFIX_PTASE_plant
+  use clm_varctl          , only : NFIX_PTASE_plant, iulog
  
   !
   implicit none
@@ -40,6 +40,7 @@
   ! !PUBLIC MEMBER FUNCTIONS:
   public :: NitrogenDynamicsInit
   public :: NitrogenDeposition
+  public :: FreeLivingFixation
   public :: NitrogenFixation
   public :: NitrogenLeaching
   public :: NitrogenFert
@@ -150,6 +151,61 @@
     end associate
 
   end subroutine NitrogenDeposition
+  !-----------------------------------------------------------------------
+  subroutine FreeLivingFixation(num_soilc, filter_soilc, waterflux_vars, &
+       carbonflux_vars, nitrogenflux_vars)
+
+   ! !USES:
+    use clm_time_manager , only : get_days_per_year, get_step_size
+    use shr_sys_mod      , only : shr_sys_flush
+    use clm_varcon       , only : secspday, spval
+    !
+    ! !ARGUMENTS:
+    integer                 , intent(in)    :: num_soilc       ! number of soil columns in filter
+    integer                 , intent(in)    :: filter_soilc(:) ! filter for soil columns
+    type(waterflux_type)     , intent(in)    :: waterflux_vars    
+    type(carbonflux_type)   , intent(inout) :: carbonflux_vars
+    type(nitrogenflux_type) , intent(inout) :: nitrogenflux_vars 
+    !
+                                                                                                                             
+    !type(soilbiogeochem_nitrogenflux_type) , intent(inout) :: soilbiogeochem_nitrogenflux_inst 
+    !type(waterflux_type)                   , intent(inout) :: waterflux_inst 
+    !
+    ! !LOCAL VARIABLES:                                                                                                                                                                                                           
+    integer  :: c,fc            !indices     
+    real(r8) :: dayspyr         !days per year 
+    real(r8) :: secs_per_year   !seconds per year   
+    real(r8) :: freelivfix_slope, freelivfix_inter ! From Cleveland et al. (1999)
+       associate(                                                                        &
+                  !qflx_tran_veg  => col_wf%qflx_tran_veg    , & ! col vegetation transpiration (mm H2O/s) (+ = to atm)
+
+                  qflx_evap_tot  => col_wf%qflx_evap_tot    , &
+                  AnnET          => col_wf%AnnET            , & ! Input:  [real(:)  ] : Annual average ET flux mmH20/s
+!                  freelivfix_slope => params_inst%freelivfix_slope_wET,                  & ! Input:  [real     ] : slope of fixation with ET
+!                  freelivfix_inter => params_inst%freelivfix_intercept,                  & ! Input:  [real     ] : intercept of fixation with ET
+!                  ffix_to_sminn    => soilbiogeochem_nitrogenflux_inst%ffix_to_sminn_col & ! Output: [real(:)  ] : free living N fixation to soil mineral N (gN/m2/s)
+                  ffix_to_sminn    =>                    col_nf%ffix_to_sminn                               & ! Output: [real(r8) (:)]  free living N fixation to soil mineral N (gN/m2/s)
+                ) 
+ 
+    
+       dayspyr = get_days_per_year()
+       secs_per_year = dayspyr*24_r8*3600_r8
+
+       freelivfix_slope = 6.0e-4_r8
+       freelivfix_inter = 1.17e-2_r8
+
+       do fc = 1,num_soilc
+           c = filter_soilc(fc)
+          ffix_to_sminn(c) = (freelivfix_slope*(max(0._r8,AnnET(c))*secs_per_year) + freelivfix_inter )/secs_per_year !(units g N m-2 s-1)  
+          !ffix_to_sminn(c) = (freelivfix_slope*(max(0._r8,qflx_evap_tot(c))*secs_per_year) + freelivfix_inter )/secs_per_year !(units g N m-2 s-1)
+          !ffix_to_sminn(c) = 0._r8
+
+       end do
+
+  end associate
+  end subroutine FreeLivingFixation
+
+  !-----------------------------------------------------------------------
 
   !-----------------------------------------------------------------------
   subroutine NitrogenFixation(num_soilc, filter_soilc, waterflux_vars, &
@@ -209,6 +265,7 @@
                
                if (col_lag_npp(c) /= spval) then
                   ! need to put npp in units of gC/m^2/year here first
+                   
                   t = (1.8_r8 * (1._r8 - exp(-0.003_r8 * col_lag_npp(c)*(secspday * dayspyr))))/(secspday * dayspyr)  
                   nfix_to_sminn(c) = max(0._r8,t)
                else
@@ -226,6 +283,10 @@
          endif
       endif
 
+      if(use_fun)then
+        nfix_to_sminn(c) = 0.0_r8
+      end if
+
     end associate
 
   end subroutine NitrogenFixation
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/NitrogenStateUpdate1Mod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/NitrogenStateUpdate1Mod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/NitrogenStateUpdate1Mod.F90	2020-06-10 13:56:35.126391704 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/NitrogenStateUpdate1Mod.F90	2020-05-10 20:09:52.056086930 -0400
@@ -8,7 +8,7 @@
   use clm_time_manager       , only : get_step_size
   use clm_varpar             , only : nlevdecomp, ndecomp_pools, ndecomp_cascade_transitions
   use clm_varpar             , only : crop_prog, i_met_lit, i_cel_lit, i_lig_lit, i_cwd
-  use clm_varctl             , only : iulog, use_nitrif_denitrif
+  use clm_varctl             , only : iulog, use_nitrif_denitrif, use_fun
   use clm_varcon             , only : nitrif_n2o_loss_frac
   use pftvarcon              , only : npcropmin, nc3crop
   use VegetationPropertiesType         , only : veg_vp
@@ -55,6 +55,7 @@
     type(bounds_type)        , intent(in)    :: bounds
     integer                  , intent(in)    :: num_soilc_with_inactive       ! number of columns in soil filter
     integer                  , intent(in)    :: filter_soilc_with_inactive(:) ! soil column filter that includes inactive points
+
     !
     ! !LOCAL VARIABLES:
     integer                                  :: c                             ! column index
@@ -66,6 +67,8 @@
     character(len=*)         , parameter     :: subname = 'NitrogenStateUpdateDynPatch'
     !-----------------------------------------------------------------------
 
+    
+
       dt = real( get_step_size(), r8 )
 
       if (.not.use_fates) then
@@ -99,6 +102,8 @@
          end do
       end if
 
+
+
   end subroutine NitrogenStateUpdateDynPatch
 
   !-----------------------------------------------------------------------
@@ -156,7 +161,11 @@
          do j = 1, nlevdecomp
             do fc = 1,num_soilc
                c = filter_soilc(fc)
-               
+                if(use_fun)then !RF in FUN logic, the fixed N goes straight into the plant, and not into the SMINN pool. 
+ 	               ! N deposition and fixation (put all into NH4 pool)
+	               col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_nf%ndep_to_sminn(c)*dt * ndep_prof(c,j)
+	               col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) + col_nf%ffix_to_sminn(c)*dt * nfixation_prof(c,j)
+	       else 
                if (.not. use_nitrif_denitrif) then
                   
                   ! N deposition and fixation
@@ -171,6 +180,8 @@
                   
                end if
 
+            end if !use_fun
+
                ! plant to litter fluxes
                ! phenology and dynamic landcover fluxes
                col_nf%decomp_npools_sourcesink(c,j,i_met_lit) = &
@@ -284,8 +295,13 @@
                   ! "bulk denitrification"
                   col_ns%sminn_vr(c,j) = col_ns%sminn_vr(c,j) - col_nf%sminn_to_denit_excess_vr(c,j) * dt
                   
-                  ! total plant uptake from mineral N
+
+               ! total plant uptake from mineral N
+               if ( .not. use_fun ) then
                   col_ns%sminn_vr(c,j) = col_ns%sminn_vr(c,j) - col_nf%sminn_to_plant_vr(c,j)*dt
+               else
+                  col_ns%sminn_vr(c,j) = col_ns%sminn_vr(c,j) - col_nf%sminn_to_plant_fun_vr(c,j)*dt
+               end if
                   
                   ! flux that prevents N limitation (when Carbon_only is set)
                   col_ns%sminn_vr(c,j) = col_ns%sminn_vr(c,j) + col_nf%supplement_to_sminn_vr(c,j)*dt
@@ -312,9 +328,16 @@
                   col_ns%smin_no3_vr(c,j) = col_ns%smin_no3_vr(c,j) - col_nf%actual_immob_no3_vr(c,j)*dt
                   
                   ! plant uptake fluxes
+                  if ( .not. use_fun )then
                   col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) - col_nf%smin_nh4_to_plant_vr(c,j)*dt
                   
                   col_ns%smin_no3_vr(c,j) = col_ns%smin_no3_vr(c,j) - col_nf%smin_no3_to_plant_vr(c,j)*dt
+
+                  else 
+                  col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) -  col_nf%sminn_to_plant_fun_nh4_vr(c,j)*dt
+
+                  col_ns%smin_no3_vr(c,j) = col_ns%smin_no3_vr(c,j) -  col_nf%sminn_to_plant_fun_no3_vr(c,j)*dt
+                  end if
                   
                   ! Account for nitrification fluxes
                   col_ns%smin_nh4_vr(c,j) = col_ns%smin_nh4_vr(c,j) - col_nf%f_nit_vr(c,j) * dt
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/PhenologyMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/PhenologyMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/PhenologyMod.F90	2020-06-10 13:56:35.136391654 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/PhenologyMod.F90	2020-05-10 20:09:52.164086300 -0400
@@ -1,4 +1,6 @@
 module PhenologyMod
+
+#include "shr_assert.h"
   !-----------------------------------------------------------------------
   ! !MODULE: PhenologyMod.F90
   !
@@ -13,7 +15,7 @@
   use shr_log_mod         , only : errMsg => shr_log_errMsg
   use shr_sys_mod         , only : shr_sys_flush
   use decompMod           , only : bounds_type
-  use clm_varpar          , only : numpft
+  use clm_varpar          , only : numpft, nlevdecomp_full
   use clm_varctl          , only : iulog
   use clm_varcon          , only : tfrz
   use abortutils          , only : endrun
@@ -31,7 +33,7 @@
   use WaterstateType      , only : waterstate_type
   use PhosphorusFluxType  , only : phosphorusflux_type
   use PhosphorusStateType , only : phosphorusstate_type
-  use clm_varctl          , only : nu_com 
+  use clm_varctl          , only : nu_com, use_fun, use_funp
   use ColumnType          , only : col_pp
   use ColumnDataType      , only : col_es, col_ws, col_cf, col_nf, col_pf 
   use TopounitDataType    , only : top_af, top_as  
@@ -40,6 +42,7 @@
   use VegetationDataType  , only : veg_es, veg_ef, veg_cs, veg_cf, veg_ns, veg_nf
   use VegetationDataType  , only : veg_ps, veg_pf
   
+  
   !
   implicit none
   save
@@ -203,15 +206,19 @@
   end subroutine readPhenolParams
 
   !-----------------------------------------------------------------------
-  subroutine Phenology (num_soilc, filter_soilc, num_soilp, filter_soilp, &
+  subroutine Phenology (bounds, num_soilc, filter_soilc, num_soilp, filter_soilp, &
        num_pcropp, filter_pcropp, doalb, atm2lnd_vars, &
        waterstate_vars, temperature_vars, crop_vars, canopystate_vars, soilstate_vars, &
        cnstate_vars, carbonstate_vars, carbonflux_vars, &
-       nitrogenstate_vars,nitrogenflux_vars,phosphorusstate_vars,phosphorusflux_vars)
+       nitrogenstate_vars,nitrogenflux_vars,phosphorusstate_vars,phosphorusflux_vars, &
+       leaf_prof_patch, froot_prof_patch, phase)
     !
     ! !DESCRIPTION:
     ! Dynamic phenology routine for coupled carbon-nitrogen code (CN)
     ! 1. grass phenology
+
+    use decompMod            , only : bounds_type
+    use clm_varpar           , only : nlevdecomp_full 
     !
     ! !ARGUMENTS:
     integer                  , intent(in)    :: num_soilc       ! number of soil columns in filter
@@ -235,11 +242,30 @@
 
     type(phosphorusstate_type) , intent(inout) :: phosphorusstate_vars
     type(phosphorusflux_type)  , intent(inout) :: phosphorusflux_vars
+
+    type(bounds_type), intent(in)    :: bounds
+    real(r8)         , intent(in)    :: leaf_prof_patch(bounds%begp:,1:)
+    real(r8)         , intent(in)    :: froot_prof_patch(bounds%begp:,1:)
+    integer          , intent(in)    :: phase
+
+    integer  :: begp, endp
     !-----------------------------------------------------------------------
 
+    begp = bounds%begp
+    endp = bounds%endp
+
+    SHR_ASSERT_ALL((ubound(leaf_prof_patch)   == (/endp,nlevdecomp_full/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(froot_prof_patch)  == (/endp,nlevdecomp_full/)), errMsg(__FILE__, __LINE__))
+
+
+
+
+
     ! each of the following phenology type routines includes a filter
     ! to operate only on the relevant patches
 
+    if ( phase == 1 ) then
+
     call PhenologyClimate(num_soilp, filter_soilp, num_pcropp, filter_pcropp, &
          temperature_vars, cnstate_vars, crop_vars)
 
@@ -268,6 +294,8 @@
             phosphorusstate_vars,phosphorusflux_vars)
     end if
 
+    else if ( phase == 2 ) then
+
     ! the same onset and offset routines are called regardless of
     ! phenology type - they depend only on onset_flag, offset_flag, bglfr, and bgtr
 
@@ -297,6 +325,15 @@
 
     ! gather all patch-level litterfall fluxes to the column for litter C and N inputs
 
+    call CNLitterToColumn(bounds, num_soilc, filter_soilc, &
+            cnstate_vars, carbonflux_vars, nitrogenflux_vars, &
+            phosphorusflux_vars, &
+            leaf_prof_patch(bounds%begp:bounds%endp,1:nlevdecomp_full), & 
+            froot_prof_patch(bounds%begp:bounds%endp,1:nlevdecomp_full))
+    else
+       call endrun( 'bad phase' )
+    end if
+
   end subroutine Phenology
 
   !-----------------------------------------------------------------------
@@ -2591,6 +2628,9 @@
     integer :: p, c         ! indices
     integer :: fp           ! lake filter pft index
     real(r8):: t1           ! temporary variable
+    real(r8):: denom        ! temporary variable for divisor
+    real(r8) :: fr_leafn_to_litter ! fraction of the nitrogen turnover that goes to litter; remaining fraction is retranslocated
+    real(r8) :: fr_leafp_to_litter ! fraction of the phosphorus turnover that goes to litter; remaining fraction is retranslocated
     !-----------------------------------------------------------------------
 
     associate(                                                                     & 
@@ -2661,7 +2701,15 @@
          hrv_leafn_to_prod1n   =>    veg_nf%hrv_leafn_to_prod1n     , & ! Input:  [real(r8) (:)] crop leafn harvested
          hrv_livestemn_to_prod1n  => veg_nf%hrv_livestemn_to_prod1n , & ! Input:  [real(r8) (:)] crop stemn harvested
          hrv_leafp_to_prod1p   =>    veg_pf%hrv_leafp_to_prod1p   , & ! Input:  [real(r8) (:)] crop leafp harvested
-         hrv_livestemp_to_prod1p  => veg_pf%hrv_livestemp_to_prod1p & ! Input:  [real(r8) (:)] crop stemp harvested
+         hrv_livestemp_to_prod1p  => veg_pf%hrv_livestemp_to_prod1p ,& ! Input:  [real(r8) (:)] crop stemp harvested
+         leafc_to_litter_fun   => veg_cf%leafc_to_litter_fun  , & ! Output:  [real(r8) (:) ] leaf C litterfall used by FUN (gC/m2/s)
+         leafc_to_litter_funp  => veg_cf%leafc_to_litter_funp  , & ! Output:  [real(r8) (:) ] leaf C litterfall used by FUN-P (gC/m2/s)
+         leafcn_offset         => cnstate_vars%leafcn_offset_patch           , & ! Output:  [real(r8) (:) ] Leaf C:N used by FUN
+         free_retransn_to_npool =>    veg_nf%free_retransn_to_npool  , & ! Input: [real(r8) (:) ] free leaf N to retranslocated N pool (gN/m2/s)           
+         paid_retransn_to_npool =>    veg_nf%retransn_to_npool   ,& ! Input: [real(r8) (:) ] free leaf N to retranslocated N pool (gN/m2/s)
+         leafcp_offset         => cnstate_vars%leafcp_offset_patch           , & ! Output:  [real(r8) (:) ] Leaf C:P used by FUN
+         free_retransp_to_ppool =>    veg_pf%free_retransp_to_ppool  , & ! Input: [real(r8) (:) ] free leaf N to retranslocated N pool (gN/m2/s)          
+         paid_retransp_to_ppool =>    veg_pf%retransp_to_ppool   & ! Input: [real(r8) (:) ] free leaf N to retranslocated N pool (gN/m2/s)
          )
 
       ! The litterfall transfer rate starts at 0.0 and increases linearly
@@ -2691,7 +2739,22 @@
                frootc_to_litter(p) = prev_frootc_to_litter(p) + t1*(frootc(p) - prev_frootc_to_litter(p)*offset_counter(p))
             end if
 
+            if ( use_fun ) then
+               if(leafc_to_litter(p)*dt.gt.leafc(p))then
+                   leafc_to_litter(p) = leafc(p)/dt + cpool_to_leafc(p)
+               endif
+               if(frootc_to_litter(p)*dt.gt.frootc(p))then
+                   frootc_to_litter(p) = frootc(p)/dt + cpool_to_frootc(p)
+               endif
+            end if
+
+
+
+
             if ( nu_com .eq. 'RD') then
+
+
+
                if (ivt(p) >= npcropmin) then
                   if (offset_counter(p) == dt) then
                       t1 = 1.0_r8 / dt
@@ -2709,19 +2772,89 @@
                      livestemp_to_litter(p) = (t1 * livestemp(p) + ppool_to_livestemp(p)) - hrv_livestemp_to_prod1p(p)
                   end if
                else
+                
+               if ( use_fun ) then
+               leafc_to_litter_fun(p)      =  leafc_to_litter(p)
+               leafn_to_retransn(p)        =  paid_retransn_to_npool(p) + free_retransn_to_npool(p)
+               if (leafn(p).gt.0._r8) then
+                  if (leafn(p)-leafn_to_retransn(p)*dt.gt.0._r8) then
+                      leafcn_offset(p)     =  leafc(p)/(leafn(p)-leafn_to_retransn(p)*dt)
+                  else
+                      leafcn_offset(p)     =  leafc(p)/leafn(p)
+                  end if
+               else
+                  leafcn_offset(p)         =  leafcn(ivt(p))
+               end if
+               leafn_to_litter(p)          =  leafc_to_litter(p)/leafcn_offset(p) - leafn_to_retransn(p)
+               leafn_to_litter(p)          =  max(leafn_to_litter(p),0._r8)
+               
+               denom = ( leafn_to_retransn(p) + leafn_to_litter(p) )
+               if ( denom /= 0.0_r8 ) then
+                  fr_leafn_to_litter =  leafn_to_litter(p) / ( leafn_to_retransn(p) + leafn_to_litter(p) )
+               else if ( leafn_to_litter(p) == 0.0_r8 ) then
+                  fr_leafn_to_litter =  0.0_r8
+               else
+                  fr_leafn_to_litter =  1.0_r8
+               end if
+
+            else
+
                   ! calculate the leaf N litterfall and retranslocation
                   leafn_to_litter(p)   = leafc_to_litter(p)  / lflitcn(ivt(p))
                   leafn_to_retransn(p) = (leafc_to_litter(p) / leafcn(ivt(p))) - leafn_to_litter(p)
 
+            end if
+
                   ! calculate fine root N litterfall (no retranslocation of fine root N)
                   frootn_to_litter(p) = frootc_to_litter(p) / frootcn(ivt(p))
 
+           if ( use_fun ) then
+               if(frootn_to_litter(p)*dt.gt.frootn(p))then
+                   frootn_to_litter(p) = frootn(p)/dt
+               endif    
+            end if
+
+             if ( use_funp ) then
+               leafc_to_litter_funp(p)     =  leafc_to_litter(p)
+               leafp_to_retransp(p)        =  paid_retransp_to_ppool(p) + free_retransp_to_ppool(p)
+               if (leafp(p).gt.0._r8) then
+                  if (leafp(p)-leafp_to_retransp(p)*dt.gt.0._r8) then
+                      leafcp_offset(p)     =  leafc(p)/(leafp(p)-leafp_to_retransp(p)*dt)
+                  else
+                      leafcp_offset(p)     =  leafc(p)/leafp(p)
+                  end if
+               else
+                  leafcp_offset(p)         =  leafcp(ivt(p))
+               end if
+               leafp_to_litter(p)          =  leafc_to_litter(p)/leafcp_offset(p) - leafp_to_retransp(p)
+               leafp_to_litter(p)          =  max(leafp_to_litter(p),0._r8)
+               
+               denom = ( leafp_to_retransp(p) + leafp_to_litter(p) )
+               if ( denom /= 0.0_r8 ) then
+                  fr_leafp_to_litter =  leafp_to_litter(p) / ( leafp_to_retransp(p) + leafp_to_litter(p) )
+               else if ( leafp_to_litter(p) == 0.0_r8 ) then
+                  fr_leafp_to_litter =  0.0_r8
+               else
+                  fr_leafp_to_litter =  1.0_r8
+               end if
+
+            else
+
                   ! calculate the leaf P litterfall and retranslocation
                   leafp_to_litter(p)   = leafc_to_litter(p)  / lflitcp(ivt(p))
                   leafp_to_retransp(p) = (leafc_to_litter(p) / leafcp(ivt(p))) - leafp_to_litter(p)
 
+            end if
+
                   ! calculate fine root P litterfall (no retranslocation of fine root N)
                   frootp_to_litter(p) = frootc_to_litter(p) / frootcp(ivt(p))
+
+            if ( use_funp ) then
+               if(frootp_to_litter(p)*dt.gt.frootp(p))then
+                   frootp_to_litter(p) = frootp(p)/dt
+               endif    
+            end if
+
                end if 
             else
                if (offset_counter(p) == dt) then
@@ -2793,6 +2926,9 @@
     ! !LOCAL VARIABLES:
     integer :: p            ! indices
     integer :: fp           ! lake filter pft index
+    real(r8):: denom        ! temporary variable for divisor
+    real(r8) :: fr_leafn_to_litter ! fraction of the nitrogen turnover that goes to litter; remaining fraction is retranslocated
+    real(r8) :: fr_leafp_to_litter ! fraction of the phosphorus turnover that goes to litter; remaining fraction is retranslocated
     !-----------------------------------------------------------------------
 
     associate(                                                               & 
@@ -2826,7 +2962,16 @@
          leafn             =>    veg_ns%leafn              , &
          frootn            =>    veg_ns%frootn             , &
          leafp             =>    veg_ps%leafp            , &
-         frootp            =>    veg_ps%frootp             &
+         frootp            =>    veg_ps%frootp           ,  &
+
+         leafc_to_litter_fun   => veg_cf%leafc_to_litter_fun, & ! Output:  [real(r8) (:) ] leaf C litterfall used by FUN (gC/m2/s)
+         leafc_to_litter_funp  => veg_cf%leafc_to_litter_funp, & ! Output:  [real(r8) (:) ] leaf C litterfall used by FUN-P (gC/m2/s)
+         leafcn_offset         => cnstate_vars%leafcn_offset_patch           , & ! Output:  [real(r8) (:) ] Leaf C:N used by FUN
+         free_retransn_to_npool=>    veg_nf%free_retransn_to_npool  , & ! Input: [real(r8) (:) ] free leaf N to retranslocated N pool (gN/m2/s)          
+         paid_retransn_to_npool=>    veg_nf%retransn_to_npool   ,& ! Input: [real(r8) (:) ] free leaf N to retranslocated N pool (gN/m2/s)
+         leafcp_offset         => cnstate_vars%leafcp_offset_patch           , & ! Output:  [real(r8) (:) ] Leaf C:P used by FUN
+         free_retransp_to_ppool=>    veg_pf%free_retransp_to_ppool  , & ! Input: [real(r8) (:) ] free leaf N to retranslocated N pool (gN/m2/s)          
+         paid_retransp_to_ppool=>    veg_pf%retransp_to_ppool   & ! Input: [real(r8) (:) ] free leaf N to retranslocated N pool (gN/m2/s)
          )
 
       ! patch loop
@@ -2840,19 +2985,88 @@
             frootc_to_litter(p) = bglfr_froot(p) * frootc(p)
 
             if ( nu_com .eq. 'RD') then
+
+            if ( use_fun ) then
+               leafc_to_litter_fun(p)     = leafc_to_litter(p)
+               leafn_to_retransn(p)       = paid_retransn_to_npool(p) + free_retransn_to_npool(p)
+               if (leafn(p).gt.0._r8) then
+                  if (leafn(p)-leafn_to_retransn(p)*dt.gt.0._r8) then
+                     leafcn_offset(p)     = leafc(p)/(leafn(p)-leafn_to_retransn(p)*dt)
+                  else
+                     leafcn_offset(p)     = leafc(p)/leafn(p)
+                  end if
+               else
+                  leafcn_offset(p)        = leafcn(ivt(p))
+               end if
+               leafn_to_litter(p)         = leafc_to_litter(p)/leafcn_offset(p) - leafn_to_retransn(p)
+               leafn_to_litter(p)         = max(leafn_to_litter(p),0._r8)
+
+               denom = ( leafn_to_retransn(p) + leafn_to_litter(p) )
+               if ( denom /= 0.0_r8 ) then
+                  fr_leafn_to_litter =  leafn_to_litter(p) / ( leafn_to_retransn(p) + leafn_to_litter(p) )
+               else if ( leafn_to_litter(p) == 0.0_r8 ) then
+                  fr_leafn_to_litter =  0.0_r8
+               else
+                  fr_leafn_to_litter =  1.0_r8
+               end if
+
+
+            else
                ! calculate the leaf N litterfall and retranslocation
                leafn_to_litter(p)   = leafc_to_litter(p)  / lflitcn(ivt(p))
                leafn_to_retransn(p) = (leafc_to_litter(p) / leafcn(ivt(p))) - leafn_to_litter(p)
 
+            end if
+
                ! calculate fine root N litterfall (no retranslocation of fine root N)
                frootn_to_litter(p) = frootc_to_litter(p) / frootcn(ivt(p))
 
+            if ( use_fun ) then
+               if(frootn_to_litter(p)*dt.gt.frootn(p))then
+                    frootn_to_litter(p) = frootn(p)/dt
+               endif
+            end if
+
+            if ( use_funp ) then
+               leafc_to_litter_funp(p)    = leafc_to_litter(p)
+               leafp_to_retransp(p)       = paid_retransp_to_ppool(p) + free_retransp_to_ppool(p)
+               if (leafp(p).gt.0._r8) then
+                  if (leafp(p)-leafp_to_retransp(p)*dt.gt.0._r8) then
+                     leafcp_offset(p)     = leafc(p)/(leafp(p)-leafp_to_retransp(p)*dt)
+                  else
+                     leafcp_offset(p)     = leafc(p)/leafp(p)
+                  end if
+               else
+                  leafcp_offset(p)        = leafcp(ivt(p))
+               end if
+               leafp_to_litter(p)         = leafc_to_litter(p)/leafcp_offset(p) - leafp_to_retransp(p)
+               leafp_to_litter(p)         = max(leafp_to_litter(p),0._r8)
+
+               denom = ( leafp_to_retransp(p) + leafp_to_litter(p) )
+               if ( denom /= 0.0_r8 ) then
+                  fr_leafp_to_litter =  leafp_to_litter(p) / ( leafp_to_retransp(p) + leafp_to_litter(p) )
+               else if ( leafp_to_litter(p) == 0.0_r8 ) then
+                  fr_leafp_to_litter =  0.0_r8
+               else
+                  fr_leafp_to_litter =  1.0_r8
+               end if
+            else
+
                ! calculate the leaf P litterfall and retranslocation
                leafp_to_litter(p)   = leafc_to_litter(p)  / lflitcp(ivt(p))
                leafp_to_retransp(p) = (leafc_to_litter(p) / leafcp(ivt(p))) - leafp_to_litter(p)
 
+             end if
+
                ! calculate fine root P litterfall (no retranslocation of fine root P)
                frootp_to_litter(p) = frootc_to_litter(p) / frootcp(ivt(p))
+
+            if ( use_funp ) then
+               if(frootp_to_litter(p)*dt.gt.frootp(p))then
+                    frootp_to_litter(p) = frootp(p)/dt
+               endif
+            end if
+
             else
                ! calculate the leaf N litterfall and retranslocation
                leafn_to_litter(p)   = bglfr_leaf(p) * leafn(p) * 0.38_r8 ! 62% N resorption rate; LEONARDUS VERGUTZ 2012 Ecological Monographs 82(2) 205-220.
@@ -2991,6 +3205,20 @@
 
                livecrootp_to_deadcrootp(p) = ptovr *  livewdcp(ivt(p))/deadwdcp(ivt(p)) ! P retranslocation
                livecrootp_to_retransp(p)  = ptovr - livecrootp_to_deadcrootp(p)
+
+            if(use_fun)then
+               !TURNED OFF FLUXES TO CORRECT N ACCUMULATION ISSUE. RF. Oct 2015. 
+               livecrootn_to_retransn(p) = 0.0_r8
+               livestemn_to_retransn(p)  = 0.0_r8
+            endif
+
+            if(use_funp)then
+               !TURNED OFF FLUXES TO CORRECT P ACCUMULATION ISSUE. RB. Apr 2020. 
+               livecrootp_to_retransp(p) = 0.0_r8
+               livestemp_to_retransp(p)  = 0.0_r8
+            endif
+
+
             end if
 
          end if
@@ -3002,8 +3230,9 @@
   end subroutine CNLivewoodTurnover
 
   !-----------------------------------------------------------------------
-  subroutine CNLitterToColumn (num_soilc, filter_soilc, &
-       cnstate_vars, carbonflux_vars, nitrogenflux_vars,phosphorusflux_vars)
+  subroutine CNLitterToColumn (bounds, num_soilc, filter_soilc, &
+       cnstate_vars, carbonflux_vars, nitrogenflux_vars,phosphorusflux_vars, &
+           leaf_prof_patch, froot_prof_patch)
     !
     ! !DESCRIPTION:
     ! called at the end of cn_phenology to gather all pft-level litterfall fluxes
@@ -3011,7 +3240,9 @@
     !
     ! !USES:
     use clm_varpar , only : max_patch_per_col, nlevdecomp
+    use clm_varpar , only : nlevdecomp_full
     use pftvarcon  , only : npcropmin
+    use decompMod  , only : bounds_type
     !
     ! !ARGUMENTS:
     integer                 , intent(in)    :: num_soilc       ! number of soil columns in filter
@@ -3020,11 +3251,21 @@
     type(carbonflux_type)   , intent(inout) :: carbonflux_vars
     type(nitrogenflux_type) , intent(inout) :: nitrogenflux_vars
     type(phosphorusflux_type) , intent(inout) :: phosphorusflux_vars
+    type(bounds_type)        , intent(in) :: bounds
+    real(r8)                        , intent(in)    :: leaf_prof_patch(bounds%begp:,1:)
+    real(r8)                        , intent(in)    :: froot_prof_patch(bounds%begp:,1:)
     !
     ! !LOCAL VARIABLES:
     integer :: fc,c,pi,p,j       ! indices
     !-----------------------------------------------------------------------
+    integer  :: begp, endp
+    !-----------------------------------------------------------------------
+
+    begp = bounds%begp
+    endp = bounds%endp
 
+    SHR_ASSERT_ALL((ubound(leaf_prof_patch)   == (/endp,nlevdecomp_full/)), errMsg(__FILE__, __LINE__))
+    SHR_ASSERT_ALL((ubound(froot_prof_patch)  == (/endp,nlevdecomp_full/)), errMsg(__FILE__, __LINE__))
     associate(                                                                                       & 
          ivt                                 =>    veg_pp%itype                                       , & ! Input:  [integer  (:)   ]  pft vegetation type                                
          wtcol                               =>    veg_pp%wtcol                                       , & ! Input:  [real(r8) (:)   ]  weight (relative to column) for this pft (0-1)    
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/PhosphorusFluxType.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/PhosphorusFluxType.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/PhosphorusFluxType.F90	2020-06-10 13:57:17.302178843 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/PhosphorusFluxType.F90	2020-07-23 20:25:15.862922763 -0400
@@ -222,6 +222,8 @@
      real(r8), pointer :: actual_immob_p_col                          (:)     ! col vert-int (diagnostic) actual P immobilization (gP/m2/s)
      real(r8), pointer :: sminp_to_plant_vr_col                     (:,:)   ! col vertically-resolved plant uptake of soil mineral P (gP/m3/s)
      real(r8), pointer :: sminp_to_plant_col                        (:)     ! col vert-int (diagnostic) plant uptake of soil mineral P (gP/m2/s)
+     real(r8), pointer :: sminp_to_plant_fun_vr_col                     (:,:)   ! col vertically-resolved plant uptake of soil mineral P (gP/m3/s)
+     real(r8), pointer :: sminp_to_plant_fun_col                        (:)     ! col vert-int (diagnostic) plant uptake of soil mineral P (gP/m2/s)
      real(r8), pointer :: supplement_to_sminp_vr_col                (:,:)   ! col vertically-resolved supplemental P supply (gP/m3/s)
      real(r8), pointer :: supplement_to_sminp_col                   (:)     ! col vert-int (diagnostic) supplemental P supply (gP/m2/s)
      real(r8), pointer :: gross_pmin_vr_col                         (:,:)   ! col vertically-resolved gross rate of P mineralization (gP/m3/s)
@@ -305,6 +307,28 @@
      real(r8), pointer :: avail_retransp_patch                      (:)     ! P flux available from retranslocation pool (gP/m2/s)
      real(r8), pointer :: plant_palloc_patch                        (:)     ! total allocated P flux (gP/m2/s)
 
+     !Variables used by FUN-P
+     real(r8), pointer :: plant_pdemand_retrans_patch                  (:)     ! The P demand pool generated for FUN2.0; mainly used for deciduous trees (gP/m2/s)
+     real(r8), pointer :: plant_pdemand_season_patch                (:)        ! The P demand pool for seasonal deciduous (gP/m2/s)
+     real(r8), pointer :: plant_pdemand_stress_patch                (:)        ! The P demand pool for stress deciduous   (gP/m2/s)
+     real(r8), pointer :: Pactive_patch                             (:)        ! P acquired by mycorrhizal uptake  (gP/m2/s)
+     real(r8), pointer :: Pnonmyc_patch                             (:)        ! P acquired by non-myc uptake      (gP/m2/s)
+     real(r8), pointer :: Pam_patch                                 (:)        ! P acquired by AM plant            (gP/m2/s)
+     real(r8), pointer :: Pecm_patch                                (:)        ! P acquired by ECM plant           (gP/m2/s)
+     real(r8), pointer :: Ppassive_patch                            (:)       ! P acquired by passive uptake      (gP/m2/s)
+     real(r8), pointer :: Pretrans_patch                            (:)        ! P acquired by retranslocation     (gP/m2/s)
+     real(r8), pointer :: Pretrans_org_patch                        (:)       ! P acquired by retranslocation     (gP/m2/s)
+     real(r8), pointer :: Pretrans_season_patch                     (:)        ! N acquired by retranslocation     (gP/m2/s)
+     real(r8), pointer :: Pretrans_stress_patch                     (:)      ! N acquired by retranslocation     (gP/m2/s)
+     real(r8), pointer :: Puptake_patch                             (:)        ! Total P uptake of FUN             (gP/m2/s)
+     real(r8), pointer :: sminp_to_plant_fun_patch                  (:)       ! Total soil N uptake of FUN        (gP/m2/s)
+     real(r8), pointer :: sminp_to_plant_fun_vr_patch               (:,:)  ! Total layer soil N uptake of FUN  (gP/m2/s)
+     real(r8), pointer :: cost_pactive_patch                        (:)     ! Average cost of active uptake     (gP/m2/s)
+     real(r8), pointer :: cost_pretrans_patch                       (:)     ! Average cost of retranslocation   (gP/m2/s)
+     real(r8), pointer :: cost_pnonmyc_patch                       (:)     ! Average cost of retranslocation   (gP/m2/s)
+     real(r8), pointer :: puptake_npp_fraction_patch                (:)    ! frac of npp spent on P acquisition   (gP/m2/s)
+
+
      ! clm_interface & pflotran
      !------------------------------------------------------------------------
      real(r8), pointer :: plant_pdemand_col                         (:)     ! col P flux required to support initial GPP (gN/m2/s)
@@ -317,6 +341,7 @@
      real(r8), pointer :: sminp_net_transport_delta_col             (:)     ! col summarized net change of column-level sminp leaching bwtn time-step (for balance checking) (gP/m2)
      !------------------------------------------------------------------------
 
+
      real(r8), pointer :: sminp_to_plant_patch                      (:)     ! pft-level plant p uptake (gP/m2/s)
      real(r8), pointer :: plant_pdemand_vr_patch                    (:,:)   ! pft-level plant P demand
      real(r8), pointer :: prev_leafp_to_litter_patch                (:)     ! previous timestep leaf P litterfall flux (gP/m2/s)
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/PhosphorusStateUpdate1Mod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/PhosphorusStateUpdate1Mod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/PhosphorusStateUpdate1Mod.F90	2020-06-10 13:56:35.147391598 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/PhosphorusStateUpdate1Mod.F90	2020-05-10 20:09:52.142086429 -0400
@@ -8,7 +8,7 @@
   use clm_time_manager       , only : get_step_size
   use clm_varpar             , only : nlevdecomp, ndecomp_pools, ndecomp_cascade_transitions
   use clm_varpar             , only : crop_prog, i_met_lit, i_cel_lit, i_lig_lit, i_cwd
-  use clm_varctl             , only : iulog, use_nitrif_denitrif
+  use clm_varctl             , only : iulog, use_nitrif_denitrif, use_funp
   use clm_varcon             , only : nitrif_n2o_loss_frac
   use pftvarcon              , only : npcropmin, nc3crop
   use soilorder_varcon       , only : smax,ks_sorption
@@ -225,6 +225,10 @@
                .and. kda == 1  .and. mcsec == 1800) then ! fertilization assumed to occur at the begnining of each month
                do j = 1, nlevdecomp
                   col_ps%solutionp_vr(c,j) = col_ps%solutionp_vr(c,j) + fert_dose(c,kmo)*ndep_prof(c,j)
+
+                  !if(use_funp)then
+                  !col_ps%solutionp_vr(c,j) = col_ps%solutionp_vr(c,j) + col_pf%sminp_to_plant_fun_vr(c,j)*dt
+                  !end if
                end do
             end if
          end do
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/PhosphorusStateUpdate3Mod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/PhosphorusStateUpdate3Mod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/PhosphorusStateUpdate3Mod.F90	2020-06-10 13:56:35.151391578 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/PhosphorusStateUpdate3Mod.F90	2020-05-10 20:09:52.118086569 -0400
@@ -10,7 +10,7 @@
   use decompMod           , only : bounds_type
   use clm_varpar          , only: nlevdecomp,ndecomp_pools,ndecomp_cascade_transitions
   use clm_time_manager    , only : get_step_size
-  use clm_varctl          , only : iulog, use_nitrif_denitrif
+  use clm_varctl          , only : iulog, use_nitrif_denitrif, use_funp
   use clm_varpar          , only : i_cwd, i_met_lit, i_cel_lit, i_lig_lit
   use clm_varctl          , only : use_erosion, ero_ccycle
   use CNDecompCascadeConType , only : decomp_cascade_con
@@ -143,6 +143,15 @@
                smax_c = smax( isoilorder(c) )
                ks_sorption_c = ks_sorption( isoilorder(c) )
                temp_solutionp(c,j) = col_ps%solutionp_vr(c,j)
+
+               if(use_funp)then
+            
+                 col_pf%sminp_to_plant_vr(c,j) = col_pf%sminp_to_plant_fun_vr(c,j)
+                end if
+
+             
+
+
                col_ps%solutionp_vr(c,j)      = col_ps%solutionp_vr(c,j)  + ( flux_mineralization(c,j) &
                     + col_pf%primp_to_labilep_vr(c,j)*dt &
                     + col_pf%secondp_to_labilep_vr(c,j)*dt &
@@ -168,6 +177,7 @@
                              + col_pf%supplement_to_sminp_vr(c,j) - col_pf%sminp_to_plant_vr(c,j) &
                              - col_pf%labilep_to_secondp_vr(c,j) - col_pf%sminp_leached_vr(c,j) ) / &
                              ( 1._r8+(smax_c*ks_sorption_c)/(ks_sorption_c+temp_solutionp(c,j))**2._r8 )
+
              end do
            end do
         else ! ECA  
@@ -179,12 +189,16 @@
 
                 smax_c = vmax_minsurf_p_vr(isoilorder(c),j)
                 ks_sorption_c = km_minsurf_p_vr(isoilorder(c),j)
+   
+                
                 temp_solutionp(c,j) = ( col_ps%solutionp_vr(c,j) + col_ps%labilep_vr(c,j) + &
                             (flux_mineralization(c,j) + col_pf%primp_to_labilep_vr(c,j)*dt + &
                             col_pf%secondp_to_labilep_vr(c,j)*dt + col_pf%supplement_to_sminp_vr(c,j)*dt - &
                             col_pf%sminp_to_plant_vr(c,j)*dt - col_pf%labilep_to_secondp_vr(c,j)*dt - &
                             col_pf%sminp_leached_vr(c,j)*dt ))
 
+                
+
                  if (temp_solutionp(c,j) < 0.0_r8) then
                     col_pf%labilep_to_secondp_vr(c,j) = col_pf%labilep_to_secondp_vr(c,j)/ &
                             (col_pf%labilep_to_secondp_vr(c,j)+col_pf%sminp_leached_vr(c,j))* &
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/PrecisionControlMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/PrecisionControlMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/PrecisionControlMod.F90	2020-06-10 13:56:35.156391553 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/PrecisionControlMod.F90	2020-05-10 20:09:52.116086580 -0400
@@ -41,7 +41,7 @@
     ! they get too small.
     !
     ! !USES:
-    use clm_varctl , only : iulog, use_c13, use_c14, use_nitrif_denitrif, use_fates
+    use clm_varctl , only : iulog, use_c13, use_c14, use_nitrif_denitrif, use_fates, use_fun, use_funp
     use clm_varpar , only : nlevdecomp_full, crop_prog
     use pftvarcon  , only : nc3crop
     use tracer_varcon          , only : is_active_betr_bgc    
@@ -636,6 +636,7 @@
 
          end do   ! end of column loop
 
+        if(.not.use_fun)then
          if (use_nitrif_denitrif) then
             ! remove small negative perturbations for stability purposes, if any should arise.
 
@@ -659,6 +660,7 @@
                end do
             end do
          endif
+        endif
 
          if (nu_com .eq. 'ECA') then
             ! decompose P pool adjust according to C pool
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/SoilLittDecompMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/SoilLittDecompMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeochem/SoilLittDecompMod.F90	2020-06-10 13:56:35.165391507 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeochem/SoilLittDecompMod.F90	2020-05-10 20:09:52.187086166 -0400
@@ -10,7 +10,7 @@
   use shr_const_mod          , only : SHR_CONST_TKFRZ
   use decompMod              , only : bounds_type
   use perf_mod               , only : t_startf, t_stopf
-  use clm_varctl             , only : iulog, use_nitrif_denitrif, use_lch4, use_century_decomp
+  use clm_varctl             , only : iulog, use_nitrif_denitrif, use_lch4, use_century_decomp, use_fun
   use clm_varcon             , only : dzsoi_decomp
   use clm_varpar             , only : nlevdecomp, ndecomp_cascade_transitions, ndecomp_pools
   use DecompCascadeCNMod   , only : decomp_rate_constants_cn
@@ -41,6 +41,10 @@
   use VegetationDataType     , only : veg_ps, veg_pf
   ! clm interface & pflotran:
   use clm_varctl             , only : use_clm_interface, use_pflotran, pf_cmode
+
+  ! used variables for FUN - R. Braghiere 
+  use SoilHydrologyType   , only : soilhydrology_type
+  use WaterFluxType       , only : waterflux_type
   !
   implicit none
   save
@@ -100,7 +104,9 @@
                 cnstate_vars, ch4_vars,                         &
                 carbonstate_vars, carbonflux_vars,              &
                 nitrogenstate_vars, nitrogenflux_vars,          &
-                phosphorusstate_vars,phosphorusflux_vars)
+                phosphorusstate_vars,phosphorusflux_vars,       &
+                c13_carbonflux_vars, c14_carbonflux_vars, crop_vars, &
+                soilhydrology_vars, waterflux_vars)
 
     !-----------------------------------------------------------------------------
     ! DESCRIPTION:
@@ -132,14 +138,19 @@
     type(ch4_type)           , intent(in)    :: ch4_vars
     type(carbonstate_type)   , intent(inout) :: carbonstate_vars
     type(carbonflux_type)    , intent(inout) :: carbonflux_vars
-!    type(carbonflux_type)    , intent(inout) :: c13_carbonflux_vars
-!    type(carbonflux_type)    , intent(inout) :: c14_carbonflux_vars
+    type(carbonflux_type)    , intent(inout) :: c13_carbonflux_vars
+    type(carbonflux_type)    , intent(inout) :: c14_carbonflux_vars
     type(nitrogenstate_type) , intent(inout) :: nitrogenstate_vars
     type(nitrogenflux_type)  , intent(inout) :: nitrogenflux_vars
     ! add phosphorus --
     type(phosphorusstate_type) , intent(inout) :: phosphorusstate_vars
     type(phosphorusflux_type)  , intent(inout) :: phosphorusflux_vars
-!    type(crop_type)          , intent(in)    :: crop_vars
+    type(crop_type)            , intent(inout) :: crop_vars
+
+     !! add varibles needed for FUN
+    type(soilhydrology_type)  , intent(in) :: soilhydrology_vars
+    !type(temperature_type)    , intent(in) :: temperature_vars
+    type(waterflux_type)      , intent(in) :: waterflux_vars
     !
     ! !LOCAL VARIABLES:
     integer :: c,j,k,l,m                                                                               !indices
@@ -407,13 +418,17 @@
       ! for available soil mineral N resource.
       ! in addition, calculate fpi_vr, fpi_p_vr, & fgp
       call t_startf('CNAllocation - phase-2')
-      call Allocation2_ResolveNPLimit(bounds,                     &
-               num_soilc, filter_soilc, num_soilp, filter_soilp,    &
-               cnstate_vars,                                        &
-               carbonstate_vars, carbonflux_vars,                   &
-               nitrogenstate_vars, nitrogenflux_vars,               &
-               phosphorusstate_vars,phosphorusflux_vars,            &
-               soilstate_vars,waterstate_vars)
+      call Allocation2_ResolveNPLimit(bounds, num_soilc, filter_soilc  , &
+                            num_soilp,filter_soilp, &
+                            cnstate_vars , &
+                            carbonstate_vars, carbonflux_vars, &
+                            c13_carbonflux_vars, c14_carbonflux_vars, &
+                            nitrogenstate_vars, nitrogenflux_vars, &
+                            phosphorusstate_vars,phosphorusflux_vars , &
+                            soilstate_vars,waterstate_vars, &
+                            crop_vars, &
+                   soilhydrology_vars, temperature_vars, waterflux_vars, &
+                   canopystate_vars)
       call t_stopf('CNAllocation - phase-2')
 
       
@@ -615,7 +630,8 @@
        waterstate_vars, cnstate_vars, ch4_vars,                                          &
        carbonstate_vars, carbonflux_vars, c13_carbonflux_vars, c14_carbonflux_vars,      &
        nitrogenstate_vars, nitrogenflux_vars, crop_vars, atm2lnd_vars,                   &
-       phosphorusstate_vars,phosphorusflux_vars)
+       phosphorusstate_vars,phosphorusflux_vars, &
+       soilhydrology_vars, waterflux_vars)
     !-----------------------------------------------------------------------------
     ! DESCRIPTION:
     ! bgc interface & pflotran:
@@ -640,7 +656,7 @@
     type(photosyns_type)     , intent(in)    :: photosyns_vars
     type(canopystate_type)   , intent(in)    :: canopystate_vars
     type(soilstate_type)     , intent(in)    :: soilstate_vars
-    type(temperature_type)   , intent(in)    :: temperature_vars
+    type(temperature_type)   , intent(inout) :: temperature_vars
     type(waterstate_type)    , intent(in)    :: waterstate_vars
     type(cnstate_type)       , intent(inout) :: cnstate_vars
     type(ch4_type)           , intent(in)    :: ch4_vars
@@ -655,6 +671,11 @@
     !! add phosphorus --
     type(phosphorusstate_type) , intent(inout) :: phosphorusstate_vars
     type(phosphorusflux_type)  , intent(inout) :: phosphorusflux_vars
+
+     !! add varibles needed for FUN - R. braghiere
+    type(soilhydrology_type)  , intent(in) :: soilhydrology_vars
+    !type(temperature_type)    , intent(in) :: temperature_inst
+    type(waterflux_type)      , intent(in) :: waterflux_vars
     !
     ! !LOCAL VARIABLES:
     integer :: fc, c, j                                     ! indices
@@ -662,6 +683,7 @@
     real(r8) :: dt                                           ! time step (seconds)
     real(r8) :: smin_nh4_to_plant_vr_loc(bounds%begc:bounds%endc,1:nlevdecomp)
     real(r8) :: smin_no3_to_plant_vr_loc(bounds%begc:bounds%endc,1:nlevdecomp)
+    real(r8) :: sminn_to_plant_new_loc(bounds%begc:bounds%endc)
 
     ! For methane code
     real(r8):: hrsum(bounds%begc:bounds%endc,1:nlevdecomp)                                             !sum of HR (gC/m2/s)
@@ -707,7 +729,14 @@
          fphr                             =>    col_cf%fphr                               , & ! Output: [real(r8) (:,:)   ]  fraction of potential SOM + LITTER heterotrophic
 
          smin_no3_vr                      =>    col_ns%smin_no3_vr                     , &
-         smin_nh4_vr                      =>    col_ns%smin_nh4_vr                       &
+         smin_nh4_vr                      =>    col_ns%smin_nh4_vr                     ,  &
+         !FUN variables
+         sminn_to_plant_fun_vr        => col_nf%sminn_to_plant_fun_vr            , & ! Output:
+         sminn_to_plant_fun_no3_vr        => col_nf%sminn_to_plant_fun_no3_vr            , & ! Output:
+         sminn_to_plant_fun_nh4_vr        => col_nf%sminn_to_plant_fun_nh4_vr            , & ! Output:
+         sminp_to_plant_fun_vr        => col_pf%sminp_to_plant_fun_vr            & ! Output:
+         !  [real(r8) (:) ]  Total layer soil P uptake of FUN (gP/m2
+         !  /s)           
          )
 
       ! set time steps
@@ -717,7 +746,7 @@
 	    !------------------------------------------------------------------
 	    smin_nh4_to_plant_vr_loc(:,:) = 0._r8
 	    smin_no3_to_plant_vr_loc(:,:) = 0._r8
-
+	    sminn_to_plant_new_loc(:) = 0._r8
 
       ! MUST have already updated needed bgc variables from PFLOTRAN by this point
       if(use_clm_interface.and.use_pflotran.and.pf_cmode) then
@@ -727,14 +756,40 @@
             sminn_to_plant(c)       = 0._r8
             do j = 1, nlevdecomp           ! sum up actual and potential column-level N fluxes to plant
                sminn_to_plant(c)    = sminn_to_plant(c) + sminn_to_plant_vr(c,j) * dzsoi_decomp(j)
+               if ( use_fun ) then
+                  if (sminn_to_plant_fun_vr(c,j).gt.sminn_to_plant_vr(c,j)) then
+                      sminn_to_plant_fun_vr(c,j)  = sminn_to_plant_vr(c,j)
+                  end if
+               end if
+
             end do
          end do
+
+           if(use_fun)then
+             ! add up fun fluxes from SMINN to plant. 
+             do j = 1, nlevdecomp
+                do fc=1,num_soilc
+                   c = filter_soilc(fc)
+                   sminn_to_plant_new_loc(c)  = sminn_to_plant_new_loc(c) + &
+                             (sminn_to_plant_fun_vr(c,j)) * dzsoi_decomp(j)
+               
+             end do
+           end do  
+          end if 
+
+
+
          do fc=1,num_soilc
             c = filter_soilc(fc)
             ! calculate the fraction of potential growth that can be
             ! acheived with the N available to plants
+           
             if (plant_ndemand_col(c) > 0.0_r8) then
+               if(.not.use_fun)then
                fpg(c) = max(0._r8,sminn_to_plant(c)) / plant_ndemand_col(c)
+               else 
+               fpg(c) = max(0._r8,sminn_to_plant_new_loc(c)) / plant_ndemand_col(c)
+               end if
                fpg(c) = min(1._r8, fpg(c))
             else
                fpg(c) = 1.0_r8
@@ -811,8 +866,13 @@
          do fc = 1,num_soilc
             c = filter_soilc(fc)
             do j = 1,nlevdecomp
+              if(.not.use_fun)then
                 smin_no3_to_plant_vr_loc(c,j) = smin_no3_to_plant_vr(c,j)
                 smin_nh4_to_plant_vr_loc(c,j) = smin_nh4_to_plant_vr(c,j)
+              else
+                smin_no3_to_plant_vr_loc(c,j) = sminn_to_plant_fun_no3_vr(c,j)
+                smin_nh4_to_plant_vr_loc(c,j) = sminn_to_plant_fun_nh4_vr(c,j)
+              end if
             end do
          end do
 
@@ -827,7 +887,9 @@
                 cnstate_vars, carbonstate_vars, carbonflux_vars     , &
                 c13_carbonflux_vars, c14_carbonflux_vars            , &
                 nitrogenstate_vars, nitrogenflux_vars               , &
-                phosphorusstate_vars, phosphorusflux_vars, crop_vars)
+                phosphorusstate_vars, phosphorusflux_vars, crop_vars, &
+                soilhydrology_vars, temperature_vars, waterflux_vars, &
+                soilstate_vars)
       call t_stopf('CNAllocation - phase-3')
       !------------------------------------------------------------------
 
@@ -838,8 +900,14 @@
       do fc = 1,num_soilc
            c = filter_soilc(fc)
            do j = 1,nlevdecomp
+            if(.not.use_fun)then
                smin_no3_vr(c,j) = smin_no3_vr(c,j) - (smin_no3_to_plant_vr(c,j) - smin_no3_to_plant_vr_loc(c,j))*dt
                smin_nh4_vr(c,j) = smin_nh4_vr(c,j) - (smin_nh4_to_plant_vr(c,j) - smin_nh4_to_plant_vr_loc(c,j))*dt
+            else
+               smin_no3_vr(c,j) = smin_no3_vr(c,j) - (sminn_to_plant_fun_no3_vr(c,j) - smin_no3_to_plant_vr_loc(c,j))*dt
+               smin_nh4_vr(c,j) = smin_nh4_vr(c,j) - (sminn_to_plant_fun_nh4_vr(c,j) - smin_nh4_to_plant_vr_loc(c,j))*dt
+            end if
+
                smin_no3_vr(c,j) = max(0._r8, smin_no3_vr(c,j))
                smin_nh4_vr(c,j) = max(0._r8, smin_nh4_vr(c,j))
             end do
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeophys/BalanceCheckMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeophys/BalanceCheckMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeophys/BalanceCheckMod.F90	2020-06-10 13:56:35.191391376 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeophys/BalanceCheckMod.F90	2020-07-10 00:37:53.526425660 -0400
@@ -9,7 +9,7 @@
   use shr_log_mod        , only : errMsg => shr_log_errMsg
   use decompMod          , only : bounds_type
   use abortutils         , only : endrun
-  use clm_varctl         , only : iulog, use_var_soil_thick
+  use clm_varctl         , only : iulog, use_var_soil_thick, use_fun
   use clm_varcon         , only : namep, namec
   use GetGlobalValuesMod , only : GetGlobalIndex
   use atm2lndType        , only : atm2lnd_type
@@ -359,6 +359,9 @@
           if (abs(errh2o(c)) > 1.e-7_r8) then
              found = .true.
              indexc = c
+             if(use_fun)then
+               found = .false.
+             end if
           end if
        end do
 
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeophys/PhotosynthesisType.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeophys/PhotosynthesisType.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeophys/PhotosynthesisType.F90	2020-06-10 13:56:35.242391118 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeophys/PhotosynthesisType.F90	2020-05-10 20:09:51.758088668 -0400
@@ -95,6 +95,7 @@
      real(r8), pointer, public :: gs_mol_sun_patch  (:,:) ! patch sunlit leaf stomatal conductance (umol H2O/m**2/s)
      real(r8), pointer, public :: gs_mol_sha_patch  (:,:) ! patch shaded leaf stomatal conductance (umol H2O/m**2/s)
 
+
    contains
 
      procedure, public  :: Init
@@ -212,6 +213,8 @@
     allocate(this%gs_mol_sun_patch  (begp:endp,1:nlevcan))   ; this%gs_mol_sun_patch  (:,:)   = nan
     allocate(this%gs_mol_sha_patch  (begp:endp,1:nlevcan))   ; this%gs_mol_sha_patch  (:,:)   = nan
 
+
+
   end subroutine InitAllocate
 
   !-----------------------------------------------------------------------
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeophys/SoilStateType.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeophys/SoilStateType.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeophys/SoilStateType.F90	2020-06-10 13:56:35.271390972 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeophys/SoilStateType.F90	2020-07-08 16:13:45.748125296 -0400
@@ -304,6 +304,7 @@
        call hist_addfld2d (fname='watfc', units='m^3/m^3', type2d='levgrnd', &
             avgflag='A', long_name='water field capacity', &
             ptr_col=this%watfc_col, default='inactive')
+
     end if
 
   end subroutine InitHistory
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeophys/WaterfluxType.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeophys/WaterfluxType.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/biogeophys/WaterfluxType.F90	2020-06-10 13:56:35.321390720 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/biogeophys/WaterfluxType.F90	2020-05-10 20:09:51.657089256 -0400
@@ -11,6 +11,8 @@
   use ColumnType   , only : col_pp                
   use VegetationType    , only : veg_pp                
   use AnnualFluxDribbler, only : annual_flux_dribbler_type, annual_flux_dribbler_gridcell
+  use clm_varctl   , only : use_fun
+
   !
   implicit none
   save
@@ -139,6 +141,9 @@
      real(r8), pointer :: mflx_recharge_col        (:)   ! recharge from soil column to unconfined aquifer (kg H2O /s)
      real(r8), pointer :: sapflow_patch (:) !plant hydraulics, (mm/s)
 
+     ! ET accumulation
+     real(r8), pointer :: AnnEt                    (:)   ! Annual average ET flux mmH20/s
+
    contains
  
      procedure, public  :: Init
@@ -147,6 +152,9 @@
      procedure, private :: InitAllocate
      procedure, private :: InitHistory
      procedure, private :: InitCold
+     procedure, public  :: InitAccBuffer
+     procedure, public  :: InitAccVars
+     procedure, public  :: UpdateAccVars
 
   end type waterflux_type
   !------------------------------------------------------------------------
@@ -309,6 +317,7 @@
     allocate(this%mflx_drain_col         (begc:endc,1:nlevgrnd))     ; this%mflx_drain_col           (:,:) = nan
     allocate(this%mflx_recharge_col      (begc:endc))                ; this%mflx_recharge_col        (:)   = nan
     allocate(this%sapflow_patch          (begp:endp))                ; this%sapflow_patch              (:) = nan
+    allocate(this%AnnET                  (begc:endc))                ; this%AnnET                    (:)   = nan
 
   end subroutine InitAllocate
 
@@ -341,6 +350,119 @@
  
   end subroutine InitHistory
 
+   !-----------------------------------------------------------------------
+    subroutine InitAccBuffer (this, bounds)
+    !
+    ! !DESCRIPTION:
+    ! Initialize accumulation buffer for all required module accumulated fields
+    ! This routine set defaults values that are then overwritten by the
+    ! restart file for restart or branch runs
+    !
+    ! !USES 
+    use clm_varcon  , only : spval
+    use accumulMod  , only : init_accum_field
+    !
+    ! !ARGUMENTS:
+    class(waterflux_type) :: this
+    type(bounds_type), intent(in) :: bounds  
+    !---------------------------------------------------------------------
+
+    if (use_fun) then
+   
+       call init_accum_field (name='AnnET', units='MM H2O/S', &
+            desc='365-day running mean of total ET', accum_type='runmean', accum_period=-365, &
+            subgrid_type='column', numlev=1, init_value=0._r8)
+
+    end if
+
+  end subroutine InitAccBuffer
+
+  !-----------------------------------------------------------------------
+    !
+     subroutine InitAccVars (this, bounds)
+    ! !DESCRIPTION:
+    ! Initialize module variables that are associated with
+    ! time accumulated fields. This routine is called for both an initial run
+    ! and a restart run (and must therefore must be called after the restart file 
+    ! is read in and the accumulation buffer is obtained)
+    !
+    ! !USES 
+    use accumulMod       , only : extract_accum_field
+    use clm_time_manager , only : get_nstep
+    !
+    ! !ARGUMENTS:
+    class(waterflux_type) :: this
+    type(bounds_type), intent(in) :: bounds  
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: begc, endc
+    integer  :: nstep
+    integer  :: ier
+    real(r8), pointer :: rbufslp(:)  ! temporary
+    !---------------------------------------------------------------------
+    begc = bounds%begc; endc = bounds%endc
+
+    ! Allocate needed dynamic memory for single level patch field
+    allocate(rbufslp(begc:endc), stat=ier)
+
+    ! Determine time step
+    nstep = get_nstep()
+
+    if (use_fun) then
+       call extract_accum_field ('AnnET', rbufslp, nstep)
+       this%AnnET(begc:endc) = rbufslp(begc:endc)
+    end if
+
+    deallocate(rbufslp)
+
+  end subroutine InitAccVars
+  
+  
+  !-----------------------------------------------------------------------
+  subroutine UpdateAccVars (this, bounds)
+    !
+    ! USES
+    use clm_time_manager, only : get_nstep
+    use accumulMod      , only : update_accum_field, extract_accum_field
+    !
+    ! !ARGUMENTS:
+    class(waterflux_type)                 :: this
+    type(bounds_type)      , intent(in) :: bounds  
+    !
+    ! !LOCAL VARIABLES:
+    integer :: g,c,p                     ! indices
+    integer :: dtime                     ! timestep size [seconds]
+    integer :: nstep                     ! timestep number
+    integer :: ier                       ! error status
+    integer :: begc, endc
+    real(r8), pointer :: rbufslp(:)      ! temporary single level - patch level
+    !---------------------------------------------------------------------
+
+    begc = bounds%begc; endc = bounds%endc
+
+    nstep = get_nstep()
+
+    ! Allocate needed dynamic memory for single level patch field
+
+    allocate(rbufslp(begc:endc), stat=ier)
+    
+    do c = begc,endc
+       rbufslp(c) = this%qflx_evap_tot_col(c)
+    end do
+    if (use_fun) then
+       ! Accumulate and extract AnnET (accumulates total ET as 365-day running mean)
+       call update_accum_field  ('AnnET', rbufslp, nstep)
+       call extract_accum_field ('AnnET', this%AnnET, nstep)
+    
+    end if
+
+    deallocate(rbufslp)
+    
+  end subroutine UpdateAccVars
+
+
+  !-----------------------------------------------------------------------
+
   !-----------------------------------------------------------------------
   subroutine InitCold(this, bounds)
     !
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/data_types/CNStateType.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/data_types/CNStateType.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/data_types/CNStateType.F90	2020-06-10 13:56:35.343390609 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/data_types/CNStateType.F90	2020-05-10 20:09:52.008087210 -0400
@@ -26,6 +26,8 @@
   save
   private
   !
+  ! !PRIVATE MEMBER FUNCTIONS: 
+  private :: checkDates
   ! !PUBLIC TYPES:
   integer    , pointer, public :: fert_type         (:)
   integer    , pointer, public :: fert_continue     (:)
@@ -136,16 +138,22 @@
      real(r8), pointer :: annmax_retransn_patch        (:)     ! patch annual max of retranslocated N pool (gN/m2)
      real(r8), pointer :: downreg_patch                (:)     ! patch fractional reduction in GPP due to N limitation (DIM)
      real(r8), pointer :: rc14_atm_patch               (:)     ! patch C14O2/C12O2 in atmosphere
+     real(r8), pointer :: leafcn_offset_patch          (:)     ! patch leaf C:N used by FUN
+     real(r8), pointer :: plantCN_patch                (:)     ! patch plant C:N used by FUN
 
 
      !!! add phosphorus  -X. YANG
      real(r8), pointer :: p_allometry_patch            (:)     ! patch P allocation index (DIM)
      real(r8), pointer :: tempmax_retransp_patch       (:)     ! patch temporary annual max of retranslocated P pool (gP/m2)
      real(r8), pointer :: annmax_retransp_patch        (:)     ! patch annual max of retranslocated P pool (gP/m2)
+     real(r8), pointer :: leafcp_offset_patch          (:)     ! patch leaf C:P used by FUN
+     real(r8), pointer :: plantCP_patch                (:)     ! patch plant C:P used by FUN
 
      real(r8), pointer :: frootc_nfix_scalar_col       (:)     ! col scalar for nitrogen fixation
      real(r8), pointer :: decomp_litpool_rcn_col       (:,:,:) ! cn ratios of the decomposition pools
 
+     integer           :: CropRestYear                         ! restart year from initial conditions file - increment as time elapses
+
      real(r8), pointer :: fpg_nh4_vr_col               (:,:)   ! fraction of plant nh4 demand that is satisfied (no units) BGC mode
      real(r8), pointer :: fpg_no3_vr_col               (:,:)   ! fraction of plant no3 demand that is satisfied (no units) BGC mode
      real(r8), pointer :: fpg_vr_col                   (:,:)   ! fraction of plant N demand that is satisfied (no units) CN mode
@@ -173,6 +181,7 @@
 
      procedure, public  :: Init         
      procedure, public  :: Restart      
+     procedure, public  :: CropRestIncYear
      procedure, private :: InitAllocate
      procedure, private :: InitHistory  
      procedure, private :: InitCold     
@@ -267,6 +276,7 @@
 
     allocate(this%nfixation_prof_col  (begc:endc,1:nlevdecomp_full)) ; this%nfixation_prof_col  (:,:) = spval
     allocate(this%ndep_prof_col       (begc:endc,1:nlevdecomp_full)) ; this%ndep_prof_col       (:,:) = spval
+    allocate(this%pdep_prof_col       (begc:endc,1:nlevdecomp_full)) ; this%pdep_prof_col       (:,:) = spval
     allocate(this%som_adv_coef_col    (begc:endc,1:nlevdecomp_full)) ; this%som_adv_coef_col    (:,:) = spval
     allocate(this%som_diffus_coef_col (begc:endc,1:nlevdecomp_full)) ; this%som_diffus_coef_col (:,:) = spval
 
@@ -294,6 +304,7 @@
     allocate(this%farea_burned_col    (begc:endc))                   ; this%farea_burned_col    (:)   = nan
     allocate(this%decomp_litpool_rcn_col (begc:endc, 1:nlevdecomp_full, 4)); this%decomp_litpool_rcn_col (:,:,:) = nan
     allocate(this%frootc_nfix_scalar_col (begc:endc))                ; this%frootc_nfix_scalar_col(:) = nan
+    this%CropRestYear = 0
 
     allocate(this%dormant_flag_patch          (begp:endp)) ;    this%dormant_flag_patch          (:) = nan
     allocate(this%days_active_patch           (begp:endp)) ;    this%days_active_patch           (:) = nan
@@ -322,12 +333,16 @@
     allocate(this%annmax_retransn_patch       (begp:endp)) ;    this%annmax_retransn_patch       (:) = nan
     allocate(this%downreg_patch               (begp:endp)) ;    this%downreg_patch               (:) = nan
     allocate(this%rc14_atm_patch              (begp:endp)) ;    this%rc14_atm_patch              (:) = nan    
+    allocate(this%leafcn_offset_patch         (begp:endp)) ;    this%leafcn_offset_patch         (:) = nan
+    allocate(this%plantCN_patch               (begp:endp)) ;    this%plantCN_patch               (:) = nan
 
 
     !! add phosphorus -X.YANG
     allocate(this%p_allometry_patch           (begp:endp)) ;    this%p_allometry_patch           (:) = nan
     allocate(this%tempmax_retransp_patch      (begp:endp)) ;    this%tempmax_retransp_patch      (:) = nan
     allocate(this%annmax_retransp_patch       (begp:endp)) ;    this%annmax_retransp_patch       (:) = nan
+    allocate(this%leafcp_offset_patch         (begp:endp)) ;    this%leafcp_offset_patch         (:) = nan
+    allocate(this%plantCP_patch               (begp:endp)) ;    this%plantCP_patch               (:) = nan
 
     allocate(this%fpg_nh4_vr_col              (begc:endc,1:nlevdecomp_full)) ; this%fpg_nh4_vr_col(:,:) = nan 
     allocate(this%fpg_no3_vr_col              (begc:endc,1:nlevdecomp_full)) ; this%fpg_no3_vr_col(:,:) = nan
@@ -639,6 +654,16 @@
          avgflag='A', long_name='fractional reduction in GPP due to N limitation', &
          ptr_patch=this%downreg_patch, default='inactive')
 
+    this%leafcn_offset_patch(begp:endp) = spval
+    call hist_addfld1d (fname='LEAFCN_OFFSET', units='unitless', &
+         avgflag='A', long_name='Leaf C:N used by FUN', &
+         ptr_patch=this%leafcn_offset_patch, default='inactive')
+
+    this%plantCN_patch(begp:endp)       = spval
+    call hist_addfld1d (fname='PLANTCN', units='unitless', &
+         avgflag='A', long_name='Plant C:N used by FUN', &
+         ptr_patch=this%plantCN_patch, default='inactive')
+
 
     !! add phosphorus -X.YANG
     this%p_allometry_patch(begp:endp) = spval
@@ -656,6 +681,16 @@
          avgflag='A', long_name='annual max of retranslocated P pool', &
          ptr_patch=this%annmax_retransp_patch, default='inactive')
 
+    this%leafcp_offset_patch(begp:endp) = spval
+    call hist_addfld1d (fname='LEAFCP_OFFSET', units='unitless', &
+         avgflag='A', long_name='Leaf C:P used by FUN', &
+         ptr_patch=this%leafcp_offset_patch, default='inactive')
+
+    this%plantCP_patch(begp:endp)       = spval
+    call hist_addfld1d (fname='PLANTCP', units='unitless', &
+         avgflag='A', long_name='Plant C:P used by FUN', &
+         ptr_patch=this%plantCP_patch, default='inactive')
+
     this%cn_scalar(begp:endp) = spval
     call hist_addfld1d (fname='cn_scalar', units='', &
        avgflag='A', long_name='N limitation factor', &
@@ -1038,10 +1073,14 @@
           this%tempmax_retransn_patch(p)      = spval
           this%annmax_retransn_patch(p)       = spval
           this%downreg_patch(p)               = spval
+          this%leafcn_offset_patch(p)         = spval
+          this%plantCN_patch(p)               = spval
 
           this%p_allometry_patch(p)           = spval
           this%tempmax_retransp_patch(p)      = spval
           this%annmax_retransp_patch(p)       = spval
+          this%leafcp_offset_patch(p)         = spval
+          this%plantCP_patch(p)               = spval
 
           this%r_mort_cal_patch(p)           = spval
 
@@ -1088,10 +1127,14 @@
           this%tempmax_retransn_patch(p)      = 0._r8
           this%annmax_retransn_patch(p)       = 0._r8
           this%downreg_patch(p)               = 0._r8
+          this%leafcn_offset_patch(p)         = spval 
+          this%plantCN_patch(p)               = spval 
 
           this%p_allometry_patch(p)           = 0._r8
           this%tempmax_retransp_patch(p)      = 0._r8
           this%annmax_retransp_patch(p)       = 0._r8
+          this%leafcp_offset_patch(p)         = spval 
+          this%plantCP_patch(p)               = spval 
 
           this%r_mort_cal_patch(p)           = 0._r8
 
@@ -1267,6 +1310,16 @@
          long_name='', units='', &
          interpinic_flag='interp', readvar=readvar, data=this%downreg_patch) 
 
+    call restartvar(ncid=ncid, flag=flag, varname='leafcn_offset', xtype=ncd_double,  &
+         dim1name='pft', &
+         long_name='', units='', &
+         interpinic_flag='interp', readvar=readvar, data=this%leafcn_offset_patch)
+     
+    call restartvar(ncid=ncid, flag=flag, varname='plantCN', xtype=ncd_double,  &
+         dim1name='pft', &
+         long_name='', units='', &
+         interpinic_flag='interp', readvar=readvar, data=this%plantCN_patch)
+
 
     call restartvar(ncid=ncid, flag=flag, varname='p_allometry', xtype=ncd_double,  &
          dim1name='pft', &
@@ -1283,6 +1336,16 @@
          long_name='', units='', &
          interpinic_flag='interp', readvar=readvar, data=this%annmax_retransp_patch) 
 
+    call restartvar(ncid=ncid, flag=flag, varname='leafcp_offset', xtype=ncd_double,  &
+         dim1name='pft', &
+         long_name='', units='', &
+         interpinic_flag='interp', readvar=readvar, data=this%leafcp_offset_patch)
+     
+    call restartvar(ncid=ncid, flag=flag, varname='plantCP', xtype=ncd_double,  &
+         dim1name='pft', &
+         long_name='', units='', &
+         interpinic_flag='interp', readvar=readvar, data=this%plantCP_patch)
+
     if (use_vertsoilc) then
        ptr2d => this%fpi_vr_col
        call restartvar(ncid=ncid, flag=flag, varname='fpi_vr', xtype=ncd_double,  &
@@ -1361,6 +1424,12 @@
 
     if (crop_prog) then
 
+       call restartvar(ncid=ncid, flag=flag,  varname='restyear', xtype=ncd_int,  &
+            long_name='Number of years prognostic crop ran', units="years", &
+            interpinic_flag='copy', readvar=readvar, data=this%CropRestYear)
+       if (flag=='read' .and. readvar)  then
+          call checkDates( )
+       end if
 
        call restartvar(ncid=ncid, flag=flag,  varname='htmx', xtype=ncd_double,  &
             dim1name='pft', long_name='max height attained by a crop during year', units='m', &
@@ -1564,5 +1633,95 @@
 
   end subroutine UpdateAccVars
 
+  !-----------------------------------------------------------------------
+  subroutine CropRestIncYear (this)
+    !
+    ! !DESCRIPTION: 
+    ! Increment the crop restart year, if appropriate
+    !
+    ! This routine should be called every time step, but only once per clump (to avoid
+    ! inadvertently updating nyrs multiple times)
+    !
+    ! !USES:
+    use clm_varpar       , only : crop_prog
+    use clm_time_manager , only : get_curr_date, is_first_step
+    !
+    ! !ARGUMENTS:
+    class(cnstate_type) :: this
+    !
+    ! !LOCAL VARIABLES:
+    integer kyr   ! current year
+    integer kmo   ! month of year  (1, ..., 12)
+    integer kda   ! day of month   (1, ..., 31)
+    integer mcsec ! seconds of day (0, ..., seconds/day)
+    !-----------------------------------------------------------------------
+
+    ! Update restyear only when running with prognostic crop
+    if ( crop_prog )then
+
+       ! Update restyear when it's the start of a new year - but don't do that at the
+       ! very start of the run
+       call get_curr_date (   kyr, kmo, kda, mcsec)
+       if ((kmo == 1 .and. kda == 1 .and. mcsec == 0) .and. .not. is_first_step()) then
+          this%CropRestYear = this%CropRestYear + 1
+       end if
+
+    end if
+
+  end subroutine CropRestIncYear
+
+  !-----------------------------------------------------------------------
+  subroutine checkDates( )
+    !
+    ! !DESCRIPTION: 
+    ! Make sure the dates are compatible. The date given to startup the model
+    ! and the date on the restart file must be the same although years can be
+    ! different. The dates need to be checked when the restart file is being
+    ! read in for a startup or branch case (they are NOT allowed to be different
+    ! for a restart case).
+    !
+    ! For the prognostic crop model the date of planting is tracked and growing
+    ! degree days is tracked (with a 20 year mean) -- so shifting the start dates
+    ! messes up these bits of saved information.
+    !
+    ! !ARGUMENTS:
+    use clm_time_manager, only : get_driver_start_ymd, get_start_date
+    use clm_varctl      , only : iulog
+    use clm_varctl      , only : nsrest, nsrBranch, nsrStartup
+    !
+    ! !LOCAL VARIABLES:
+    integer :: stymd       ! Start date YYYYMMDD from driver
+    integer :: styr        ! Start year from driver
+    integer :: stmon_day   ! Start date MMDD from driver
+    integer :: rsmon_day   ! Restart date MMDD from restart file
+    integer :: rsyr        ! Restart year from restart file
+    integer :: rsmon       ! Restart month from restart file
+    integer :: rsday       ! Restart day from restart file
+    integer :: tod         ! Restart time of day from restart file
+    character(len=*), parameter :: formDate = '(A,i4.4,"/",i2.2,"/",i2.2)' ! log output format
+    character(len=32) :: subname = 'CropRest::checkDates'
+    !-----------------------------------------------------------------------
+    !
+    ! If branch or startup make sure the startdate is compatible with the date
+    ! on the restart file.
+    !
+    if ( nsrest == nsrBranch .or. nsrest == nsrStartup )then
+       stymd       = get_driver_start_ymd()
+       styr        = stymd / 10000
+       stmon_day   = stymd - styr*10000
+       call get_start_date( rsyr, rsmon, rsday, tod )
+       rsmon_day = rsmon*100 + rsday
+       if ( masterproc ) &
+            write(iulog,formDate) 'Date on the restart file is: ', rsyr, rsmon, rsday
+       if ( stmon_day /= rsmon_day )then
+          write(iulog,formDate) 'Start date is: ', styr, stmon_day/100, &
+               (stmon_day - stmon_day/100)
+          call endrun(msg=' ERROR: For prognostic crop to work correctly, the start date (month and day)'// &
+               ' and the date on the restart file needs to match (years can be different)'//&
+               errMsg(__FILE__, __LINE__))
+       end if
+    end if
+
+  end subroutine checkDates
 
 end module CNStateType
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/data_types/ColumnDataType.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/data_types/ColumnDataType.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/data_types/ColumnDataType.F90	2020-06-10 13:57:17.325178727 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/data_types/ColumnDataType.F90	2020-05-10 20:09:52.001087251 -0400
@@ -20,7 +20,7 @@
   use clm_varcon      , only : spval, ispval, zlnd, snw_rds_min, denice, denh2o, tfrz, pondmx
   use clm_varcon      , only : watmin, bdsno, zsoi, zisoi, dzsoi_decomp
   use clm_varcon      , only : c13ratio, c14ratio, secspday
-  use clm_varctl      , only : use_fates, use_fates_planthydro, create_glacier_mec_landunit
+  use clm_varctl      , only : use_fates, use_fates_planthydro, create_glacier_mec_landunit, use_fun, use_funp
   use clm_varctl      , only : use_hydrstress
   use clm_varctl      , only : bound_h2osoi, use_cn, iulog, use_vertsoilc, spinup_state
   use clm_varctl      , only : use_erosion
@@ -489,11 +489,18 @@
     real(r8), pointer :: mflx_drain           (:,:) => null() ! drainage from groundwater table (kg H2O /s)
     real(r8), pointer :: mflx_recharge        (:)   => null() ! recharge from soil column to unconfined aquifer (kg H2O /s)
 
+     ! ET accumulation
+     real(r8), pointer :: AnnEt               (:)  => null() ! Annual average ET flux mmH20/s
+
   contains
     procedure, public :: Init    => col_wf_init
     procedure, public :: Restart => col_wf_restart
     procedure, public :: Reset   => col_wf_reset
     procedure, public :: Clean   => col_wf_clean
+    procedure, public :: InitAccBuffer => init_acc_buffer_col_wf
+    procedure, public :: InitAccVars   => init_acc_vars_col_wf
+    procedure, public :: UpdateAccVars => update_acc_vars_col_wf
+
   end type column_water_flux
   
   !-----------------------------------------------------------------------
@@ -605,6 +612,9 @@
     ! Temporary and annual sums
     real(r8), pointer :: annsum_npp                            (:)     => null() ! col annual sum of NPP, averaged from pft-level (gC/m2/yr)
     real(r8), pointer :: lag_npp                               (:)     => null() ! col lagged net primary production (gC/m2/s)
+    real(r8), pointer :: soilc_change                          (:)     => null() ! col total used C from soil        (gC/m2/s)
+    real(r8), pointer :: soilc_change_p                        (:)     => null() ! col total used C from soil        (gC/m2/s)
+
     ! Variables for clm_interface_funcsMod & pflotran
     real(r8), pointer :: externalc_to_decomp_cpools            (:,:,:) => null() ! col (gC/m3/s) net C fluxes associated with litter/som-adding/removal to decomp pools
     real(r8), pointer :: externalc_to_decomp_delta             (:)     => null() ! col (gC/m2) summarized net change of whole column C i/o to decomposing pool bwtn time-step
@@ -657,6 +667,7 @@
     ! deposition fluxes
     real(r8), pointer :: ndep_to_sminn                         (:)     => null() ! atmospheric N deposition to soil mineral N (gN/m2/s)
     real(r8), pointer :: nfix_to_sminn                         (:)     => null() ! symbiotic/asymbiotic N fixation to soil mineral N (gN/m2/s) 
+    real(r8), pointer :: ffix_to_sminn                         (:)     => null() ! free N fixation to soil mineral N (gN/m2/s) 
     real(r8), pointer :: nfix_to_ecosysn                       (:)     => null() ! total nitrogen fixation
     real(r8), pointer :: fert_to_sminn                         (:)     => null() ! fertilizer N to soil mineral N (gN/m2/s)
     real(r8), pointer :: soyfixn_to_sminn                      (:)     => null() ! soybean fixation to soil mineral N (gN/m2/s)
@@ -680,13 +691,15 @@
     real(r8), pointer :: actual_immob_vr                       (:,:)   => null() ! vertically-resolved actual N immobilization (gN/m3/s) at each level
     real(r8), pointer :: actual_immob                          (:)     => null() ! vert-int (diagnostic) actual N immobilization (gN/m2/s)
     real(r8), pointer :: sminn_to_plant_vr                     (:,:)   => null() ! vertically-resolved plant uptake of soil mineral N (gN/m3/s)
-    real(r8), pointer :: sminn_to_plant                        (:)     => null() ! vert-int (diagnostic) plant uptake of soil mineral N (gN/m2/s)
+    real(r8), pointer :: sminn_to_plant                        (:)     => null() ! vert-int (diagnostic) plant uptake of soil mineral N (gN/m2/s)  
     real(r8), pointer :: supplement_to_sminn_vr                (:,:)   => null() ! vertically-resolved supplemental N supply (gN/m3/s)
     real(r8), pointer :: supplement_to_sminn                   (:)     => null() ! vert-int (diagnostic) supplemental N supply (gN/m2/s)
     real(r8), pointer :: gross_nmin_vr                         (:,:)   => null() ! vertically-resolved gross rate of N mineralization (gN/m3/s)
     real(r8), pointer :: gross_nmin                            (:)     => null() ! vert-int (diagnostic) gross rate of N mineralization (gN/m2/s)
     real(r8), pointer :: net_nmin_vr                           (:,:)   => null() ! vertically-resolved net rate of N mineralization (gN/m3/s)
     real(r8), pointer :: net_nmin                              (:)     => null() ! vert-int (diagnostic) net rate of N mineralization (gN/m2/s)
+    real(r8), pointer :: sminn_to_plant_fun                    (:)     => null() ! vert-int (diagnostic) plant uptake of soil mineral N (gN/m2/s)
+
     real(r8), pointer :: sminn_no3_input_vr                    (:,:)   => null() ! no3 input, gN/m3/time step
     real(r8), pointer :: sminn_nh4_input_vr                    (:,:)   => null() ! nh4 input, gN/m3/time step
     real(r8), pointer :: sminn_no3_input                       (:)     => null() ! no3 input, gN/m2
@@ -718,6 +731,8 @@
     real(r8), pointer :: actual_immob_nh4                      (:)     => null() ! actual immobilization of NH4 (gN/m2/s)
     real(r8), pointer :: smin_no3_to_plant                     (:)     => null() ! plant uptake of soil NO3 (gN/m2/s)
     real(r8), pointer :: smin_nh4_to_plant                     (:)     => null() ! plant uptake of soil Nh4 (gN/m2/s)
+    !real(r8), pointer :: smin_no3_to_plant_fun                 (:)     => null() ! plant uptake of soil NO3 FUN (gN/m2/s)
+    !real(r8), pointer :: smin_nh4_to_plant_fun                 (:)     => null() ! plant uptake of soil Nh4 FUN (gN/m2/s)
     ! leaching fluxes
     real(r8), pointer :: smin_no3_leached_vr                   (:,:)   => null() ! vertically-resolved soil mineral NO3 loss to leaching (gN/m3/s)
     real(r8), pointer :: smin_no3_leached                      (:)     => null() ! soil mineral NO3 pool loss to leaching (gN/m2/s)
@@ -740,7 +755,11 @@
     real(r8), pointer :: soil_co2_prod                         (:,:)   => null() 
     real(r8), pointer :: fr_WFPS                               (:,:)   => null() 
     real(r8), pointer :: r_psi                                 (:,:)   => null() 
-    real(r8), pointer :: anaerobic_frac                        (:,:)   => null() 
+    real(r8), pointer :: anaerobic_frac                        (:,:)   => null()
+
+    real(r8), pointer :: sminn_to_plant_fun_no3_vr             (:,:)   => null() ! col total layer no3 uptake of FUN     (gN/m2/s)
+    real(r8), pointer :: sminn_to_plant_fun_nh4_vr             (:,:)  => null() ! col total layer nh4 uptake of FUN     (gN/m2/s) 
+
     ! (old version) denitrification fluxes
     real(r8), pointer :: sminn_to_denit_decomp_cascade_vr      (:,:,:) => null() ! vertically-resolved denitrification along decomp cascade (gN/m3/s) 
     real(r8), pointer :: sminn_to_denit_decomp_cascade         (:,:)   => null() ! vertically-integrated (diagnostic) denitrification along decomp cascade (gN/m2/s) 
@@ -775,6 +794,9 @@
     real(r8), pointer :: decomp_npools_transport_tendency      (:,:,:) => null() ! N tendency due to vertical transport in decomposing N pools (gN/m^3/s)
     ! all n pools involved in decomposition
     real(r8), pointer :: decomp_npools_sourcesink              (:,:,:) => null() ! (gN/m3) change in decomposing n pools 
+    real(r8), pointer :: sminn_to_plant_fun_vr                 (:,:)   => null() ! col total layer soil N uptake of FUN  (gN/m2/s)
+
+
     ! bgc interface/pflotran
     real(r8), pointer :: plant_ndemand                         (:)     => null() ! N flux required to support initial GPP (gN/m2/s)
     real(r8), pointer :: plant_ndemand_vr                      (:,:)   => null() ! vertically-resolved N flux required to support initial GPP (gN/m3/s)
@@ -852,12 +874,15 @@
     real(r8), pointer :: actual_immob_p                        (:)     ! vert-int (diagnostic) actual P immobilization (gP/m2/s)
     real(r8), pointer :: sminp_to_plant_vr                     (:,:)   ! vertically-resolved plant uptake of soil mineral P (gP/m3/s)
     real(r8), pointer :: sminp_to_plant                        (:)     ! vert-int (diagnostic) plant uptake of soil mineral P (gP/m2/s)
+    real(r8), pointer :: sminp_to_excess_vr                    (:,:)   ! vertically-resolved excess P (gP/m3/s)
+    real(r8), pointer :: sminp_to_excess                       (:)   ! vertically-resolved excess P (gP/m2/s)
     real(r8), pointer :: supplement_to_sminp_vr                (:,:)   ! vertically-resolved supplemental P supply (gP/m3/s)
     real(r8), pointer :: supplement_to_sminp                   (:)     ! vert-int (diagnostic) supplemental P supply (gP/m2/s)
     real(r8), pointer :: gross_pmin_vr                         (:,:)   ! vertically-resolved gross rate of P mineralization (gP/m3/s)
     real(r8), pointer :: gross_pmin                            (:)     ! vert-int (diagnostic) gross rate of P mineralization (gP/m2/s)
     real(r8), pointer :: net_pmin_vr                           (:,:)   ! vertically-resolved net rate of P mineralization (gP/m3/s)
     real(r8), pointer :: net_pmin                              (:)     ! vert-int (diagnostic) net rate of P mineralization (gP/m2/s)
+    real(r8), pointer :: sminp_to_plant_fun                    (:)   ! vertically-resolved plant uptake of soil mineral P (gP/m3/s)
     real(r8), pointer :: biochem_pmin_ppools_vr                (:,:,:) ! vertically-resolved biochemical P mineralization for each soi pool (gP/m3/s)
     real(r8), pointer :: biochem_pmin_vr                       (:,:)   ! vertically-resolved total biochemical P mineralization (gP/m3/s)
     real(r8), pointer :: biochem_pmin_to_ecosysp_vr            (:,:)   ! biochemical P mineralization directly goes to soil (gP/m3/s)
@@ -916,6 +941,8 @@
     real(r8), pointer :: decomp_ppools_leached                 (:,:)   ! P loss from vertical transport from each decomposing P pool (gP/m^2/s)
     real(r8), pointer :: decomp_ppools_transport_tendency      (:,:,:) ! P tendency due to vertical transport in decomposing P pools (gP/m^3/s)
     real(r8), pointer :: decomp_ppools_sourcesink              (:,:,:) ! (gP/m3) change in decomposing P pools
+    real(r8), pointer :: sminp_to_plant_fun_vr                 (:,:)   ! vertically-resolved plant uptake of soil mineral P (gP/m3/s)
+
     real(r8), pointer :: plant_pdemand                         (:)     ! P flux required to support initial GPP (gN/m2/s)
     real(r8), pointer :: plant_pdemand_vr                      (:,:)   ! vertically-resolved P flux required to support initial GPP (gP/m3/s)
     real(r8), pointer :: externalp_to_decomp_ppools            (:,:,:) ! net N fluxes associated with litter/som-adding/removal to decomp pools (gP/m3/s)
@@ -5181,6 +5208,7 @@
     allocate(this%mflx_et                (begc:endc,1:nlevgrnd))  ; this%mflx_et                         (:,:) = nan
     allocate(this%mflx_drain             (begc:endc,1:nlevgrnd))  ; this%mflx_drain                      (:,:) = nan
     allocate(this%mflx_recharge          (begc:endc))             ; this%mflx_recharge                   (:)   = nan
+    allocate(this%AnnET                  (begc:endc))             ; this%AnnET                           (:)   = nan
     
     !-----------------------------------------------------------------------
     ! initialize history fields for select members of col_wf
@@ -5302,6 +5330,14 @@
          avgflag='A', long_name='snow sinks (liquid water)', &
          ptr_col=this%snow_sinks, c2l_scale_type='urbanf')
 
+    this%AnnET(begc:endc) = spval
+    call hist_addfld1d (fname='AnnET',  units='mm/s',  &
+         avgflag='A', long_name='Annual ET', &
+         ptr_col=this%AnnET, c2l_scale_type='urbanf', default='inactive')
+
+
+
+
     !-----------------------------------------------------------------------
     ! set cold-start initial values for select members of col_wf
     !-----------------------------------------------------------------------
@@ -5403,6 +5439,117 @@
     !------------------------------------------------------------------------
     
   end subroutine col_wf_clean
+
+    subroutine init_acc_buffer_col_wf (this, bounds)
+    !
+    ! !DESCRIPTION:
+    ! Initialize accumulation buffer for all required module accumulated fields
+    ! This routine set defaults values that are then overwritten by the
+    ! restart file for restart or branch runs
+    !
+    ! !USES 
+    use clm_varcon  , only : spval
+    use accumulMod  , only : init_accum_field
+    !
+    ! !ARGUMENTS:
+    !class(waterflux_type) :: this
+    class(column_water_flux) :: this
+    type(bounds_type), intent(in) :: bounds  
+    !---------------------------------------------------------------------
+
+    if (use_fun) then
+   
+       call init_accum_field (name='AnnET', units='MM H2O/S', &
+            desc='365-day running mean of total ET', accum_type='runmean', accum_period=-365, &
+            subgrid_type='column', numlev=1, init_value=0._r8)
+
+    end if
+
+  end subroutine init_acc_buffer_col_wf
+
+  subroutine init_acc_vars_col_wf (this, bounds)
+    ! !DESCRIPTION:
+    ! Initialize module variables that are associated with
+    ! time accumulated fields. This routine is called for both an initial run
+    ! and a restart run (and must therefore must be called after the restart file 
+    ! is read in and the accumulation buffer is obtained)
+    !
+    ! !USES 
+    use accumulMod       , only : extract_accum_field
+    use clm_time_manager , only : get_nstep
+    !
+    ! !ARGUMENTS:
+    !class(waterflux_type) :: this
+    class(column_water_flux) :: this
+    type(bounds_type), intent(in) :: bounds  
+    !
+    ! !LOCAL VARIABLES:
+    integer  :: begc, endc
+    integer  :: nstep
+    integer  :: ier
+    real(r8), pointer :: rbufslp(:)  ! temporary
+    !---------------------------------------------------------------------
+    begc = bounds%begc; endc = bounds%endc
+
+    ! Allocate needed dynamic memory for single level patch field
+    allocate(rbufslp(begc:endc), stat=ier)
+
+    ! Determine time step
+    nstep = get_nstep()
+
+    if (use_fun) then
+       call extract_accum_field ('AnnET', rbufslp, nstep)
+       this%AnnET(begc:endc) = rbufslp(begc:endc)
+    end if
+
+    deallocate(rbufslp)
+
+  end subroutine init_acc_vars_col_wf
+
+
+
+  subroutine update_acc_vars_col_wf (this, bounds)
+    !
+    ! USES
+    use clm_time_manager, only : get_nstep
+    use accumulMod      , only : update_accum_field, extract_accum_field
+    !
+    ! !ARGUMENTS:
+    !class(waterflux_type)                 :: this
+    class(column_water_flux) :: this
+    type(bounds_type)      , intent(in) :: bounds  
+    !
+    ! !LOCAL VARIABLES:
+    integer :: g,c,p                     ! indices
+    integer :: dtime                     ! timestep size [seconds]
+    integer :: nstep                     ! timestep number
+    integer :: ier                       ! error status
+    integer :: begc, endc
+    real(r8), pointer :: rbufslp(:)      ! temporary single level - patch level
+    !---------------------------------------------------------------------
+
+    begc = bounds%begc; endc = bounds%endc
+
+    nstep = get_nstep()
+
+    ! Allocate needed dynamic memory for single level patch field
+
+    allocate(rbufslp(begc:endc), stat=ier)
+    
+    do c = begc,endc
+       rbufslp(c) = this%qflx_evap_tot(c)
+    end do
+    if (use_fun) then
+       ! Accumulate and extract AnnET (accumulates total ET as 365-day running mean)
+       call update_accum_field  ('AnnET', rbufslp, nstep)
+       call extract_accum_field ('AnnET', this%AnnET, nstep)
+    
+    end if
+
+    deallocate(rbufslp)
+    
+  end subroutine update_acc_vars_col_wf
+
   
   !------------------------------------------------------------------------
   ! Subroutines to initialize and clean column carbon flux data structure
@@ -5525,6 +5672,8 @@
     allocate(this%plant_to_cwd_cflux	             (begc:endc))                  ; this%plant_to_cwd_cflux		       (:)   = nan 
     allocate(this%annsum_npp                        (begc:endc))                  ; this%annsum_npp                   (:)   = nan 
     allocate(this%lag_npp                           (begc:endc))                  ; this%lag_npp                      (:)   = spval 
+    allocate(this%soilc_change                           (begc:endc))                  ; this%soilc_change                 (:)   = spval 
+    allocate(this%soilc_change_p                           (begc:endc))                  ; this%soilc_change_p               (:)   = spval
     allocate(this%externalc_to_decomp_cpools        (begc:endc,1:nlevdecomp_full,1:ndecomp_pools)) ; this%externalc_to_decomp_cpools(:,:,:) = spval
     allocate(this%externalc_to_decomp_delta         (begc:endc))                  ; this%externalc_to_decomp_delta    (:)   = spval    
     allocate(this%f_co2_soil_vr                     (begc:endc,1:nlevdecomp_full)); this%f_co2_soil_vr                (:,:) = nan  
@@ -6730,6 +6879,8 @@
             this%rr(c) + &
             this%hr(c)
 
+    
+
        ! total ecosystem respiration, autotrophic + heterotrophic (ER)
        this%er(c) = &
             this%ar(c) + &
@@ -7173,6 +7324,10 @@
        this%somc_deposit(i)              = value_column
        this%somc_yield(i)                = value_column
 
+       !Variable used by FUN
+       this%soilc_change(i)              = value_column
+       this%soilc_change_p(i)            = value_column
+
        ! Zero p2c column fluxes
        this%rr(i)                    = value_column  
        this%ar(i)                    = value_column  
@@ -7476,6 +7631,7 @@
     !-----------------------------------------------------------------------
     allocate(this%ndep_to_sminn                   (begc:endc))                   ; this%ndep_to_sminn	                 (:)   = nan
     allocate(this%nfix_to_sminn                   (begc:endc))                   ; this%nfix_to_sminn	                 (:)   = nan
+    allocate(this%ffix_to_sminn                   (begc:endc))                   ; this%ffix_to_sminn	                 (:)   = nan
     allocate(this%nfix_to_ecosysn                 (begc:endc))                   ; this%nfix_to_ecosysn                (:)   = nan
     allocate(this%fert_to_sminn                   (begc:endc))                   ; this%fert_to_sminn	                 (:)   = nan
     allocate(this%soyfixn_to_sminn                (begc:endc))                   ; this%soyfixn_to_sminn               (:)   = nan
@@ -7510,9 +7666,18 @@
     allocate(this%potential_immob_vr              (begc:endc,1:nlevdecomp_full)) ; this%potential_immob_vr             (:,:) = nan
     allocate(this%actual_immob_vr                 (begc:endc,1:nlevdecomp_full)) ; this%actual_immob_vr                (:,:) = nan
     allocate(this%sminn_to_plant_vr               (begc:endc,1:nlevdecomp_full)) ; this%sminn_to_plant_vr              (:,:) = nan
+
+
     allocate(this%supplement_to_sminn_vr          (begc:endc,1:nlevdecomp_full)) ; this%supplement_to_sminn_vr         (:,:) = nan
     allocate(this%gross_nmin_vr                   (begc:endc,1:nlevdecomp_full)) ; this%gross_nmin_vr                  (:,:) = nan
     allocate(this%net_nmin_vr                     (begc:endc,1:nlevdecomp_full)) ; this%net_nmin_vr                    (:,:) = nan
+
+
+    !!!FUN
+    allocate(this%sminn_to_plant_fun                  (begc:endc))                   ; this%sminn_to_plant_fun	          (:)   = nan
+    allocate(this%sminn_to_plant_fun_vr           (begc:endc,1:nlevdecomp_full)) ; this%sminn_to_plant_fun_vr          (:,:) = nan
+    allocate(this%sminn_to_plant_fun_no3_vr       (begc:endc,1:nlevdecomp_full)) ; this%sminn_to_plant_fun_no3_vr      (:,:) = nan
+    allocate(this%sminn_to_plant_fun_nh4_vr       (begc:endc,1:nlevdecomp_full)) ; this%sminn_to_plant_fun_nh4_vr      (:,:) = nan
     allocate(this%dwt_slash_nflux                 (begc:endc))                   ; this%dwt_slash_nflux                (:)   = nan
     allocate(this%dwt_conv_nflux                  (begc:endc))                   ; this%dwt_conv_nflux                 (:)   = nan
     allocate(this%dwt_prod10n_gain                (begc:endc))                   ; this%dwt_prod10n_gain               (:)   = nan
@@ -7541,6 +7706,8 @@
     allocate(this%smin_nh4_to_plant_vr            (begc:endc,1:nlevdecomp_full)) ; this%smin_nh4_to_plant_vr           (:,:) = nan
     allocate(this%smin_no3_to_plant               (begc:endc))                   ; this%smin_no3_to_plant              (:)   = nan
     allocate(this%smin_nh4_to_plant               (begc:endc))                   ; this%smin_nh4_to_plant              (:)   = nan
+    !allocate(this%smin_no3_to_plant_fun               (begc:endc))                   ; this%smin_no3_to_plant_fun          (:)   = nan
+    !allocate(this%smin_nh4_to_plant_fun               (begc:endc))                   ; this%smin_nh4_to_plant_fun          (:)   = nan
     allocate(this%f_nit                           (begc:endc))                   ; this%f_nit                          (:)   = nan
     allocate(this%f_denit                         (begc:endc))                   ; this%f_denit                        (:)   = nan
     allocate(this%n2_n2o_ratio_denit_vr           (begc:endc,1:nlevdecomp_full)) ; this%n2_n2o_ratio_denit_vr          (:,:) = nan
@@ -7607,6 +7774,8 @@
     allocate(this%actual_immob_nh4                (begc:endc))                    ; this%actual_immob_nh4              (:)   = nan
     allocate(this%smin_no3_to_plant               (begc:endc))                    ; this%smin_no3_to_plant             (:)   = nan
     allocate(this%smin_nh4_to_plant               (begc:endc))                    ; this%smin_nh4_to_plant             (:)   = nan 
+    !allocate(this%smin_no3_to_plant_fun               (begc:endc))                    ; this%smin_no3_to_plant_fun         (:)   = nan
+    !allocate(this%smin_nh4_to_plant_fun               (begc:endc))                    ; this%smin_nh4_to_plant_fun         (:)   = nan
     allocate(this%plant_to_litter_nflux           (begc:endc))                    ; this%plant_to_litter_nflux         (:)   = nan
     allocate(this%plant_to_cwd_nflux              (begc:endc))                    ; this%plant_to_cwd_nflux            (:)   = nan
     allocate(this%bgc_npool_ext_inputs_vr         (begc:endc,1:nlevdecomp_full,ndecomp_pools                )) ; this%bgc_npool_ext_inputs_vr          (:,:,:) = nan
@@ -7653,6 +7822,11 @@
          avgflag='A', long_name='symbiotic/asymbiotic N fixation to soil mineral N', &
          ptr_col=this%nfix_to_sminn)
 
+    this%ffix_to_sminn(begc:endc) = spval
+    call hist_addfld1d (fname='FFIX_TO_SMINN', units='gN/m^2/s', &
+         avgflag='A', long_name='free N fixation to soil mineral N', &
+         ptr_col=this%ffix_to_sminn)
+
     do k = 1, ndecomp_pools
        if ( decomp_cascade_con%is_litter(k) .or. decomp_cascade_con%is_cwd(k) ) then
           this%m_decomp_npools_to_fire(begc:endc,k) = spval
@@ -8191,6 +8365,11 @@
        call hist_addfld_decomp (fname='SMINN_TO_PLANT'//trim(vr_suffix), units='gN/m^3/s',  type2d='levdcmp', &
             avgflag='A', long_name='plant uptake of soil mineral N', &
             ptr_col=this%sminn_to_plant_vr, default='inactive')
+
+       !this%sminn_to_plant_fun_vr(begc:endc,:) = spval
+       !call hist_addfld_decomp (fname='SMINN_TO_PLANT_FUN'//trim(vr_suffix), units='gN/m^3/s',  type2d='levdcmp', &
+       !     avgflag='A', long_name='plant FUN uptake of soil mineral N', &
+       !     ptr_col=this%sminn_to_plant_fun_vr, default='inactive')
     end if
 
 
@@ -8233,6 +8412,11 @@
          avgflag='A', long_name='plant uptake of soil mineral N', &
          ptr_col=this%sminn_to_plant)
 
+    !this%sminn_to_plant_fun(begc:endc) = spval
+    !call hist_addfld1d (fname='SMINN_TO_PLANT_FUN', units='gN/m^2/s', &
+    !     avgflag='A', long_name='plant FUN uptake of soil mineral N', &
+    !     ptr_col=this%sminn_to_plant_fun)
+
     this%supplement_to_sminn(begc:endc) = spval
     call hist_addfld1d (fname='SUPPLEMENT_TO_SMINN', units='gN/m^2/s', &
          avgflag='A', long_name='supplemental N supply', &
@@ -8400,6 +8584,16 @@
             avgflag='A', long_name='plant uptake of NO3', &
             ptr_col=this%smin_no3_to_plant, default='inactive')
 
+       !this%smin_nh4_to_plant_fun(begc:endc) = spval
+       !call hist_addfld1d (fname='SMIN_NH4_TO_PLANT_FUN', units='gN/m^2/s', &
+       !     avgflag='A', long_name='plant uptake of NH4 FUN', &
+       !     ptr_col=this%smin_nh4_to_plant_fun, default='inactive')
+
+       !this%smin_no3_to_plant_fun(begc:endc) = spval
+       !call hist_addfld1d (fname='SMIN_NO3_TO_PLANT_FUN', units='gN/m^2/s', &
+       !     avgflag='A', long_name='plant uptake of NO3 FUN', &
+       !     ptr_col=this%smin_no3_to_plant_fun, default='inactive')
+
        this%f_ngas_decomp_vr(begc:endc,:) = spval
        call hist_addfld_decomp (fname='F_NGAS_DECOMP'//trim(vr_suffix), units='gN/m^3/s',  type2d='levdcmp', &
           avgflag='A', long_name='n gas emission from excess mineral N pool due to mineralization', &
@@ -8603,6 +8797,7 @@
           if (.not. use_nitrif_denitrif) then
              this%sminn_to_denit_excess_vr(i,j)      = value_column
              this%sminn_leached_vr(i,j)              = value_column
+             this%sminn_to_plant_fun_vr(i,j)         = value_column
           else
              this%f_nit_vr(i,j)                      = value_column
              this%f_denit_vr(i,j)                    = value_column
@@ -8654,6 +8849,8 @@
           this%net_nmin_vr(i,j)                      = value_column
           this%sminn_nh4_input_vr(i,j)               = value_column
           this%sminn_no3_input_vr(i,j)               = value_column
+          this%sminn_to_plant_fun_no3_vr(i,j)        = value_column
+          this%sminn_to_plant_fun_nh4_vr(i,j)        = value_column
        end do
     end do
 
@@ -8662,6 +8859,7 @@
 
        this%ndep_to_sminn(i)             = value_column
        this%nfix_to_sminn(i)             = value_column
+       this%ffix_to_sminn(i)             = value_column
        this%nfix_to_ecosysn(i)           = value_column
        this%fert_to_sminn(i)             = value_column
        this%soyfixn_to_sminn(i)          = value_column
@@ -8679,6 +8877,7 @@
        this%gross_nmin(i)                = value_column
        this%net_nmin(i)                  = value_column
        this%denit(i)                     = value_column
+       this%sminn_to_plant_fun(i)        = value_column
        if (use_nitrif_denitrif) then
           this%f_nit(i)                  = value_column
           this%pot_f_nit(i)              = value_column
@@ -8696,7 +8895,8 @@
           this%f_n2_soil(i)             = value_column
 
           this%smin_nh4_to_plant(i)      = value_column
-          this%smin_no3_to_plant(i)      = value_column          
+          this%smin_no3_to_plant(i)      = value_column     
+   
        else
           this%sminn_to_denit_excess(i)  = value_column
           this%sminn_leached(i)          = value_column
@@ -9388,10 +9588,12 @@
     allocate(this%hrv_deadstemp_to_prod100p        (begc:endc))                   ; this%hrv_deadstemp_to_prod100p     (:)   = nan
     allocate(this%hrv_cropp_to_prod1p              (begc:endc))                   ; this%hrv_cropp_to_prod1p           (:)   = nan
     allocate(this%sminp_to_plant                   (begc:endc))                   ; this%sminp_to_plant                (:)   = nan
+    allocate(this%sminp_to_plant_fun                   (begc:endc))                   ; this%sminp_to_plant_fun            (:)   = nan
     allocate(this%potential_immob_p                (begc:endc))                   ; this%potential_immob_p             (:)   = nan
     allocate(this%actual_immob_p                   (begc:endc))                   ; this%actual_immob_p                (:)   = nan
     allocate(this%gross_pmin                       (begc:endc))                   ; this%gross_pmin                    (:)   = nan
     allocate(this%net_pmin                         (begc:endc))                   ; this%net_pmin                      (:)   = nan
+    allocate(this%sminp_to_excess              (begc:endc))                   ; this%sminp_to_excess               (:)   = nan
     allocate(this%supplement_to_sminp              (begc:endc))                   ; this%supplement_to_sminp           (:)   = nan
     allocate(this%prod1p_loss                      (begc:endc))                   ; this%prod1p_loss                   (:)   = nan
     allocate(this%prod10p_loss                     (begc:endc))                   ; this%prod10p_loss                  (:)   = nan
@@ -9424,6 +9626,12 @@
     allocate(this%potential_immob_p_vr             (begc:endc,1:nlevdecomp_full)) ; this%potential_immob_p_vr          (:,:) = nan
     allocate(this%actual_immob_p_vr                (begc:endc,1:nlevdecomp_full)) ; this%actual_immob_p_vr             (:,:) = nan
     allocate(this%sminp_to_plant_vr                (begc:endc,1:nlevdecomp_full)) ; this%sminp_to_plant_vr             (:,:) = nan
+
+    allocate(this%sminp_to_plant_fun_vr            (begc:endc,1:nlevdecomp_full)) ; this%sminp_to_plant_fun_vr         (:,:) = nan
+
+
+    allocate(this%sminp_to_excess_vr           (begc:endc,1:nlevdecomp_full)) ; this%sminp_to_excess_vr        (:,:) = nan
+
     allocate(this%supplement_to_sminp_vr           (begc:endc,1:nlevdecomp_full)) ; this%supplement_to_sminp_vr        (:,:) = nan
     allocate(this%gross_pmin_vr                    (begc:endc,1:nlevdecomp_full)) ; this%gross_pmin_vr                 (:,:) = nan
     allocate(this%net_pmin_vr                      (begc:endc,1:nlevdecomp_full)) ; this%net_pmin_vr                   (:,:) = nan
@@ -9874,6 +10082,12 @@
        call hist_addfld_decomp (fname='SMINP_TO_PLANT'//trim(vr_suffix), units='gP/m^3/s',  type2d='levdcmp', &
             avgflag='A', long_name='plant uptake of soil mineral P', &
             ptr_col=this%sminp_to_plant_vr, default='inactive')
+       
+       !this%sminp_to_plant_fun_vr(begc:endc,:) = spval
+       !call hist_addfld_decomp (fname='SMINP_TO_PLANT_FUN'//trim(vr_suffix), units='gP/m^3/s',  type2d='levdcmp', &
+       !     avgflag='A', long_name='plant FUN uptake of soil mineral P', &
+       !     ptr_col=this%sminp_to_plant_fun_vr, default='inactive')
+
     end if
 
     if ( nlevdecomp_full > 1 ) then
@@ -9881,6 +10095,12 @@
        call hist_addfld_decomp (fname='SUPPLEMENT_TO_SMINP'//trim(vr_suffix), units='gP/m^3/s',  type2d='levdcmp', &
             avgflag='A', long_name='supplemental P supply', &
             ptr_col=this%supplement_to_sminp_vr, default='inactive')
+
+       this%sminp_to_excess_vr(begc:endc,:) = spval
+       call hist_addfld_decomp (fname='SMINP_TO_EXCESS'//trim(vr_suffix), units='gP/m^3/s',  type2d='levdcmp', &
+            avgflag='A', long_name='excess of P ', &
+            ptr_col=this%sminp_to_excess_vr, default='inactive')
+
     end if
 
     if ( nlevdecomp_full > 1 ) then
@@ -9919,6 +10139,11 @@
          avgflag='A', long_name='plant uptake of soil mineral P', &
          ptr_col=this%sminp_to_plant)
 
+    this%sminp_to_excess(begc:endc) = spval
+    call hist_addfld1d (fname='SMINP_TO_EXCESS', units='gP/m^2/s', &
+         avgflag='A', long_name='excess P ', &
+         ptr_col=this%sminp_to_excess)
+
     this%supplement_to_sminp(begc:endc) = spval
     call hist_addfld1d (fname='SUPPLEMENT_TO_SMINP', units='gP/m^2/s', &
          avgflag='A', long_name='supplemental P supply', &
@@ -10195,6 +10420,8 @@
           this%potential_immob_p_vr(i,j)             = value_column
           this%actual_immob_p_vr(i,j)                = value_column
           this%sminp_to_plant_vr(i,j)                = value_column
+          this%sminp_to_plant_fun_vr(i,j)            = value_column
+          this%sminp_to_excess_vr(i,j)               = value_column
           this%supplement_to_sminp_vr(i,j)           = value_column
           this%gross_pmin_vr(i,j)                    = value_column
           this%net_pmin_vr(i,j)                      = value_column
@@ -10223,6 +10450,8 @@
        this%potential_immob_p(i)         = value_column
        this%actual_immob_p(i)            = value_column
        this%sminp_to_plant(i)            = value_column
+       this%sminp_to_plant_fun(i)        = value_column
+       this%sminp_to_excess(i)           = value_column
        this%supplement_to_sminp(i)       = value_column
        this%gross_pmin(i)                = value_column
        this%net_pmin(i)                  = value_column
@@ -10402,6 +10631,7 @@
     !-----------------------------------------------------------------------
     do fc = 1,num_soilc
        c = filter_soilc(fc)
+       this%sminp_to_excess(c)     = 0._r8
        this%supplement_to_sminp(c) = 0._r8
        this%som_p_leached(c)       = 0._r8
        this%somp_erode(c)          = 0._r8
@@ -10565,6 +10795,10 @@
           this%supplement_to_sminp(c) = &
                this%supplement_to_sminp(c) + &
                this%supplement_to_sminp_vr(c,j) * dzsoi_decomp(j)
+
+          this%sminp_to_excess(c) = &
+               this%sminp_to_excess(c) + &
+               this%sminp_to_excess_vr(c,j) * dzsoi_decomp(j)
        end do
     end do
 
@@ -10644,8 +10878,14 @@
        do j = 1, nlevdecomp
           this%actual_immob_p(c)= this%actual_immob_p(c) + & 
                this%actual_immob_p_vr(c,j) * dzsoi_decomp(j)
-          this%smin_p_to_plant(c)= this%smin_p_to_plant(c) + & 
+          !if(.not.use_funp)then
+               this%smin_p_to_plant(c)= this%smin_p_to_plant(c) + & 
                this%sminp_to_plant_vr(c,j) * dzsoi_decomp(j)
+          !else 
+          !     this%smin_p_to_plant(c)= this%smin_p_to_plant(c) + & 
+          !     this%sminp_to_plant_fun_vr(c,j) * dzsoi_decomp(j)
+          !end if 
+
           this%plant_to_litter_pflux(c) = &
                this%plant_to_litter_pflux(c)  + &
                this%phenology_p_to_litr_met_p(c,j)* dzsoi_decomp(j) + &
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/data_types/VegetationDataType.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/data_types/VegetationDataType.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/data_types/VegetationDataType.F90	2020-06-10 13:57:17.332178691 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/data_types/VegetationDataType.F90	2020-07-22 18:27:01.273294015 -0400
@@ -18,7 +18,7 @@
   use clm_varcon      , only : c13ratio, c14ratio
   use landunit_varcon , only : istsoil, istcrop
   use pftvarcon       , only : npcropmin, noveg, nstor
-  use clm_varctl      , only : iulog, use_cn, spinup_state, spinup_mortality_factor, use_fates  
+  use clm_varctl      , only : iulog, use_cn, spinup_state, spinup_mortality_factor, use_fates, use_fun, use_funp  
   use clm_varctl      , only : nu_com, use_crop, use_c13
   use clm_varctl      , only : use_lch4, use_betr
   use histFileMod     , only : hist_addfld1d, hist_addfld2d, no_snow_normal
@@ -118,6 +118,8 @@
     real(r8), pointer :: leafc              (:) => null() ! (gC/m2) leaf C
     real(r8), pointer :: leafc_storage      (:) => null() ! (gC/m2) leaf C storage
     real(r8), pointer :: leafc_xfer         (:) => null() ! (gC/m2) leaf C transfer
+    real(r8), pointer :: leafc_storage_xfer_acc   (:) => null() ! (gC/m2) Accmulated leaf C transfer
+    real(r8), pointer :: storage_cdemand    (:) => null() ! (gC/m2)       C use from the C storage pool
     real(r8), pointer :: frootc             (:) => null() ! (gC/m2) fine root C
     real(r8), pointer :: frootc_storage     (:) => null() ! (gC/m2) fine root C storage
     real(r8), pointer :: frootc_xfer        (:) => null() ! (gC/m2) fine root C transfer
@@ -167,6 +169,8 @@
     real(r8), pointer :: leafn                  (:)   => null()  ! (gN/m2) leaf N 
     real(r8), pointer :: leafn_storage          (:)   => null()  ! (gN/m2) leaf N storage
     real(r8), pointer :: leafn_xfer             (:)   => null()  ! (gN/m2) leaf N transfer
+    real(r8), pointer :: leafn_storage_xfer_acc (:)   => null()  ! (gN/m2) Accmulated leaf N transfer
+    real(r8), pointer :: storage_ndemand       (:)   => null()   ! (gN/m2) N use from the N storage pool
     real(r8), pointer :: frootn                 (:)   => null()  ! (gN/m2) fine root N
     real(r8), pointer :: frootn_storage         (:)   => null()  ! (gN/m2) fine root N storage
     real(r8), pointer :: frootn_xfer            (:)   => null()  ! (gN/m2) fine root N transfer
@@ -255,6 +259,8 @@
     real(r8), pointer :: leafp                  (:)     ! (gP/m2) leaf P 
     real(r8), pointer :: leafp_storage          (:)     ! (gP/m2) leaf P storage
     real(r8), pointer :: leafp_xfer             (:)     ! (gP/m2) leaf P transfer
+    real(r8), pointer :: leafp_storage_xfer_acc (:)     ! (gP/m2) Accmulated leaf P transfer
+     real(r8), pointer :: storage_pdemand       (:)     ! (gP/m2) P use from the P storage pool
     real(r8), pointer :: frootp                 (:)     ! (gP/m2) fine root P
     real(r8), pointer :: frootp_storage         (:)     ! (gP/m2) fine root P storage
     real(r8), pointer :: frootp_xfer            (:)     ! (gP/m2) fine root P transfer
@@ -503,11 +509,14 @@
                                                                  
     ! leaf and fine root litterfall fluxes                          
     real(r8), pointer :: leafc_to_litter                     (:) => null()    ! leaf C litterfall (gC/m2/s)
+    real(r8), pointer :: leafc_to_litter_fun                 (:) => null()    ! leaf C litterfall used by FUN (gC/m2/s)
+    real(r8), pointer :: leafc_to_litter_funp                (:) => null()    ! leaf C litterfall used by FUN-P (gC/m2/s)
     real(r8), pointer :: frootc_to_litter                    (:) => null()    ! fine root C litterfall (gC/m2/s)
     real(r8), pointer :: livestemc_to_litter                 (:) => null()    ! live stem C litterfall (gC/m2/s)
     real(r8), pointer :: grainc_to_food                      (:) => null()    ! grain C to food for prognostic crop(gC/m2/s)
                                                                  
-    ! maintenance respiration fluxes                             
+    ! maintenance respiration fluxes     
+    ! real(r8), pointer :: cpool_to_resp                      (:) => null()   ! CNflex excess C maintenance respiration (gC/m2/s)                         
     real(r8), pointer :: leaf_mr                             (:) => null()    ! leaf maintenance respiration (gC/m2/s)
     real(r8), pointer :: froot_mr                            (:) => null()    ! fine root maintenance respiration (gC/m2/s)
     real(r8), pointer :: livestem_mr                         (:) => null()    ! live stem maintenance respiration (gC/m2/s)
@@ -652,6 +661,40 @@
     ! For comparison with RAINFOR wood productivity data         
     real(r8), pointer :: agwdnpp                             (:) => null()    !(gC/m2/s) aboveground NPP
 
+    !Variables used by FUN
+     real(r8), pointer :: npp_Nactive                        (:) => null()     ! C used by mycorrhizal uptake    (gC/m2/s)
+     real(r8), pointer :: npp_burnedoff                      (:) => null()     ! C that cannot be used for N uptake   (gC/m2/s)
+     real(r8), pointer :: npp_Nnonmyc                        (:) => null()     ! C used by non-myc uptake        (gC/m2/s)
+     real(r8), pointer :: npp_Nam                            (:) => null()     ! C used by AM plant              (gC/m2/s)
+     real(r8), pointer :: npp_Necm                           (:) => null()     ! C used by ECM plant             (gC/m2/s)
+     real(r8), pointer :: npp_Nactive_no3                    (:) => null()     ! C used by mycorrhizal uptake    (gC/m2/s)
+     real(r8), pointer :: npp_Nactive_nh4                    (:) => null()     ! C used by mycorrhizal uptake    (gC/m2/s)
+     real(r8), pointer :: npp_Nnonmyc_no3                    (:) => null()     ! C used by non-myc               (gC/m2/s)
+     real(r8), pointer :: npp_Nnonmyc_nh4                    (:) => null()     ! C used by non-myc               (gC/m2/s)
+     real(r8), pointer :: npp_Nam_no3                        (:) => null()     ! C used by AM plant              (gC/m2/s)
+     real(r8), pointer :: npp_Nam_nh4                        (:) => null()     ! C used by AM plant              (gC/m2/s)
+     real(r8), pointer :: npp_Necm_no3                       (:) => null()     ! C used by ECM plant             (gC/m2/s)
+     real(r8), pointer :: npp_Necm_nh4                       (:) => null()     ! C used by ECM plant             (gC/m2/s)
+     real(r8), pointer :: npp_Nfix                           (:) => null()     ! C used by Symbiotic BNF         (gC/m2/s)
+     real(r8), pointer :: npp_Nretrans                       (:) => null()     ! C used by retranslocation       (gC/m2/s)
+     real(r8), pointer :: npp_Nuptake                        (:) => null()     ! Total C used by N uptake in FUN (gC/m2/s)
+     real(r8), pointer :: npp_growth                         (:) => null()     ! Total C u for growth in FUN      (gC/m2/s)   
+     real(r8), pointer :: leafc_change                       (:) => null()     ! Total used C from leaves        (gC/m2/s)
+     real(r8), pointer :: soilc_change                       (:) => null()     ! Total used C from soil          (gC/m2/s)
+
+    !Variables used by FUN-P
+     real(r8), pointer :: npp_Pactive                        (:) => null()     ! C used by mycorrhizal uptake    (gC/m2/s)
+     real(r8), pointer :: npp_burnedoff_p                    (:) => null()     ! C that cannot be used for N uptake   (gC/m2/s)
+     real(r8), pointer :: npp_Pnonmyc                        (:) => null()     ! C used by non-myc uptake        (gC/m2/s)
+     real(r8), pointer :: npp_Pam                            (:) => null()     ! C used by AM plant              (gC/m2/s)
+     real(r8), pointer :: npp_Pecm                           (:) => null()     ! C used by ECM plant             (gC/m2/s)
+     real(r8), pointer :: npp_Pretrans                       (:) => null()     ! C used by retranslocation       (gC/m2/s)
+     real(r8), pointer :: npp_Puptake                        (:) => null()     ! Total C used by N uptake in FUN (gC/m2/s)
+     real(r8), pointer :: npp_growth_p                       (:) => null()     ! Total C u for growth in FUN      (gC/m2/s)   
+     real(r8), pointer :: leafc_change_p                     (:) => null()     ! Total used C from leaves for P      (gC/m2/s)
+     real(r8), pointer :: soilc_change_p                     (:) => null()     ! Total used C from soil for P         (gC/m2/s)
+ 
+
   contains
     procedure, public :: Init       => veg_cf_init
     procedure, public :: Restart    => veg_cf_restart
@@ -774,7 +817,8 @@
     real(r8), pointer :: frootn_to_retransn                  (:)   => null()  ! fine root N to retranslocated N pool (gN/m2/s)
     real(r8), pointer :: frootn_to_litter                    (:)   => null()  ! fine root N litterfall (gN/m2/s)
     ! allocation fluxes
-    real(r8), pointer :: retransn_to_npool                   (:)   => null()  ! deployment of retranslocated N (gN/m2/s)       
+    real(r8), pointer :: retransn_to_npool                   (:)   => null()  ! deployment of retranslocated N (gN/m2/s) 
+    real(r8), pointer :: free_retransn_to_npool                   (:)   => null()  ! deployment of free retranslocated N (gN/m2/s)       
     real(r8), pointer :: sminn_to_npool                      (:)   => null()  ! deployment of soil mineral N uptake (gN/m2/s)
     real(r8), pointer :: npool_to_grainn                     (:)   => null()  ! allocation to grain N for prognostic crop (gN/m2/s)
     real(r8), pointer :: npool_to_grainn_storage             (:)   => null()  ! allocation to grain N storage for prognostic crop (gN/m2/s)
@@ -810,6 +854,8 @@
     real(r8), pointer :: ndeploy                             (:)   => null()  ! total N deployed to growth and storage (gN/m2/s)
     real(r8), pointer :: wood_harvestn                       (:)   => null()  ! total N losses to wood product pools (gN/m2/s)
     ! deposition fluxes
+    real(r8), pointer :: ninputs                             (:)   => null()  ! total N inputs to pft-level (gN/m2/s)
+    real(r8), pointer :: noutputs                            (:)   => null()  ! total N outputs from pft-level (gN/m2/s)
     real(r8), pointer :: nfix_to_plantn                      (:)   => null()  ! nitrogen fixation goes to plant
     ! dynamic landcover fluxes
     real(r8), pointer :: crop_seedn_to_leaf                  (:)   => null()  ! (gN/m2/s) seed source to leaf, for crops
@@ -824,6 +870,40 @@
     real(r8), pointer :: plant_ndemand                       (:)   => null()  ! N flux required to support initial GPP (gN/m2/s)
     real(r8), pointer :: avail_retransn                      (:)   => null()  ! N flux available from retranslocation pool (gN/m2/s)
     real(r8), pointer :: plant_nalloc                        (:)   => null()  ! total allocated N flux (gN/m2/s)
+
+     !Variables used by FUN
+     real(r8), pointer :: plant_ndemand_retrans               (:)   => null()     ! The N demand pool generated for FUN2.0; mainly used for deciduous trees (gN/m2/s)
+     real(r8), pointer :: plant_ndemand_season                (:)   => null()     ! The N demand pool for seasonal deciduous (gN/m2/s)
+     real(r8), pointer :: plant_ndemand_stress                (:)   => null()     ! The N demand pool for stress deciduous   (gN/m2/s)
+     real(r8), pointer :: Nactive                             (:)   => null()     ! N acquired by mycorrhizal uptake  (gN/m2/s)
+     real(r8), pointer :: Nnonmyc                             (:)   => null()     ! N acquired by non-myc uptake      (gN/m2/s)
+     real(r8), pointer :: Nam                                 (:)   => null()     ! N acquired by AM plant            (gN/m2/s)
+     real(r8), pointer :: Necm                                (:)   => null()     ! N acquired by ECM plant           (gN/m2/s)
+     real(r8), pointer :: Nactive_no3                         (:)   => null()     ! N acquired by mycorrhizal uptake  (gN/m2/s)
+     real(r8), pointer :: Nactive_nh4                         (:)   => null()     ! N acquired by mycorrhizal uptake  (gN/m2/s)
+     real(r8), pointer :: Nnonmyc_no3                         (:)   => null()     ! N acquired by non-myc             (gN/m2/s)
+     real(r8), pointer :: Nnonmyc_nh4                         (:)   => null()     ! N acquired by non-myc             (gN/m2/s)
+     real(r8), pointer :: Nam_no3                             (:)   => null()     ! N acquired by AM plant            (gN/m2/s)
+     real(r8), pointer :: Nam_nh4                             (:)   => null()     ! N acquired by AM plant            (gN/m2/s)
+     real(r8), pointer :: Necm_no3                            (:)   => null()     ! N acquired by ECM plant           (gN/m2/s)
+     real(r8), pointer :: Necm_nh4                            (:)   => null()     ! N acquired by ECM plant           (gN/m2/s)
+     real(r8), pointer :: Nfix                                (:)   => null()     ! N acquired by Symbiotic BNF       (gN/m2/s)
+     real(r8), pointer :: Npassive                            (:)   => null()     ! N acquired by passive uptake      (gN/m2/s)
+     real(r8), pointer :: Nretrans                            (:)   => null()     ! N acquired by retranslocation     (gN/m2/s)
+     real(r8), pointer :: Nretrans_org                        (:)   => null()     ! N acquired by retranslocation     (gN/m2/s)
+     real(r8), pointer :: Nretrans_season                     (:)   => null()     ! N acquired by retranslocation     (gN/m2/s)
+     real(r8), pointer :: Nretrans_stress                     (:)   => null()     ! N acquired by retranslocation     (gN/m2/s)
+     real(r8), pointer :: Nuptake                             (:)   => null()     ! Total N uptake of FUN             (gN/m2/s)
+     real(r8), pointer :: sminn_to_plant_fun                  (:)   => null()     ! Total soil N uptake of FUN        (gN/m2/s)
+     real(r8), pointer :: sminn_to_plant_fun_vr               (:,:) => null()  ! Total layer soil N uptake of FUN  (gN/m2/s)
+     real(r8), pointer :: sminn_to_plant_fun_no3_vr           (:,:) => null()  ! Total layer no3 uptake of FUN     (gN/m2/s)
+     real(r8), pointer :: sminn_to_plant_fun_nh4_vr           (:,:) => null()  ! Total layer nh4 uptake of FUN     (gN/m2/s)
+     real(r8), pointer :: cost_nfix                           (:) => null()    ! Average cost of fixation          (gN/m2/s)
+     real(r8), pointer :: cost_nactive                        (:) => null()    ! Average cost of active uptake     (gN/m2/s)
+     real(r8), pointer :: cost_nretrans                       (:) => null()    ! Average cost of retranslocation   (gN/m2/s)
+     real(r8), pointer :: cost_nnonmyc                        (:) => null()    ! Average cost of non-mycorrhizal   (gN/m2/s)
+     real(r8), pointer :: nuptake_npp_fraction                (:) => null()   ! frac of npp spent on N acquisition   (gN/m2/s)
+
     real(r8), pointer :: smin_no3_to_plant                   (:)   => null()  ! pft level plant uptake of soil NO3 (gN/m2/s) BGC mode
     real(r8), pointer :: smin_nh4_to_plant                   (:)   => null()  ! pft level plant uptake of soil Nh4 (gN/m2/s) BGC mode
     real(r8), pointer :: sminn_to_plant                      (:)   => null()  ! pft level plant uptake of soil N (gN/m2/s) CN mode
@@ -950,7 +1030,8 @@
     real(r8), pointer :: leafp_to_retransp                   (:)     ! leaf P to retranslocated P pool (gP/m2/s)
     real(r8), pointer :: frootp_to_retransp                  (:)     ! fine root P to retranslocated P pool (gP/m2/s)
     real(r8), pointer :: frootp_to_litter                    (:)     ! fine root P litterfall (gP/m2/s)
-    real(r8), pointer :: retransp_to_ppool                   (:)     ! deployment of retranslocated P (gP/m2/s)       
+    real(r8), pointer :: retransp_to_ppool                   (:)     ! deployment of retranslocated P (gP/m2/s)
+   real(r8), pointer :: free_retransp_to_ppool               (:)     ! deployment of free retranslocated P (gP/m2/s)         
     real(r8), pointer :: sminp_to_ppool                      (:)     ! deployment of soil mineral P uptake (gP/m2/s)
     real(r8), pointer :: ppool_to_grainp                     (:)     ! allocation to grain P for prognostic crop (gP/m2/s)
     real(r8), pointer :: ppool_to_grainp_storage             (:)     ! allocation to grain P storage for prognostic crop (gP/m2/s)
@@ -980,6 +1061,8 @@
     real(r8), pointer :: livecrootp_to_deadcrootp            (:)     ! live coarse root P turnover (gP/m2/s)
     real(r8), pointer :: livecrootp_to_retransp              (:)     ! live coarse root P to retranslocated P pool (gP/m2/s)
     real(r8), pointer :: pdeploy                             (:)     ! total P deployed to growth and storage (gP/m2/s)
+    real(r8), pointer :: pinputs                             (:)     ! total P inputs to pft-level (gP/m2/s)
+    real(r8), pointer :: poutputs                            (:)     ! total P outputs from pft-level (gP/m2/s)
     real(r8), pointer :: wood_harvestp                       (:)     ! total P losses to wood product pools (gP/m2/s)
     real(r8), pointer :: biochem_pmin_to_plant               (:)     ! biochemical P mineralization directly goes to plant (gP/m2/s)
     real(r8), pointer :: crop_seedp_to_leaf                  (:)     ! (gP/m2/s) seed source to leaf, for crops
@@ -993,6 +1076,28 @@
     real(r8), pointer :: plant_pdemand                       (:)     ! P flux required to support initial GPP (gP/m2/s)
     real(r8), pointer :: avail_retransp                      (:)     ! P flux available from retranslocation pool (gP/m2/s)
     real(r8), pointer :: plant_palloc                        (:)     ! total allocated P flux (gP/m2/s)
+     !Variables used by FUN-P
+     real(r8), pointer :: plant_pdemand_retrans               (:)   => null()     ! The P demand pool generated for FUN2.0; mainly used for deciduous trees (gP/m2/s)
+     real(r8), pointer :: plant_pdemand_season                (:)   => null()     ! The P demand pool for seasonal deciduous (gP/m2/s)
+     real(r8), pointer :: plant_pdemand_stress                (:)   => null()     ! The P demand pool for stress deciduous   (gP/m2/s)
+     real(r8), pointer :: Pactive                             (:)   => null()     ! P acquired by mycorrhizal uptake  (gP/m2/s)
+     real(r8), pointer :: Pnonmyc                             (:)   => null()     ! P acquired by non-myc uptake      (gP/m2/s)
+     real(r8), pointer :: Pam                                 (:)   => null()     ! P acquired by AM plant            (gP/m2/s)
+     real(r8), pointer :: Pecm                                (:)   => null()     ! P acquired by ECM plant           (gP/m2/s)
+     real(r8), pointer :: Ppassive                            (:)   => null()     ! P acquired by passive uptake      (gP/m2/s)
+     real(r8), pointer :: Pretrans                            (:)   => null()     ! P acquired by retranslocation     (gP/m2/s)
+     real(r8), pointer :: Pretrans_org                        (:)   => null()     ! P acquired by retranslocation     (gP/m2/s)
+     real(r8), pointer :: Pretrans_season                     (:)   => null()     ! N acquired by retranslocation     (gP/m2/s)
+     real(r8), pointer :: Pretrans_stress                     (:)   => null()     ! N acquired by retranslocation     (gP/m2/s)
+     real(r8), pointer :: Puptake                             (:)   => null()     ! Total P uptake of FUN             (gP/m2/s)
+     real(r8), pointer :: sminp_to_plant_fun                  (:)   => null()     ! Total soil N uptake of FUN        (gP/m2/s)
+     real(r8), pointer :: sminp_to_plant_fun_vr               (:,:) => null()  ! Total layer soil N uptake of FUN  (gP/m2/s)
+     real(r8), pointer :: cost_pactive                        (:) => null()    ! Average cost of active uptake     (gP/m2/s)
+     real(r8), pointer :: cost_pretrans                       (:) => null()    ! Average cost of retranslocation   (gP/m2/s)
+     real(r8), pointer :: cost_pnonmyc                        (:) => null()    ! Average cost of non-mycorrhizal   (gP/m2/s)
+     real(r8), pointer :: puptake_npp_fraction                (:) => null()   ! frac of npp spent on P acquisition   (gP/m2/s)
+
+
     real(r8), pointer :: sminp_to_plant                      (:)     ! plant p uptake (gP/m2/s)
     real(r8), pointer :: plant_pdemand_vr                    (:,:)   ! plant P demand
     real(r8), pointer :: prev_leafp_to_litter                (:)     ! previous timestep leaf P litterfall flux (gP/m2/s)
@@ -1898,6 +2003,8 @@
        allocate(this%leafc              (begp :endp))   ;  this%leafc              (:)   = nan
        allocate(this%leafc_storage      (begp :endp))   ;  this%leafc_storage      (:)   = nan
        allocate(this%leafc_xfer         (begp :endp))   ;  this%leafc_xfer         (:)   = nan
+       allocate(this%leafc_storage_xfer_acc(begp :endp));     this%leafc_storage_xfer_acc (:)   = nan
+       allocate(this%storage_cdemand    (begp :endp))   ;     this%storage_cdemand    (:)   = nan
        allocate(this%frootc             (begp :endp))   ;  this%frootc             (:)   = nan
        allocate(this%frootc_storage     (begp :endp))   ;  this%frootc_storage     (:)   = nan
        allocate(this%frootc_xfer        (begp :endp))   ;  this%frootc_xfer        (:)   = nan
@@ -1958,6 +2065,16 @@
              avgflag='A', long_name='leaf C transfer', &
              ptr_patch=this%leafc_xfer, default='inactive')
 
+       this%leafc_storage_xfer_acc(begp:endp) = spval
+       call hist_addfld1d (fname='LEAFC_STORAGE_XFER_ACC', units='gC/m^2', &
+             avgflag='A', long_name='accmulated leaf C transfer', &
+             ptr_patch=this%leafc_storage_xfer_acc, default='inactive')
+
+       this%storage_cdemand(begp:endp) = spval
+       call hist_addfld1d (fname='STORAGE_CDEMAND', units='gC/m^2', &
+             avgflag='A', long_name='C use from the C storage pool', &
+             ptr_patch=this%storage_cdemand, default='inactive')
+
        this%frootc(begp:endp) = spval
        call hist_addfld1d (fname='FROOTC', units='gC/m^2', &
              avgflag='A', long_name='fine root C', &
@@ -2118,6 +2235,17 @@
              avgflag='A', long_name='C13 leaf C transfer', &
              ptr_patch=this%leafc_xfer, default='inactive')
 
+       this%leafc_storage_xfer_acc(begp:endp) = spval
+       call hist_addfld1d (fname='C13_LEAFC_STORAGE_XFER_ACC', units='gC/m^2', &
+             avgflag='A', long_name='accmulated leaf C13 transfer', &
+             ptr_patch=this%leafc_storage_xfer_acc, default='inactive')
+
+       this%storage_cdemand(begp:endp) = spval
+       call hist_addfld1d (fname='C13_STORAGE_CDEMAND', units='gC/m^2', &
+             avgflag='A', long_name='C13 use from the C storage pool', &
+             ptr_patch=this%storage_cdemand, default='inactive')
+
+
        this%frootc(begp:endp) = spval
        call hist_addfld1d (fname='C13_FROOTC', units='gC13/m^2', &
              avgflag='A', long_name='C13 fine root C', &
@@ -2268,6 +2396,17 @@
              avgflag='A', long_name='C14 leaf C transfer', &
              ptr_patch=this%leafc_xfer, default='inactive')
 
+       this%leafc_storage_xfer_acc(begp:endp) = spval
+       call hist_addfld1d (fname='C14_LEAFC_STORAGE_XFER_ACC', units='gC/m^2', &
+             avgflag='A', long_name='accmulated leaf C14 transfer', &
+             ptr_patch=this%leafc_storage_xfer_acc, default='inactive')
+
+       this%storage_cdemand(begp:endp) = spval
+       call hist_addfld1d (fname='C14_STORAGE_CDEMAND', units='gC/m^2', &
+             avgflag='A', long_name='C14 use from the C storage pool', &
+             ptr_patch=this%storage_cdemand, default='inactive')
+
+
        this%frootc(begp:endp) = spval
        call hist_addfld1d (fname='C14_FROOTC', units='gC14/m^2', &
              avgflag='A', long_name='C14 fine root C', &
@@ -2433,6 +2572,8 @@
                 end if
              end if
              this%leafc_xfer(p) = 0._r8
+             this%leafc_storage_xfer_acc(p) = 0._r8
+             this%storage_cdemand(p)   = 0._r8
 
              this%frootc(p)            = 0._r8 
              this%frootc_storage(p)    = 0._r8 
@@ -2545,6 +2686,8 @@
           this%leafc(p)                = value_veg
           this%leafc_storage(p)        = value_veg
           this%leafc_xfer(p)           = value_veg
+          this%leafc_storage_xfer_acc(p) = value_veg
+          this%storage_cdemand(p)      = value_veg
           this%frootc(p)               = value_veg
           this%frootc_storage(p)       = value_veg
           this%frootc_xfer(p)          = value_veg
@@ -2642,6 +2785,14 @@
                dim1name='pft', long_name='', units='', &
                interpinic_flag='interp', readvar=readvar, data=this%leafc_xfer) 
 
+          call restartvar(ncid=ncid, flag=flag, varname='leafc_storage_xfer_acc', xtype=ncd_double,  &
+               dim1name='pft', long_name='', units='', &
+               interpinic_flag='interp', readvar=readvar, data=this%leafc_storage_xfer_acc)
+
+          call restartvar(ncid=ncid, flag=flag, varname='storage_cdemand', xtype=ncd_double,  &
+               dim1name='pft', long_name='', units='', &
+               interpinic_flag='interp', readvar=readvar, data=this%storage_cdemand)
+
           call restartvar(ncid=ncid, flag=flag, varname='frootc', xtype=ncd_double,  &
                dim1name='pft', long_name='', units='', &
                interpinic_flag='interp', readvar=readvar, data=this%frootc) 
@@ -2823,6 +2974,34 @@
              end do
           end if
 
+          call restartvar(ncid=ncid, flag=flag, varname='leafc_storage_xfer_acc_13', xtype=ncd_double,  &
+               dim1name='pft', long_name='', units='', &
+               interpinic_flag='interp', readvar=readvar, data=this%leafc_storage_xfer_acc) 
+          if (flag=='read' .and. .not. readvar) then
+             write(iulog,*) 'initializing this%leafc_storage_xfer_acc with atmospheric c13 value'
+             do i = bounds%begp,bounds%endp
+                if (veg_vp%c3psn(veg_pp%itype(i)) == 1._r8) then
+                   this%leafc_storage_xfer_acc(i) = c12_veg_cs%leafc_storage_xfer_acc(i) * c3_r2
+                else
+                   this%leafc_storage_xfer_acc(i) = c12_veg_cs%leafc_storage_xfer_acc(i) * c4_r2
+                endif
+             end do
+          end if
+
+          call restartvar(ncid=ncid, flag=flag, varname='storage_cdemand_13', xtype=ncd_double,  &
+               dim1name='pft', long_name='', units='', &
+               interpinic_flag='interp', readvar=readvar, data=this%storage_cdemand) 
+          if (flag=='read' .and. .not. readvar) then
+             write(iulog,*) 'initializing this%storage_cdemand with atmospheric c13 value'
+             do i = bounds%begp,bounds%endp
+                if (veg_vp%c3psn(veg_pp%itype(i)) == 1._r8) then
+                   this%storage_cdemand(i) = c12_veg_cs%storage_cdemand(i) * c3_r2
+                else
+                   this%storage_cdemand(i) = c12_veg_cs%storage_cdemand(i) * c4_r2
+                endif
+             end do
+          end if
+
           call restartvar(ncid=ncid, flag=flag, varname='frootc_13', xtype=ncd_double,  &
                dim1name='pft', long_name='', units='', &
                interpinic_flag='interp', readvar=readvar, data=this%frootc) 
@@ -3164,6 +3343,32 @@
              end do
           end if
 
+          call restartvar(ncid=ncid, flag=flag, varname='leafc_storage_xfer_acc_14', xtype=ncd_double,  &
+               dim1name='pft', long_name='', units='', &
+               interpinic_flag='interp', readvar=readvar, data=this%leafc_storage_xfer_acc) 
+          if (flag=='read' .and. .not. readvar) then
+             write(iulog,*) 'initializing this%leafc_storage_xfer_acc with atmospheric c14 value'
+             do i = bounds%begp,bounds%endp
+                if (this%leafc_storage_xfer_acc(i) /= spval .and. .not. isnan(this%leafc_storage_xfer_acc(i)) ) then
+                   this%leafc_storage_xfer_acc(i) = c12_veg_cs%leafc_storage_xfer_acc(i) * c14ratio
+                endif
+             end do
+          end if
+
+          call restartvar(ncid=ncid, flag=flag, varname='storage_cdemand_14', xtype=ncd_double,  &
+               dim1name='pft', long_name='', units='', &
+               interpinic_flag='interp', readvar=readvar, data=this%storage_cdemand) 
+          if (flag=='read' .and. .not. readvar) then
+             write(iulog,*) 'initializing this%storage_cdemand with atmospheric c14 value'
+             do i = bounds%begp,bounds%endp
+                if (this%storage_cdemand(i) /= spval .and. .not. isnan(this%storage_cdemand(i)) ) then
+                   this%storage_cdemand(i) = c12_veg_cs%storage_cdemand(i) * c14ratio
+                endif
+             end do
+          end if
+
+
+
           call restartvar(ncid=ncid, flag=flag, varname='frootc_14', xtype=ncd_double,  &
                dim1name='pft', long_name='', units='', &
                interpinic_flag='interp', readvar=readvar, data=this%frootc) 
@@ -3651,6 +3856,8 @@
     allocate(this%leafn                  (begp:endp))           ; this%leafn               (:)   = nan
     allocate(this%leafn_storage          (begp:endp))           ; this%leafn_storage       (:)   = nan
     allocate(this%leafn_xfer             (begp:endp))           ; this%leafn_xfer          (:)   = nan
+    allocate(this%leafn_storage_xfer_acc (begp:endp))           ; this%leafn_storage_xfer_acc  (:)   = nan
+    allocate(this%storage_ndemand        (begp:endp))           ; this%storage_ndemand         (:)   = nan
     allocate(this%frootn                 (begp:endp))           ; this%frootn              (:)   = nan
     allocate(this%frootn_storage         (begp:endp))           ; this%frootn_storage      (:)   = nan
     allocate(this%frootn_xfer            (begp:endp))           ; this%frootn_xfer         (:)   = nan
@@ -3748,6 +3955,16 @@
          avgflag='A', long_name='leaf N transfer', &
          ptr_patch=this%leafn_xfer, default='inactive')
 
+    this%leafn_storage_xfer_acc(begp:endp) = spval
+    call hist_addfld1d (fname='LEAFN_STORAGE_XFER_ACC', units='gN/m^2', &
+         avgflag='A', long_name='accmulated leaf N transfer', &
+         ptr_patch=this%leafn_storage_xfer_acc, default='inactive')
+
+    this%storage_ndemand(begp:endp) = spval
+    call hist_addfld1d (fname='STORAGE_NDEMAND', units='gN/m^2', &
+         avgflag='A', long_name='N use from the N storage pool', &
+         ptr_patch=this%storage_ndemand, default='inactive')
+
     this%frootn(begp:endp) = spval
     call hist_addfld1d (fname='FROOTN', units='gN/m^2', &
          avgflag='A', long_name='fine root N', &
@@ -3887,6 +4104,8 @@
           end if
 
           this%leafn_xfer(p)        = 0._r8
+          this%leafn_storage_xfer_acc(p)  = 0._r8
+          this%storage_ndemand(p)   = 0._r8
           if ( crop_prog )then
              this%grainn(p)            = 0._r8
              this%grainn_storage(p)    = 0._r8
@@ -3991,7 +4210,15 @@
 
     call restartvar(ncid=ncid, flag=flag, varname='leafn_xfer', xtype=ncd_double,  &
          dim1name='pft', long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%leafn_xfer) 
+         interpinic_flag='interp', readvar=readvar, data=this%leafn_xfer)
+
+    call restartvar(ncid=ncid, flag=flag, varname='leafn_storage_xfer_acc', xtype=ncd_double,  &
+         dim1name='pft', long_name='', units='', &
+         interpinic_flag='interp', readvar=readvar, data=this%leafn_storage_xfer_acc)
+
+    call restartvar(ncid=ncid, flag=flag, varname='storage_ndemand', xtype=ncd_double,  &
+         dim1name='pft', long_name='', units='', &
+         interpinic_flag='interp', readvar=readvar, data=this%storage_ndemand) 
 
     call restartvar(ncid=ncid, flag=flag, varname='frootn', xtype=ncd_double,  &
          dim1name='pft', long_name='', units='', &
@@ -4261,6 +4488,8 @@
        this%leafn(i)              = value_veg
        this%leafn_storage(i)      = value_veg
        this%leafn_xfer(i)         = value_veg
+       this%leafn_storage_xfer_acc(i)  = value_veg
+       !this%storage_ndemand(i)    = value_veg
        this%frootn(i)             = value_veg
        this%frootn_storage(i)     = value_veg
        this%frootn_xfer(i)        = value_veg
@@ -4353,7 +4582,9 @@
     allocate(this%grainp_xfer        (begp:endp)) ; this%grainp_xfer        (:) = nan     
     allocate(this%leafp              (begp:endp)) ; this%leafp              (:) = nan
     allocate(this%leafp_storage      (begp:endp)) ; this%leafp_storage      (:) = nan     
-    allocate(this%leafp_xfer         (begp:endp)) ; this%leafp_xfer         (:) = nan     
+    allocate(this%leafp_xfer         (begp:endp)) ;  this%leafp_xfer         (:) = nan     
+    allocate(this%leafp_storage_xfer_acc  (begp:endp)) ;  this%leafp_storage_xfer_acc  (:) = nan 
+    allocate(this%storage_pdemand     (begp:endp)) ;  this%storage_pdemand    (:) = nan 
     allocate(this%frootp             (begp:endp)) ; this%frootp             (:) = nan
     allocate(this%frootp_storage     (begp:endp)) ; this%frootp_storage     (:) = nan     
     allocate(this%frootp_xfer        (begp:endp)) ; this%frootp_xfer        (:) = nan     
@@ -4412,6 +4643,17 @@
          avgflag='A', long_name='leaf P transfer', &
          ptr_patch=this%leafp_xfer, default='inactive')
 
+    this%leafp_storage_xfer_acc(begp:endp) = spval
+    call hist_addfld1d (fname='LEAFP_STORAGE_XFER_ACC', units='gP/m^2', &
+         avgflag='A', long_name='accumulated leaf P transfer', &
+         ptr_patch=this%leafp_storage_xfer_acc, default='inactive')
+
+    this%storage_pdemand(begp:endp) = spval
+    call hist_addfld1d (fname='STORAGE_PDEMAND', units='gP/m^2', &
+         avgflag='A', long_name='P use from the P storage pool', &
+         ptr_patch=this%storage_pdemand, default='inactive')
+
+
     this%frootp(begp:endp) = spval
     call hist_addfld1d (fname='FROOTP', units='gP/m^2', &
          avgflag='A', long_name='fine root P', &
@@ -4552,6 +4794,8 @@
           end if
 
           this%leafp_xfer(p)        = 0._r8
+          this%leafp_storage_xfer_acc(p) = 0._r8
+          this%storage_pdemand(p)   = 0._r8
           if ( crop_prog )then
              this%grainp(p)            = 0._r8
              this%grainp_storage(p)    = 0._r8
@@ -4652,7 +4896,15 @@
 
     call restartvar(ncid=ncid, flag=flag, varname='leafp_xfer', xtype=ncd_double,  &
          dim1name='pft', long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%leafp_xfer) 
+         interpinic_flag='interp', readvar=readvar, data=this%leafp_xfer)
+
+    call restartvar(ncid=ncid, flag=flag, varname='leafp_storage_xfer_acc', xtype=ncd_double,  &
+         dim1name='pft', long_name='', units='', &
+         interpinic_flag='interp', readvar=readvar, data=this%leafp_storage_xfer_acc)
+
+    call restartvar(ncid=ncid, flag=flag, varname='storage_pdemand', xtype=ncd_double,  &
+         dim1name='pft', long_name='', units='', &
+         interpinic_flag='interp', readvar=readvar, data=this%storage_pdemand) 
 
     call restartvar(ncid=ncid, flag=flag, varname='frootp', xtype=ncd_double,  &
          dim1name='pft', long_name='', units='', &
@@ -4828,6 +5080,8 @@
        this%leafp(i)              = value_patch
        this%leafp_storage(i)      = value_patch
        this%leafp_xfer(i)         = value_patch
+       this%leafp_storage_xfer_acc(i) = value_patch
+       !this%storage_pdemand(i)    = value_patch
        this%frootp(i)             = value_patch
        this%frootp_storage(i)     = value_patch
        this%frootp_xfer(i)        = value_patch
@@ -5708,9 +5962,12 @@
        allocate(this%livecrootc_xfer_to_livecrootc       (begp:endp)) ;    this%livecrootc_xfer_to_livecrootc        (:) = nan
        allocate(this%deadcrootc_xfer_to_deadcrootc       (begp:endp)) ;    this%deadcrootc_xfer_to_deadcrootc        (:) = nan
        allocate(this%leafc_to_litter                     (begp:endp)) ;    this%leafc_to_litter                      (:) = nan
+       allocate(this%leafc_to_litter_fun                 (begp:endp)) ;    this%leafc_to_litter_fun                  (:) = nan
+       allocate(this%leafc_to_litter_funp                (begp:endp)) ;    this%leafc_to_litter_funp                 (:) = nan
        allocate(this%frootc_to_litter                    (begp:endp)) ;    this%frootc_to_litter                     (:) = nan
        allocate(this%livestemc_to_litter                 (begp:endp)) ;    this%livestemc_to_litter                  (:) = nan
        allocate(this%grainc_to_food                      (begp:endp)) ;    this%grainc_to_food                       (:) = nan
+       !allocate(this%cpool_to_resp                       (begp:endp)) ;    this%cpool_to_resp                        (:) = nan
        allocate(this%leaf_mr                             (begp:endp)) ;    this%leaf_mr                              (:) = nan
        allocate(this%froot_mr                            (begp:endp)) ;    this%froot_mr                             (:) = nan
        allocate(this%livestem_mr                         (begp:endp)) ;    this%livestem_mr                          (:) = nan
@@ -5810,6 +6067,42 @@
        allocate(this%woodc_loss                          (begp:endp)) ;    this%woodc_loss                           (:) = nan
        allocate(this%fire_closs                          (begp:endp)) ;    this%fire_closs                           (:) = nan
        allocate(this%crop_seedc_to_leaf                  (begp:endp)) ;    this%crop_seedc_to_leaf                   (:) = nan
+
+    !Variables used by FUN
+    allocate(this%npp_Nactive                         (begp:endp)) ; this%npp_Nactive                          (:) = nan
+    allocate(this%npp_burnedoff                       (begp:endp)) ; this%npp_burnedoff                        (:) = nan
+    allocate(this%npp_Nnonmyc                         (begp:endp)) ; this%npp_Nnonmyc                          (:) = nan
+    allocate(this%npp_Nam                             (begp:endp)) ; this%npp_Nam                              (:) = nan
+    allocate(this%npp_Necm                            (begp:endp)) ; this%npp_Necm                             (:) = nan
+    allocate(this%npp_Nactive_no3                     (begp:endp)) ; this%npp_Nactive_no3                      (:) = nan
+    allocate(this%npp_Nactive_nh4                     (begp:endp)) ; this%npp_Nactive_nh4                      (:) = nan
+    allocate(this%npp_Nnonmyc_no3                     (begp:endp)) ; this%npp_Nnonmyc_no3                      (:) = nan
+    allocate(this%npp_Nnonmyc_nh4                     (begp:endp)) ; this%npp_Nnonmyc_nh4                      (:) = nan
+    allocate(this%npp_Nam_no3                         (begp:endp)) ; this%npp_Nam_no3                          (:) = nan
+    allocate(this%npp_Nam_nh4                         (begp:endp)) ; this%npp_Nam_nh4                          (:) = nan
+    allocate(this%npp_Necm_no3                        (begp:endp)) ; this%npp_Necm_no3                         (:) = nan
+    allocate(this%npp_Necm_nh4                        (begp:endp)) ; this%npp_Necm_nh4                         (:) = nan
+    allocate(this%npp_Nfix                            (begp:endp)) ; this%npp_Nfix                             (:) = nan
+    allocate(this%npp_Nretrans                        (begp:endp)) ; this%npp_Nretrans                         (:) = nan
+    allocate(this%npp_Nuptake                         (begp:endp)) ; this%npp_Nuptake                          (:) = nan
+    allocate(this%npp_growth                          (begp:endp)) ; this%npp_growth                           (:) = nan
+    allocate(this%leafc_change                        (begp:endp)) ; this%leafc_change                         (:) = nan
+    allocate(this%soilc_change                        (begp:endp)) ; this%soilc_change                         (:) = nan
+
+    !Variables used by FUN-P
+    allocate(this%npp_Pactive                         (begp:endp)) ; this%npp_Pactive                          (:) = nan
+    allocate(this%npp_burnedoff_p                     (begp:endp)) ; this%npp_burnedoff_p                      (:) = nan
+    allocate(this%npp_Pnonmyc                         (begp:endp)) ; this%npp_Pnonmyc                          (:) = nan
+    allocate(this%npp_Pam                             (begp:endp)) ; this%npp_Pam                              (:) = nan
+    allocate(this%npp_Pecm                            (begp:endp)) ; this%npp_Pecm                             (:) = nan
+    allocate(this%npp_Pretrans                        (begp:endp)) ; this%npp_Pretrans                         (:) = nan
+    allocate(this%npp_Puptake                         (begp:endp)) ; this%npp_Puptake                          (:) = nan
+    allocate(this%npp_growth_p                        (begp:endp)) ; this%npp_growth_p                         (:) = nan
+    allocate(this%leafc_change_p                      (begp:endp)) ; this%leafc_change_p                       (:) = nan
+    allocate(this%soilc_change_p                      (begp:endp)) ; this%soilc_change_p                       (:) = nan
+
+
+
     end if ! .not use fates
 
     allocate(this%dwt_seedc_to_leaf                   (begp:endp)) ;    this%dwt_seedc_to_leaf                    (:) = nan
@@ -6239,11 +6532,30 @@
             avgflag='A', long_name='leaf C litterfall', &
             ptr_patch=this%leafc_to_litter, default='active')
 
+       !if ( use_fun ) then
+       this%leafc_to_litter_fun(begp:endp) = spval
+       call hist_addfld1d (fname='LEAFC_TO_LITTER_FUN', units='gC/m^2/s', &
+            avgflag='A', long_name='leaf C litterfall used by FUN', &
+            ptr_patch=this%leafc_to_litter_fun, default='active')
+       !if ( use_funp ) then
+       this%leafc_to_litter_funp(begp:endp) = spval
+       call hist_addfld1d (fname='LEAFC_TO_LITTER_FUNP', units='gC/m^2/s', &
+            avgflag='A', long_name='leaf C litterfall used by FUN-P', &
+            ptr_patch=this%leafc_to_litter_funp, default='active')
+       !end if
+       !end if
+
+
        this%frootc_to_litter(begp:endp) = spval
        call hist_addfld1d (fname='FROOTC_TO_LITTER', units='gC/m^2/s', &
             avgflag='A', long_name='fine root C litterfall', &
             ptr_patch=this%frootc_to_litter, default='inactive')
 
+       !this%cpool_to_resp(begp:endp) = spval
+       !call hist_addfld1d (fname='EXCESSC_MR', units='gC/m^2/s', &
+       !     avgflag='A', long_name='excess C maintenance respiration', &
+       !     ptr_patch=this%cpool_to_resp, default='inactive')
+
        this%leaf_mr(begp:endp) = spval
        call hist_addfld1d (fname='LEAF_MR', units='gC/m^2/s', &
             avgflag='A', long_name='leaf maintenance respiration', &
@@ -6651,6 +6963,165 @@
             avgflag='A', long_name='annual sum of NPP', &
             ptr_patch=this%annsum_npp, default='inactive')
 
+       !Variables used by FUN
+        !if ( use_fun ) then
+          this%npp_Nactive(begp:endp)  = spval
+          call hist_addfld1d (fname='NPP_NACTIVE', units='gC/m^2/s',     &
+               avgflag='A', long_name='Mycorrhizal N uptake used C',     &
+               ptr_patch=this%npp_Nactive, default='active')
+
+          ! BUG(wjs, 2016-04-13, bugz 2292) This field has a threading bug. Making it
+          ! inactive for now.
+          this%npp_burnedoff(begp:endp)  = spval
+          call hist_addfld1d (fname='NPP_BURNEDOFF', units='gC/m^2/s',   &
+               avgflag='A', long_name='C that cant be used for N uptake', &
+               ptr_patch=this%npp_burnedoff, default='inactive')
+  
+          this%npp_Nnonmyc(begp:endp)  = spval
+          call hist_addfld1d (fname='NPP_NNONMYC', units='gC/m^2/s',     &
+               avgflag='A', long_name='Non-mycorrhizal N uptake used C', &
+               ptr_patch=this%npp_Nnonmyc, default='active')
+
+          this%npp_Nam(begp:endp)      = spval
+          call hist_addfld1d (fname='NPP_NAM', units='gC/m^2/s',         &
+               avgflag='A', long_name='AM-associated N uptake used C',   &
+               ptr_patch=this%npp_Nam, default='active')
+
+          this%npp_Necm(begp:endp)     = spval
+          call hist_addfld1d (fname='NPP_NECM', units='gC/m^2/s',        &
+               avgflag='A', long_name='ECM-associated N uptake used C',  &
+               ptr_patch=this%npp_Necm, default='active')
+
+          !if (use_nitrif_denitrif) then
+          this%npp_Nactive_no3(begp:endp)  = spval
+          call hist_addfld1d (fname='NPP_NACTIVE_NO3', units='gC/m^2/s', &
+               avgflag='A', long_name='Mycorrhizal N uptake used C',     &
+                ptr_patch=this%npp_Nactive_no3, default='active')
+
+          this%npp_Nactive_nh4(begp:endp)  = spval
+          call hist_addfld1d (fname='NPP_NACTIVE_NH4', units='gC/m^2/s', &
+               avgflag='A', long_name='Mycorrhizal N uptake use C',      &
+               ptr_patch=this%npp_Nactive_nh4, default='active')
+
+          this%npp_Nnonmyc_no3(begp:endp)  = spval
+          call hist_addfld1d (fname='NPP_NNONMYC_NO3', units='gC/m^2/s', &
+               avgflag='A', long_name='Non-mycorrhizal N uptake use C',  &
+               ptr_patch=this%npp_Nnonmyc_no3, default='active')
+
+          this%npp_Nnonmyc_nh4(begp:endp)  = spval
+          call hist_addfld1d (fname='NPP_NNONMYC_NH4', units='gC/m^2/s', &
+               avgflag='A', long_name='Non-mycorrhizal N uptake use C',  &
+               ptr_patch=this%npp_Nnonmyc_nh4, default='active')
+
+          this%npp_Nam_no3(begp:endp)      = spval
+          call hist_addfld1d (fname='NPP_NAM_NO3', units='gC/m^2/s',     &
+               avgflag='A', long_name='AM-associated N uptake use C',    &
+               ptr_patch=this%npp_Nam_no3, default='active')
+
+          this%npp_Nam_nh4(begp:endp)      = spval
+          call hist_addfld1d (fname='NPP_NAM_NH4', units='gC/m^2/s',     &
+               avgflag='A', long_name='AM-associated N uptake use C',    &
+               ptr_patch=this%npp_Nam_nh4, default='active')
+
+          this%npp_Necm_no3(begp:endp)     = spval
+          call hist_addfld1d (fname='NPP_NECM_NO3', units='gC/m^2/s',    &
+               avgflag='A', long_name='ECM-associated N uptake used C',  &
+               ptr_patch=this%npp_Necm_no3, default='active')
+
+          this%npp_Necm_nh4(begp:endp)     = spval
+          call hist_addfld1d (fname='NPP_NECM_NH4', units='gC/m^2/s',     &
+               avgflag='A', long_name='ECM-associated N uptake use C',    &
+               ptr_patch=this%npp_Necm_nh4, default='active')
+          !end if
+
+          this%npp_Nfix(begp:endp)     = spval
+          call hist_addfld1d (fname='NPP_NFIX', units='gC/m^2/s',         &
+               avgflag='A', long_name='Symbiotic BNF uptake used C',      &
+               ptr_patch=this%npp_Nfix, default='active')
+
+          this%npp_Nretrans(begp:endp) = spval
+          call hist_addfld1d (fname='NPP_NRETRANS', units='gC/m^2/s',     &
+              avgflag='A', long_name='Retranslocated N uptake flux',      &
+              ptr_patch=this%npp_Nretrans, default='active')
+
+          this%npp_Nuptake(begp:endp) = spval
+          call hist_addfld1d (fname='NPP_NUPTAKE', units='gC/m^2/s',      &
+               avgflag='A', long_name='Total C used by N uptake in FUN',  &
+               ptr_patch=this%npp_Nuptake, default='active')
+
+          this%npp_growth(begp:endp) = spval
+          call hist_addfld1d (fname='NPP_GROWTH', units='gC/m^2/s',      &
+               avgflag='A', long_name='Total C used for growth in FUN',  &
+               ptr_patch=this%npp_growth)
+
+          this%leafc_change(begp:endp) = spval
+          call hist_addfld1d (fname='LEAFC_CHANGE', units='gC/m^2/s',     &
+               avgflag='A', long_name='C change in leaf',                 &
+               ptr_patch=this%leafc_change, default='active')
+
+          this%soilc_change(begp:endp) = spval
+          call hist_addfld1d (fname='SOILC_CHANGE', units='gC/m^2/s',     &
+               avgflag='A', long_name='C change in soil',                 &
+               ptr_patch=this%soilc_change, default='active')
+
+       !Variables used by FUN-P
+        !if ( use_funp ) then
+          this%npp_Pactive(begp:endp)  = spval
+          call hist_addfld1d (fname='NPP_PACTIVE', units='gC/m^2/s',     &
+               avgflag='A', long_name='Mycorrhizal P uptake used C',     &
+               ptr_patch=this%npp_Pactive, default='active')
+
+          this%npp_burnedoff_p(begp:endp)  = spval
+          call hist_addfld1d (fname='NPP_BURNEDOFF_P', units='gC/m^2/s',   &
+               avgflag='A', long_name='C that cant be used for P uptake', &
+               ptr_patch=this%npp_burnedoff_p, default='inactive')
+
+           this%npp_Pnonmyc(begp:endp)  = spval
+          call hist_addfld1d (fname='NPP_PNONMYC', units='gC/m^2/s',     &
+               avgflag='A', long_name='Non-mycorrhizal P uptake used C', &
+               ptr_patch=this%npp_Pnonmyc, default='active')
+
+          this%npp_Pam(begp:endp)      = spval
+          call hist_addfld1d (fname='NPP_PAM', units='gC/m^2/s',         &
+               avgflag='A', long_name='AM-associated P uptake used C',   &
+               ptr_patch=this%npp_Pam, default='active')
+
+          this%npp_Pecm(begp:endp)     = spval
+          call hist_addfld1d (fname='NPP_PECM', units='gC/m^2/s',        &
+               avgflag='A', long_name='ECM-associated P uptake used C',  &
+               ptr_patch=this%npp_Pecm, default='active')
+
+          this%npp_Pretrans(begp:endp) = spval
+          call hist_addfld1d (fname='NPP_PRETRANS', units='gC/m^2/s',     &
+              avgflag='A', long_name='Retranslocated P uptake flux',      &
+              ptr_patch=this%npp_Pretrans, default='active')
+
+          this%npp_Puptake(begp:endp) = spval
+          call hist_addfld1d (fname='NPP_PUPTAKE', units='gC/m^2/s',      &
+               avgflag='A', long_name='Total C used by P uptake in FUN-P',  &
+               ptr_patch=this%npp_Puptake, default='active')
+
+          this%npp_growth_p(begp:endp) = spval
+          call hist_addfld1d (fname='NPP_GROWTH_P', units='gC/m^2/s',      &
+               avgflag='A', long_name='Total C used for growth in FUN-P',  &
+               ptr_patch=this%npp_growth_p, default='active')
+
+          this%leafc_change_p(begp:endp) = spval
+          call hist_addfld1d (fname='LEAFC_CHANGE_P', units='gC/m^2/s',     &
+               avgflag='A', long_name='C change in leaf for P',             &
+               ptr_patch=this%leafc_change_p, default='active')
+
+          this%soilc_change_p(begp:endp) = spval
+          call hist_addfld1d (fname='SOILC_CHANGE_P', units='gC/m^2/s',     &
+               avgflag='A', long_name='C change in soil for P',             &
+               ptr_patch=this%soilc_change_p, default='active')
+
+       !end if
+! FUN-P Ends 
+
+      !end if
+! FUN Ends 
+
        ! end of C12 block
 
     else if ( carbon_type == 'c13') then
@@ -6899,6 +7370,19 @@
             avgflag='A', long_name='C13 leaf C litterfall', &
             ptr_patch=this%leafc_to_litter, default='inactive')
 
+       !if( use_fun ) then
+       this%leafc_to_litter_fun(begp:endp) = spval
+       call hist_addfld1d (fname='C13_LEAFC_TO_LITTER_FUN', units='gC13/m^2/s', &
+            avgflag='A', long_name='C13 leaf C litterfall used by FUN', &
+            ptr_patch=this%leafc_to_litter_fun, default='inactive')
+       !if( use_funp ) then
+       this%leafc_to_litter_funp(begp:endp) = spval
+       call hist_addfld1d (fname='C13_LEAFC_TO_LITTER_FUNP', units='gC13/m^2/s', &
+            avgflag='A', long_name='C13 leaf C litterfall used by FUN-P', &
+            ptr_patch=this%leafc_to_litter_funp, default='inactive')
+       !end if
+       !end if
+
        this%frootc_to_litter(begp:endp) = spval
        call hist_addfld1d (fname='C13_FROOTC_TO_LITTER', units='gC13/m^2/s', &
             avgflag='A', long_name='C13 fine root C litterfall', &
@@ -7494,6 +7978,19 @@
             avgflag='A', long_name='C14 leaf C litterfall', &
             ptr_patch=this%leafc_to_litter, default='inactive')
 
+       !if( use_fun )then 
+       this%leafc_to_litter_fun(begp:endp) = spval
+       call hist_addfld1d (fname='C14_LEAFC_TO_LITTER', units='gC14/m^2/s', &
+            avgflag='A', long_name='C14 leaf C litterfall used by FUN', &
+            ptr_patch=this%leafc_to_litter_fun, default='inactive')
+       !if( use_fun )then 
+       this%leafc_to_litter_funp(begp:endp) = spval
+       call hist_addfld1d (fname='C14_LEAFC_TO_LITTER', units='gC14/m^2/s', &
+            avgflag='A', long_name='C14 leaf C litterfall used by FUNP', &
+            ptr_patch=this%leafc_to_litter_funp, default='inactive')
+       !end if
+       !end if
+
        this%frootc_to_litter(begp:endp) = spval
        call hist_addfld1d (fname='C14_FROOTC_TO_LITTER', units='gC14/m^2/s', &
             avgflag='A', long_name='C14 fine root C litterfall', &
@@ -7858,6 +8355,8 @@
              this%plant_calloc(p)          = spval
              this%prev_leafc_to_litter(p)  = spval
              this%prev_frootc_to_litter(p) = spval
+             this%leafc_to_litter_fun(p)   = spval
+             this%leafc_to_litter_funp(p)  = spval
              if ( use_c13 ) then
                 this%xsmrpool_c13ratio(p)  = spval
              endif
@@ -7869,6 +8368,8 @@
              this%xsmrpool_recover(p)      = 0._r8
              this%excess_cflux(p)          = 0._r8
              this%prev_leafc_to_litter(p)  = 0._r8
+             this%leafc_to_litter_fun(p)   = 0._r8
+             this%leafc_to_litter_funp(p)  = 0._r8
              this%prev_frootc_to_litter(p) = 0._r8
              this%plant_calloc(p)          = 0._r8
           end if
@@ -8025,7 +8526,21 @@
     call restartvar(ncid=ncid, flag=flag, varname='annsum_npp', xtype=ncd_double,  &
          dim1name='pft', &
          long_name='', units='', &
-         interpinic_flag='interp', readvar=readvar, data=this%annsum_npp) 
+         interpinic_flag='interp', readvar=readvar, data=this%annsum_npp)
+
+
+       call restartvar(ncid=ncid, flag=flag, varname='leafc_to_litter_fun', xtype=ncd_double,  &
+            dim1name='pft', &
+            long_name='', units='', &
+            interpinic_flag='interp', readvar=readvar, data=this%leafc_to_litter_fun)
+        ! BACKWARDS_COMPATIBILITY(wrw, 2018-06-28) re. issue #426
+
+       call restartvar(ncid=ncid, flag=flag, varname='leafc_to_litter_funp', xtype=ncd_double,  &
+            dim1name='pft', &
+            long_name='', units='', &
+            interpinic_flag='interp', readvar=readvar, data=this%leafc_to_litter_funp)
+        
+     
 
   end subroutine veg_cf_restart
   
@@ -8077,6 +8592,15 @@
             this%livestem_mr(p) + &
             this%livecroot_mr(p)
 
+       !if (.not.use_fun) then
+       !   this%mr(p)  = &
+       !        this%cpool_to_resp(p)     + &
+       !        this%leaf_mr(p)     + &
+       !        this%froot_mr(p)    + &
+       !        this%livestem_mr(p) + &
+       !        this%livecroot_mr(p)
+       !end if
+
        ! growth respiration (GR)
        ! current GR is respired this time step for new growth displayed in this timestep
        this%current_gr(p) = &
@@ -8151,6 +8675,14 @@
           end if
        end if
 
+       !soilc_change and soilc_change_P when FUNP is on!
+       if (use_fun) then
+          this%ar(p) = this%ar(p) + this%soilc_change(p)
+       end if
+
+       if (use_funp) then
+          this%ar(p) = this%ar(p) + this%soilc_change_p(p)
+       end if
 
 
        ! net primary production (NPP)
@@ -8617,6 +9149,8 @@
           this%livecrootc_xfer_to_livecrootc(i)       = value_patch
           this%deadcrootc_xfer_to_deadcrootc(i)       = value_patch
           this%leafc_to_litter(i)                     = value_patch
+          !this%leafc_to_litter_fun(i)                 = value_patch
+          !this%leafc_to_litter_funp(i)                = value_patch
           this%frootc_to_litter(i)                    = value_patch
           this%leaf_mr(i)                             = value_patch
           this%froot_mr(i)                            = value_patch
@@ -8703,6 +9237,40 @@
           this%woodc_alloc(i)                         = value_patch
           this%woodc_loss(i)                          = value_patch
           this%xsmrpool_turnover(i)                   = value_patch
+
+          !Variables used by FUN
+          this%npp_Nactive(i)                         = value_patch
+          this%npp_burnedoff(i)                       = value_patch
+          this%npp_Nnonmyc(i)                         = value_patch
+          this%npp_Nam(i)                             = value_patch
+          this%npp_Necm(i)                            = value_patch
+          this%npp_Nactive_no3(i)                     = value_patch
+          this%npp_Nactive_nh4(i)                     = value_patch
+          this%npp_Nnonmyc_no3(i)                     = value_patch
+          this%npp_Nnonmyc_nh4(i)                     = value_patch
+          this%npp_Nam_no3(i)                         = value_patch
+          this%npp_Nam_nh4(i)                         = value_patch
+          this%npp_Necm_no3(i)                        = value_patch
+          this%npp_Necm_nh4(i)                        = value_patch
+          this%npp_Nfix(i)                            = value_patch
+          this%npp_Nretrans(i)                        = value_patch
+          this%npp_Nuptake(i)                         = value_patch
+          this%npp_growth(i)                          = value_patch
+          this%leafc_change(i)                        = value_patch
+          this%soilc_change(i)                        = value_patch
+          !Variables used by FUN-P
+          this%npp_Pactive(i)                         = value_patch
+          this%npp_burnedoff_p(i)                     = value_patch
+          this%npp_Pnonmyc(i)                         = value_patch
+          this%npp_Pam(i)                             = value_patch
+          this%npp_Pecm(i)                            = value_patch
+          this%npp_Pretrans(i)                        = value_patch
+          this%npp_Puptake(i)                         = value_patch
+          this%npp_growth_p(i)                        = value_patch
+          this%leafc_change_p(i)                      = value_patch
+          this%soilc_change_p(i)                      = value_patch
+
+
        end do
     end if !(.not.use_fates)
 
@@ -8744,7 +9312,7 @@
     integer, intent(in) :: begp,endp
     !
     ! !LOCAL VARIABLES:
-    integer :: p,c,l
+    integer :: p,c,l,j
     integer :: fp                                        ! filter indices
     integer :: num_special_patch                         ! number of good values in special_patch filter
     integer :: special_patch(endp-begp+1)  ! special landunit filter - patches
@@ -8848,6 +9416,7 @@
     allocate(this%deadcrootn_xfer_to_deadcrootn       (begp:endp)) ; this%deadcrootn_xfer_to_deadcrootn       (:) = nan
     allocate(this%leafn_to_litter                     (begp:endp)) ; this%leafn_to_litter                     (:) = nan
     allocate(this%leafn_to_retransn                   (begp:endp)) ; this%leafn_to_retransn                   (:) = nan
+    allocate(this%free_retransn_to_npool              (begp:endp)) ; this%free_retransn_to_npool              (:) = nan
     allocate(this%frootn_to_retransn                  (begp:endp)) ; this%frootn_to_retransn                  (:) = nan
     allocate(this%frootn_to_litter                    (begp:endp)) ; this%frootn_to_litter                    (:) = nan
     allocate(this%retransn_to_npool                   (begp:endp)) ; this%retransn_to_npool                   (:) = nan
@@ -8875,6 +9444,8 @@
     allocate(this%livecrootn_to_deadcrootn            (begp:endp)) ; this%livecrootn_to_deadcrootn            (:) = nan
     allocate(this%livecrootn_to_retransn              (begp:endp)) ; this%livecrootn_to_retransn              (:) = nan
     allocate(this%ndeploy                             (begp:endp)) ; this%ndeploy                             (:) = nan
+    allocate(this%ninputs                             (begp:endp)) ; this%ninputs                             (:) = nan
+    allocate(this%noutputs                            (begp:endp)) ; this%noutputs                            (:) = nan
     allocate(this%wood_harvestn                       (begp:endp)) ; this%wood_harvestn                       (:) = nan
     allocate(this%fire_nloss                          (begp:endp)) ; this%fire_nloss                          (:) = nan
     allocate(this%npool_to_grainn                     (begp:endp)) ; this%npool_to_grainn                     (:) = nan
@@ -8898,6 +9469,39 @@
     allocate(this%plant_ndemand                       (begp:endp)) ; this%plant_ndemand                       (:) = nan
     allocate(this%avail_retransn                      (begp:endp)) ; this%avail_retransn                      (:) = nan
     allocate(this%plant_nalloc                        (begp:endp)) ; this%plant_nalloc                        (:) = nan
+    !Variables used by FUN
+    allocate(this%plant_ndemand_retrans (begp:endp)) ;    this%plant_ndemand_retrans (:) = nan
+    allocate(this%plant_ndemand_season  (begp:endp)) ;    this%plant_ndemand_season  (:) = nan
+    allocate(this%plant_ndemand_stress  (begp:endp)) ;    this%plant_ndemand_stress  (:) = nan
+    allocate(this%Nactive               (begp:endp)) ;    this%Nactive               (:) = nan 
+    allocate(this%Nnonmyc               (begp:endp)) ;    this%Nnonmyc               (:) = nan
+    allocate(this%Nam                   (begp:endp)) ;    this%Nam                   (:) = nan
+    allocate(this%Necm                  (begp:endp)) ;    this%Necm                  (:) = nan
+    allocate(this%Nactive_no3           (begp:endp)) ;    this%Nactive_no3           (:) = nan
+    allocate(this%Nactive_nh4           (begp:endp)) ;    this%Nactive_nh4           (:) = nan
+    allocate(this%Nnonmyc_no3           (begp:endp)) ;    this%Nnonmyc_no3           (:) = nan
+    allocate(this%Nnonmyc_nh4           (begp:endp)) ;    this%Nnonmyc_nh4           (:) = nan
+    allocate(this%Nam_no3               (begp:endp)) ;    this%Nam_no3               (:) = nan
+    allocate(this%Nam_nh4               (begp:endp)) ;    this%Nam_nh4               (:) = nan
+    allocate(this%Necm_no3              (begp:endp)) ;    this%Necm_no3              (:) = nan
+    allocate(this%Necm_nh4              (begp:endp)) ;    this%Necm_nh4              (:) = nan
+    allocate(this%Npassive              (begp:endp)) ;    this%Npassive              (:) = nan
+    allocate(this%Nfix                  (begp:endp)) ;    this%Nfix                  (:) = nan
+    allocate(this%Nretrans              (begp:endp)) ;    this%Nretrans              (:) = nan
+    allocate(this%Nretrans_org          (begp:endp)) ;    this%Nretrans_org          (:) = nan
+    allocate(this%Nretrans_season       (begp:endp)) ;    this%Nretrans_season       (:) = nan
+    allocate(this%Nretrans_stress       (begp:endp)) ;    this%Nretrans_stress       (:) = nan 
+    allocate(this%Nuptake               (begp:endp)) ;    this%Nuptake               (:) = nan
+    allocate(this%sminn_to_plant_fun    (begp:endp)) ;    this%sminn_to_plant_fun    (:) = nan
+    allocate(this%sminn_to_plant_fun_vr (begp:endp,1:nlevdecomp_full)) ; this%sminn_to_plant_fun_vr (:,:) = nan
+    allocate(this%sminn_to_plant_fun_no3_vr (begp:endp,1:nlevdecomp_full)) ; this%sminn_to_plant_fun_no3_vr (:,:) = nan
+    allocate(this%sminn_to_plant_fun_nh4_vr (begp:endp,1:nlevdecomp_full)) ; this%sminn_to_plant_fun_nh4_vr (:,:) = nan
+    allocate(this%cost_nfix              (begp:endp)) ;    this%cost_nfix            (:) = nan
+    allocate(this%cost_nactive           (begp:endp)) ;    this%cost_nactive         (:) = nan
+    allocate(this%cost_nretrans          (begp:endp)) ;    this%cost_nretrans        (:) = nan
+    allocate(this%cost_nnonmyc           (begp:endp)) ;    this%cost_nnonmyc         (:) = nan
+    allocate(this%nuptake_npp_fraction   (begp:endp)) ;    this%nuptake_npp_fraction            (:) = nan
+
     allocate(this%smin_no3_to_plant                   (begp:endp)) ; this%smin_no3_to_plant                   (:) = nan
     allocate(this%smin_nh4_to_plant                   (begp:endp)) ; this%smin_nh4_to_plant                   (:) = nan
     allocate(this%sminn_to_plant                      (begp:endp)) ; this%sminn_to_plant                      (:) = nan
@@ -9177,6 +9781,11 @@
          avgflag='A', long_name='deployment of retranslocated N', &
          ptr_patch=this%retransn_to_npool)
 
+    this%free_retransn_to_npool(begp:endp) = spval
+    call hist_addfld1d (fname='FREE_RETRANSN_TO_NPOOL', units='gN/m^2/s', &
+         avgflag='A', long_name='deployment of free retranslocated N', &
+         ptr_patch=this%free_retransn_to_npool)
+
     this%sminn_to_npool(begp:endp) = spval
     call hist_addfld1d (fname='SMINN_TO_NPOOL', units='gN/m^2/s', &
          avgflag='A', long_name='deployment of soil mineral N uptake', &
@@ -9314,7 +9923,7 @@
             ptr_patch=this%fert)
     end if
 
-    if (crop_prog) then
+    if (crop_prog .and. .not. use_fun) then
        this%soyfixn(begp:endp) = spval
        call hist_addfld1d (fname='SOYFIXN', units='gN/m^2/s', &
             avgflag='A', long_name='soybean fixation', &
@@ -9375,6 +9984,135 @@
          avgflag='A', long_name='total allocated N flux', &
          ptr_patch=this%plant_nalloc, default='inactive')
 
+    !if ( use_fun ) then
+       this%Nactive(begp:endp)  = spval
+       call hist_addfld1d (fname='NACTIVE', units='gN/m^2/s',       &
+            avgflag='A', long_name='Mycorrhizal N uptake flux',     &
+            ptr_patch=this%Nactive, default='active')
+   
+       this%Nnonmyc(begp:endp)  = spval
+       call hist_addfld1d (fname='NNONMYC', units='gN/m^2/s',       &
+            avgflag='A', long_name='Non-mycorrhizal N uptake flux', &
+            ptr_patch=this%Nnonmyc, default='active')    
+
+       this%Nam(begp:endp)      = spval
+       call hist_addfld1d (fname='NAM', units='gN/m^2/s',           &
+            avgflag='A', long_name='AM-associated N uptake flux',   &
+            ptr_patch=this%Nam, default='active')
+
+       this%Necm(begp:endp)     = spval
+       call hist_addfld1d (fname='NECM', units='gN/m^2/s',          &
+            avgflag='A', long_name='ECM-associated N uptake flux',  &
+            ptr_patch=this%Necm, default='active')
+
+       !if (use_nitrif_denitrif) then
+       this%Nactive_no3(begp:endp)  = spval
+       call hist_addfld1d (fname='NACTIVE_NO3', units='gN/m^2/s',   &
+            avgflag='A', long_name='Mycorrhizal N uptake flux',     &
+            ptr_patch=this%Nactive_no3, default='active')
+   
+      this%Nactive_nh4(begp:endp)  = spval
+      call hist_addfld1d (fname='NACTIVE_NH4', units='gN/m^2/s',   &
+           avgflag='A', long_name='Mycorrhizal N uptake flux',     &
+           ptr_patch=this%Nactive_nh4, default='active')
+
+      this%Nnonmyc_no3(begp:endp)  = spval
+      call hist_addfld1d (fname='NNONMYC_NO3', units='gN/m^2/s',   &
+           avgflag='A', long_name='Non-mycorrhizal N uptake flux', &
+           ptr_patch=this%Nnonmyc_no3, default='active')
+  
+      this%Nnonmyc_nh4(begp:endp)  = spval
+      call hist_addfld1d (fname='NNONMYC_NH4', units='gN/m^2/s',   &
+           avgflag='A', long_name='Non-mycorrhizal N uptake flux', &
+           ptr_patch=this%Nnonmyc_nh4, default='active')
+
+      this%Nam_no3(begp:endp)      = spval
+      call hist_addfld1d (fname='NAM_NO3', units='gN/m^2/s',       &
+           avgflag='A', long_name='AM-associated N uptake flux',   &
+           ptr_patch=this%Nam_no3, default='active')
+ 
+      this%Nam_nh4(begp:endp)      = spval
+      call hist_addfld1d (fname='NAM_NH4', units='gN/m^2/s',       &
+           avgflag='A', long_name='AM-associated N uptake flux',   &
+           ptr_patch=this%Nam_nh4, default='active')
+
+      this%Necm_no3(begp:endp)     = spval
+      call hist_addfld1d (fname='NECM_NO3', units='gN/m^2/s',      &
+           avgflag='A', long_name='ECM-associated N uptake flux',  &
+           ptr_patch=this%Necm_no3, default='active') 
+  
+      this%Necm_nh4(begp:endp)     = spval
+      call hist_addfld1d (fname='NECM_NH4', units='gN/m^2/s',      &
+           avgflag='A', long_name='ECM-associated N uptake flux',  &
+           ptr_patch=this%Necm_nh4, default='active')   
+      !end if 
+
+       this%Npassive(begp:endp) = spval
+       call hist_addfld1d (fname='NPASSIVE', units='gN/m^2/s',        &
+            avgflag='A', long_name='Passive N uptake flux',           &
+            ptr_patch=this%Npassive, default='active')
+
+       this%Nfix(begp:endp)     = spval
+       call hist_addfld1d (fname='NFIX', units='gN/m^2/s',            &
+            avgflag='A', long_name='Symbiotic BNF uptake flux',       &
+            ptr_patch=this%Nfix, default='active')
+
+       this%Nretrans(begp:endp) = spval
+       call hist_addfld1d (fname='NRETRANS', units='gN/m^2/s',        &
+            avgflag='A', long_name='Retranslocated N uptake flux',    &
+            ptr_patch=this%Nretrans, default='active')
+  
+       this%Nretrans_org(begp:endp) = spval
+       call hist_addfld1d (fname='NRETRANS_REG', units='gN/m^2/s',    &
+            avgflag='A', long_name='Retranslocated N uptake flux',    &
+            ptr_patch=this%Nretrans_org, default='active')
+
+       this%Nretrans_season(begp:endp) = spval
+       call hist_addfld1d (fname='NRETRANS_SEASON', units='gN/m^2/s', &
+            avgflag='A', long_name='Retranslocated N uptake flux',    &
+            ptr_patch=this%Nretrans_season, default='active')
+
+       this%Nretrans_stress(begp:endp) = spval
+       call hist_addfld1d (fname='NRETRANS_STRESS', units='gN/m^2/s', &
+            avgflag='A', long_name='Retranslocated N uptake flux',    &
+            ptr_patch=this%Nretrans_stress, default='active')
+  
+       this%Nuptake(begp:endp) = spval
+       call hist_addfld1d (fname='NUPTAKE', units='gN/m^2/s',         &
+            avgflag='A', long_name='Total N uptake of FUN',           &
+            ptr_patch=this%Nuptake, default='active')
+
+       this%sminn_to_plant_fun(begp:endp) = spval
+       call hist_addfld1d (fname='SMINN_TO_PLANT_FUN', units='gN/m^2/s', &
+            avgflag='A', long_name='Total soil N uptake of FUN',        &
+            ptr_patch=this%sminn_to_plant_fun, default='active')      
+       
+       this%cost_nfix(begp:endp)     = spval
+       call hist_addfld1d (fname='COST_NFIX', units='gN/gC',            &
+            avgflag='A', long_name='Cost of fixation',       &
+            ptr_patch=this%cost_nfix, default='active')
+            
+       this%cost_nactive(begp:endp)     = spval
+       call hist_addfld1d (fname='COST_NACTIVE', units='gN/gC',            &
+            avgflag='A', long_name='Cost of active uptake',       &
+            ptr_patch=this%cost_nactive, default='active')
+            
+       this%cost_nretrans(begp:endp)     = spval
+       call hist_addfld1d (fname='COST_NRETRANS', units='gN/gC',            &
+            avgflag='A', long_name='Cost of retranslocation',       &
+            ptr_patch=this%cost_nretrans, default='active')
+
+       this%cost_nnonmyc(begp:endp)     = spval
+       call hist_addfld1d (fname='COST_NNONMYC', units='gN/gC',            &
+            avgflag='A', long_name='Cost of non-mycorrhizal',       &
+            ptr_patch=this%cost_nnonmyc, default='active')
+            
+       this%nuptake_npp_fraction(begp:endp)     = spval
+       call hist_addfld1d (fname='NUPTAKE_NPP_FRACTION', units='-',            &
+            avgflag='A', long_name='frac of NPP used in N uptake',       &
+            ptr_patch=this%nuptake_npp_fraction, default='active')
+    !end if
+ 
     this%gap_nloss_litter(begp:endp) = spval
     call hist_addfld1d (fname='GAP_NLOSS_LITTER', units='gN/m^2/s', &
          avgflag='A', long_name='total nloss from veg to litter due to gap mortality', &
@@ -9434,11 +10172,46 @@
        if (lun_pp%itype(l) == istsoil .or. lun_pp%itype(l) == istcrop) then
           this%fert_counter(p)  = 0._r8
        end if
+       if ( use_fun ) then      !previously set to spval for special land units
 
        if (lun_pp%ifspecial(l)) then
-          this%plant_ndemand(p)  = spval
-          this%avail_retransn(p) = spval
-          this%plant_nalloc(p)   = spval
+          this%plant_ndemand(p)  = 0._r8
+          this%avail_retransn(p) = 0._r8
+          this%plant_nalloc(p)   = 0._r8
+          !Variables used by FUN
+          this%Npassive(p)             = 0._r8
+          this%Nactive(p)              = 0._r8
+          this%Nnonmyc(p)              = 0._r8
+          this%Nam(p)                  = 0._r8
+          this%Necm(p)                 = 0._r8             
+          this%Nactive_no3(p)          = 0._r8
+          this%Nactive_nh4(p)          = 0._r8
+          this%Nnonmyc_no3(p)          = 0._r8
+          this%Nnonmyc_nh4(p)          = 0._r8
+          this%Nam_no3(p)              = 0._r8
+          this%Nam_nh4(p)              = 0._r8
+          this%Necm_no3(p)             = 0._r8
+          this%Necm_nh4(p)             = 0._r8
+          this%Nfix(p)                 = 0._r8
+          this%Nretrans(p)             = 0._r8
+          this%Nretrans_org(p)         = 0._r8
+          this%Nretrans_season(p)      = 0._r8
+          this%Nretrans_stress(p)      = 0._r8
+          this%Nuptake(p)              = 0._r8
+          this%sminn_to_plant_fun(p)   = 0._r8
+          this%cost_nfix(p)            = 0._r8
+          this%cost_nactive(p)         = 0._r8
+          this%cost_nretrans(p)        = 0._r8  
+          this%cost_nnonmyc(p)         = 0._r8       
+          this%nuptake_npp_fraction(p) = 0._r8
+   
+             do j = 1, nlevdecomp
+                this%sminn_to_plant_fun_vr(p,j)       = 0._r8
+                this%sminn_to_plant_fun_no3_vr(p,j)   = 0._r8
+                this%sminn_to_plant_fun_nh4_vr(p,j)   = 0._r8
+             end do 
+          end if
+
        end if
     end do
 
@@ -9518,6 +10291,135 @@
          long_name='', units='', &
          interpinic_flag='interp', readvar=readvar, data=this%plant_nalloc) 
 
+      !if ( use_fun ) then
+!       set_missing_vals_to_constant for BACKWARDS_COMPATIBILITY(wrw, 2018-06-28) re. issue #426
+!       special land units previously set to spval, not 0
+!       modifications here should correct this 
+        call restartvar(ncid=ncid, flag=flag, varname='Nactive', xtype=ncd_double,       &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Nactive) 
+        
+!    
+        call restartvar(ncid=ncid, flag=flag, varname='Nnonmyc', xtype=ncd_double,       &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Nnonmyc)
+        
+ 
+        call restartvar(ncid=ncid, flag=flag, varname='Nam', xtype=ncd_double,           &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Nam)
+        
+ 
+        call restartvar(ncid=ncid, flag=flag, varname='Necm', xtype=ncd_double,          &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Necm)
+        
+ 
+        !if (use_nitrif_denitrif) then
+           call restartvar(ncid=ncid, flag=flag, varname='Nactive_no3', xtype=ncd_double,   &
+                dim1name='pft', &
+                long_name='', units='', &
+                interpinic_flag='interp', readvar=readvar, data=this%Nactive_no3)
+           
+    
+           call restartvar(ncid=ncid, flag=flag, varname='Nactive_nh4', xtype=ncd_double,   &
+                dim1name='pft', &
+                long_name='', units='', &
+                interpinic_flag='interp', readvar=readvar, data=this%Nactive_nh4)   
+           
+ 
+           call restartvar(ncid=ncid, flag=flag, varname='Nnonmyc_no3', xtype=ncd_double,    &
+                dim1name='pft', &
+                long_name='', units='', &
+                interpinic_flag='interp', readvar=readvar, data=this%Nnonmyc_no3)
+           
+ 
+           call restartvar(ncid=ncid, flag=flag, varname='Nnonmyc_nh4', xtype=ncd_double,    &
+                dim1name='pft', &
+                long_name='', units='', &
+                interpinic_flag='interp', readvar=readvar, data=this%Nnonmyc_nh4)
+           
+ 
+           call restartvar(ncid=ncid, flag=flag, varname='Nam_no3', xtype=ncd_double,         &
+                dim1name='pft', &
+                long_name='', units='', &
+                interpinic_flag='interp', readvar=readvar, data=this%Nam_no3)
+           
+ 
+           call restartvar(ncid=ncid, flag=flag, varname='Nam_nh4', xtype=ncd_double,         &
+                dim1name='pft', &
+                long_name='', units='', &
+                interpinic_flag='interp', readvar=readvar, data=this%Nam_nh4)
+           
+ 
+           call restartvar(ncid=ncid, flag=flag, varname='Necm_no3', xtype=ncd_double,        &
+                dim1name='pft', &
+                long_name='', units='', &
+                interpinic_flag='interp', readvar=readvar, data=this%Necm_no3)
+           
+ 
+           call restartvar(ncid=ncid, flag=flag, varname='Necm_nh4', xtype=ncd_double,        &
+                dim1name='pft', &
+                long_name='', units='', &
+                interpinic_flag='interp', readvar=readvar, data=this%Necm_nh4)
+           
+        !end if
+!
+        call restartvar(ncid=ncid, flag=flag, varname='Npassive', xtype=ncd_double,      &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Npassive)
+        
+ 
+        call restartvar(ncid=ncid, flag=flag, varname='Nfix', xtype=ncd_double,          &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Nfix)
+        
+ 
+        call restartvar(ncid=ncid, flag=flag, varname='Nretrans', xtype=ncd_double,       &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Nretrans)
+        
+ 
+        call restartvar(ncid=ncid, flag=flag, varname='Nretrans_org', xtype=ncd_double,   &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Nretrans_org)
+        
+ 
+        call restartvar(ncid=ncid, flag=flag, varname='Nretrans_season', xtype=ncd_double, &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Nretrans_season)
+        
+ 
+        call restartvar(ncid=ncid, flag=flag, varname='Nretrans_stress', xtype=ncd_double, &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Nretrans_stress)
+        
+ 
+        call restartvar(ncid=ncid, flag=flag, varname='Nuptake', xtype=ncd_double,            &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Nuptake)
+        
+
+        call restartvar(ncid=ncid, flag=flag, varname='sminn_to_plant_fun', xtype=ncd_double,            &
+             dim1name='pft', &
+             long_name='Total soil N uptake of FUN', units='gN/m2/s', &
+             interpinic_flag='interp', readvar=readvar, data=this%sminn_to_plant_fun)
+        
+     !end if
+! End BACKWARDS_COMPATIBILITY(wrw, 2018-06-28) re. issue #426
+
+
   end subroutine veg_nf_restart  
   
   !-----------------------------------------------------------------------
@@ -9639,6 +10541,7 @@
        this%leafn_to_retransn(i)                   = value_patch
        this%frootn_to_litter(i)                    = value_patch
        this%retransn_to_npool(i)                   = value_patch
+       this%free_retransn_to_npool(i)              = value_patch
        this%sminn_to_npool(i)                      = value_patch
        this%npool_to_leafn(i)                      = value_patch
        this%npool_to_leafn_storage(i)              = value_patch
@@ -9663,6 +10566,8 @@
        this%livecrootn_to_deadcrootn(i)            = value_patch
        this%livecrootn_to_retransn(i)              = value_patch
        this%ndeploy(i)                             = value_patch
+       this%ninputs(i)                             = value_patch
+       this%noutputs(i)                            = value_patch
        this%wood_harvestn(i)                       = value_patch
        this%fire_nloss(i)                          = value_patch
        this%nfix_to_plantn(i)                      = value_patch
@@ -9672,6 +10577,32 @@
        this%sen_nloss_litter(i)                    = value_patch
        this%crop_seedn_to_leaf(i)                  = value_patch
        this%livestemn_to_litter(i)                 = value_patch
+       !Variables used by FUN
+       !this%Npassive(i)                            = value_patch
+       !this%Nactive(i)                             = value_patch
+       !this%Nnonmyc(i)                             = value_patch
+       !this%Nam(i)                                 = value_patch
+       !this%Necm(i)                                = value_patch         
+       !this%Nactive_no3(i)                         = value_patch
+       !this%Nactive_nh4(i)                         = value_patch
+       !this%Nnonmyc_no3(i)                         = value_patch
+       !this%Nnonmyc_nh4(i)                         = value_patch
+       !this%Nam_no3(i)                             = value_patch
+       !this%Nam_nh4(i)                             = value_patch
+       !this%Necm_no3(i)                            = value_patch
+       !this%Necm_nh4(i)                            = value_patch
+       !this%Nfix(i)                                = value_patch
+       !this%Nretrans(i)                            = value_patch
+       !this%Nretrans_org(i)                        = value_patch
+       !this%Nretrans_season(i)                     = value_patch
+       !this%Nretrans_stress(i)                     = value_patch
+       !this%Nuptake(i)                             = value_patch
+       !this%sminn_to_plant_fun(i)                  = value_patch
+       !this%cost_nfix(i)                           = value_patch
+       !this%cost_nactive(i)                        = value_patch
+       !this%cost_nretrans(i)                       = value_patch          
+       !this%nuptake_npp_fraction(i)                = value_patch
+
     end do
 
     if ( crop_prog )then
@@ -9715,7 +10646,8 @@
        ! total N deployment (from sminn and retranslocated N pool) (NDEPLOY)
        this%ndeploy(p) = &
             this%sminn_to_npool(p) + &
-            this%retransn_to_npool(p)
+            this%retransn_to_npool(p)+ &
+            this%free_retransn_to_npool(p)
 
        ! pft-level wood harvest
        this%wood_harvestn(p) = &
@@ -9856,7 +10788,7 @@
     integer, intent(in) :: begp,endp
     !
     ! !LOCAL VARIABLES:
-    integer :: p,l                         ! indices
+    integer :: p,l,j                       ! indices
     integer :: fp                          ! filter indices
     integer :: num_special_patch           ! number of good values in special_patch filter
     integer :: special_patch(endp-begp+1)  ! special landunit filter - patches
@@ -9963,6 +10895,7 @@
     allocate(this%frootp_to_retransp                  (begp:endp)) ; this%frootp_to_retransp                  (:) = nan
     allocate(this%frootp_to_litter                    (begp:endp)) ; this%frootp_to_litter                    (:) = nan
     allocate(this%retransp_to_ppool                   (begp:endp)) ; this%retransp_to_ppool                   (:) = nan
+    allocate(this%free_retransp_to_ppool              (begp:endp)) ; this%free_retransp_to_ppool              (:) = nan
     allocate(this%sminp_to_ppool                      (begp:endp)) ; this%sminp_to_ppool                      (:) = nan
     allocate(this%biochem_pmin_to_plant               (begp:endp)) ; this%biochem_pmin_to_plant               (:) = nan
     allocate(this%ppool_to_leafp                      (begp:endp)) ; this%ppool_to_leafp                      (:) = nan
@@ -9988,6 +10921,8 @@
     allocate(this%livecrootp_to_deadcrootp            (begp:endp)) ; this%livecrootp_to_deadcrootp            (:) = nan
     allocate(this%livecrootp_to_retransp              (begp:endp)) ; this%livecrootp_to_retransp              (:) = nan
     allocate(this%pdeploy                             (begp:endp)) ; this%pdeploy                             (:) = nan
+    allocate(this%pinputs                             (begp:endp)) ; this%pinputs                             (:) = nan
+    allocate(this%poutputs                            (begp:endp)) ; this%poutputs                            (:) = nan
     allocate(this%wood_harvestp                       (begp:endp)) ; this%wood_harvestp                       (:) = nan
     allocate(this%fire_ploss                          (begp:endp)) ; this%fire_ploss                          (:) = nan
     allocate(this%ppool_to_grainp                     (begp:endp)) ; this%ppool_to_grainp                     (:) = nan
@@ -10009,6 +10944,29 @@
     allocate(this%plant_pdemand                       (begp:endp)) ; this%plant_pdemand                       (:) = nan
     allocate(this%avail_retransp                      (begp:endp)) ; this%avail_retransp                      (:) = nan
     allocate(this%plant_palloc                        (begp:endp)) ; this%plant_palloc                        (:) = nan
+    !Variables used by FUN-P
+    allocate(this%plant_pdemand_retrans (begp:endp)) ;    this%plant_pdemand_retrans (:) = nan
+    allocate(this%plant_pdemand_season  (begp:endp)) ;    this%plant_pdemand_season  (:) = nan
+    allocate(this%plant_pdemand_stress  (begp:endp)) ;    this%plant_pdemand_stress  (:) = nan
+    allocate(this%Pactive               (begp:endp)) ;    this%Pactive               (:) = nan 
+    allocate(this%Pnonmyc               (begp:endp)) ;    this%Pnonmyc               (:) = nan
+    allocate(this%Pam                   (begp:endp)) ;    this%Pam                   (:) = nan
+    allocate(this%Pecm                  (begp:endp)) ;    this%Pecm                  (:) = nan
+    allocate(this%Ppassive              (begp:endp)) ;    this%Ppassive              (:) = nan
+    allocate(this%Pretrans              (begp:endp)) ;    this%Pretrans              (:) = nan
+    allocate(this%Pretrans_org          (begp:endp)) ;    this%Pretrans_org          (:) = nan
+    allocate(this%Pretrans_season       (begp:endp)) ;    this%Pretrans_season       (:) = nan
+    allocate(this%Pretrans_stress       (begp:endp)) ;    this%Pretrans_stress       (:) = nan 
+    allocate(this%Puptake               (begp:endp)) ;    this%Puptake               (:) = nan
+    allocate(this%sminp_to_plant_fun    (begp:endp)) ;    this%sminp_to_plant_fun    (:) = nan
+    allocate(this%sminp_to_plant_fun_vr (begp:endp,1:nlevdecomp_full)) 
+    this%sminp_to_plant_fun_vr          (:,:) = nan
+    allocate(this%cost_pactive           (begp:endp)) ;    this%cost_pactive         (:) = nan
+    allocate(this%cost_pretrans          (begp:endp)) ;    this%cost_pretrans        (:) = nan
+    allocate(this%cost_pnonmyc           (begp:endp)) ;    this%cost_pnonmyc         (:) = nan
+    allocate(this%puptake_npp_fraction   (begp:endp)) ;    this%puptake_npp_fraction            (:) = nan
+
+
     allocate(this%sminp_to_plant                      (begp:endp)) ; this%sminp_to_plant                      (:) = nan
     allocate(this%plant_pdemand_vr                    (begp:endp,1:nlevdecomp_full )) ; this%plant_pdemand_vr (:,:) = nan
     allocate(this%prev_leafp_to_litter                (begp:endp)) ; this%prev_leafp_to_litter                (:) = nan
@@ -10282,6 +11240,11 @@
          avgflag='A', long_name='deployment of retranslocated P', &
          ptr_patch=this%retransp_to_ppool)
 
+    this%free_retransp_to_ppool(begp:endp) = spval
+    call hist_addfld1d (fname='FREE_RETRANSP_TO_PPOOL', units='gP/m^2/s', &
+         avgflag='A', long_name='free deployment of retranslocated P', &
+         ptr_patch=this%free_retransp_to_ppool)
+
     this%sminp_to_ppool(begp:endp) = spval
     call hist_addfld1d (fname='SMINP_TO_PPOOL', units='gP/m^2/s', &
          avgflag='A', long_name='deployment of soil mineral P uptake', &
@@ -10503,6 +11466,84 @@
          avgflag='A', long_name='total allocated P flux', &
          ptr_patch=this%plant_palloc, default='active')
 
+    !if ( use_funp ) then
+       this%Pactive(begp:endp)  = spval
+       call hist_addfld1d (fname='PACTIVE', units='gP/m^2/s',       &
+            avgflag='A', long_name='Mycorrhizal P uptake flux',     &
+            ptr_patch=this%Pactive, default='active')
+   
+       this%Pnonmyc(begp:endp)  = spval
+       call hist_addfld1d (fname='PNONMYC', units='gP/m^2/s',       &
+            avgflag='A', long_name='Non-mycorrhizal P uptake flux', &
+            ptr_patch=this%Pnonmyc, default='active')    
+
+       this%Pam(begp:endp)      = spval
+       call hist_addfld1d (fname='PAM', units='gP/m^2/s',           &
+            avgflag='A', long_name='AM-associated P uptake flux',   &
+            ptr_patch=this%Pam, default='active')
+
+       this%Pecm(begp:endp)     = spval
+       call hist_addfld1d (fname='PECM', units='gP/m^2/s',          &
+            avgflag='A', long_name='ECM-associated P uptake flux',  &
+            ptr_patch=this%Pecm, default='active')
+
+       this%Ppassive(begp:endp) = spval
+       call hist_addfld1d (fname='PPASSIVE', units='gP/m^2/s',        &
+            avgflag='A', long_name='Passive P uptake flux',           &
+            ptr_patch=this%Ppassive, default='active')
+
+       this%Pretrans(begp:endp) = spval
+       call hist_addfld1d (fname='PRETRANS', units='gP/m^2/s',        &
+            avgflag='A', long_name='Retranslocated P uptake flux',    &
+            ptr_patch=this%Pretrans, default='active')
+  
+       this%Pretrans_org(begp:endp) = spval
+       call hist_addfld1d (fname='PRETRANS_REG', units='gP/m^2/s',    &
+            avgflag='A', long_name='Retranslocated P uptake flux',    &
+            ptr_patch=this%Pretrans_org, default='active')
+
+       this%Pretrans_season(begp:endp) = spval
+       call hist_addfld1d (fname='PRETRANS_SEASON', units='gP/m^2/s', &
+            avgflag='A', long_name='Retranslocated P uptake flux',    &
+            ptr_patch=this%Pretrans_season, default='active')
+
+       this%Pretrans_stress(begp:endp) = spval
+       call hist_addfld1d (fname='PRETRANS_STRESS', units='gP/m^2/s', &
+            avgflag='A', long_name='Retranslocated P uptake flux',    &
+            ptr_patch=this%Pretrans_stress, default='active')
+  
+       this%Puptake(begp:endp) = spval
+       call hist_addfld1d (fname='PUPTAKE', units='gP/m^2/s',         &
+            avgflag='A', long_name='Total P uptake of FUN-P',           &
+            ptr_patch=this%Puptake, default='active')
+
+       this%sminp_to_plant_fun(begp:endp) = spval
+       call hist_addfld1d (fname='SMINP_TO_PLANT_FUN', units='gP/m^2/s',&
+            avgflag='A', long_name='Total soil P uptake of FUN-P',        &
+            ptr_patch=this%sminp_to_plant_fun, default='active')      
+    
+      
+       this%cost_pactive(begp:endp)     = spval
+       call hist_addfld1d (fname='COST_PACTIVE', units='gP/gC',            &
+            avgflag='A', long_name='Cost of active uptake',       &
+            ptr_patch=this%cost_pactive, default='active')
+            
+       this%cost_pretrans(begp:endp)     = spval
+       call hist_addfld1d (fname='COST_PRETRANS', units='gP/gC',            &
+            avgflag='A', long_name='Cost of retranslocation',       &
+            ptr_patch=this%cost_pretrans, default='active')
+
+       this%cost_pnonmyc(begp:endp)     = spval
+       call hist_addfld1d (fname='COST_PNONMYC', units='gP/gC',            &
+            avgflag='A', long_name='Cost of non-mycorrhizal',       &
+            ptr_patch=this%cost_pnonmyc, default='active')
+            
+      this%puptake_npp_fraction(begp:endp)     = spval
+       call hist_addfld1d (fname='PUPTAKE_NPP_FRACTION', units='-',            &
+            avgflag='A', long_name='frac of NPP used in P uptake',       &
+            ptr_patch=this%puptake_npp_fraction, default='active')
+    !end if
+
     !-----------------------------------------------------------------------
     ! set cold-start initial values for select members of veg_pf
     !------------------------------------------------------------------------
@@ -10529,11 +11570,32 @@
           this%fert_p_counter(p)  = 0._r8
        end if
 
+       if (use_funp) then
        if (lun_pp%ifspecial(l)) then
-          this%plant_pdemand(p)  = spval
-          this%avail_retransp(p) = spval
-          this%plant_palloc(p)   = spval
+          this%plant_pdemand(p)  = 0._r8
+          this%avail_retransp(p) = 0._r8
+          this%plant_palloc(p)   = 0._r8
+       this%Ppassive(p)                            = 0._r8
+       this%Pactive(p)                             = 0._r8
+       this%Pnonmyc(p)                             = 0._r8
+       this%Pam(p)                                 = 0._r8
+       this%Pecm(p)                                = 0._r8        
+       this%Pretrans(p)                            = 0._r8
+       this%Pretrans_org(p)                        = 0._r8
+       this%Pretrans_season(p)                     = 0._r8
+       this%Pretrans_stress(p)                     = 0._r8
+       this%Puptake(p)                             = 0._r8
+       this%sminp_to_plant_fun(p)                  = 0._r8
+       this%cost_pactive(p)                        = 0._r8
+       this%cost_pretrans(p)                       = 0._r8  
+       this%cost_pnonmyc(p)                        = 0._r8        
+       this%puptake_npp_fraction(p)                = 0._r8
+
+            do j = 1, nlevdecomp
+                this%sminp_to_plant_fun_vr(p,j)       = 0._r8
+             end do
        end if
+     end if
     end do
     
     call this%SetValues (num_patch=num_special_patch, filter_patch=special_patch, value_patch=0._r8)
@@ -10625,6 +11687,81 @@
          dim1name='pft', &
          long_name='', units='', &
          interpinic_flag='interp', readvar=readvar, data=this%plant_palloc) 
+
+      if ( use_funp ) then
+!       set_missing_vals_to_constant for BACKWARDS_COMPATIBILITY(wrw, 2018-06-28) re. issue #426
+!       special land units previously set to spval, not 0
+!       modifications here should correct this 
+        call restartvar(ncid=ncid, flag=flag, varname='Pactive', xtype=ncd_double,       &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Pactive) 
+        
+!    
+        call restartvar(ncid=ncid, flag=flag, varname='Pnonmyc', xtype=ncd_double,       &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Pnonmyc)
+        
+ 
+        call restartvar(ncid=ncid, flag=flag, varname='Pam', xtype=ncd_double,           &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Pam)
+        
+ 
+        call restartvar(ncid=ncid, flag=flag, varname='Pecm', xtype=ncd_double,          &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Pecm)
+        
+ 
+        call restartvar(ncid=ncid, flag=flag, varname='Ppassive', xtype=ncd_double,      &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Ppassive)
+        
+ 
+        call restartvar(ncid=ncid, flag=flag, varname='Pretrans', xtype=ncd_double,       &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Pretrans)
+        
+ 
+        call restartvar(ncid=ncid, flag=flag, varname='Pretrans_org', xtype=ncd_double,   &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Pretrans_org)
+        
+ 
+        call restartvar(ncid=ncid, flag=flag, varname='Pretrans_season', xtype=ncd_double, &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Pretrans_season)
+        
+ 
+        call restartvar(ncid=ncid, flag=flag, varname='Pretrans_stress', xtype=ncd_double, &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Pretrans_stress)
+        
+ 
+        call restartvar(ncid=ncid, flag=flag, varname='Puptake', xtype=ncd_double,            &
+             dim1name='pft', &
+             long_name='', units='', &
+             interpinic_flag='interp', readvar=readvar, data=this%Puptake)
+        
+
+        call restartvar(ncid=ncid, flag=flag, varname='sminp_to_plant_fun', xtype=ncd_double,            &
+             dim1name='pft', &
+             long_name='Total soil P uptake of FUN-P', units='gN/m2/s', &
+             interpinic_flag='interp', readvar=readvar, data=this%sminp_to_plant_fun)
+        
+     end if
+! End BACKWARDS_COMPATIBILITY(wrw, 2018-06-28) re. issue #426
+
+
+
   
   end subroutine veg_pf_restart
   
@@ -10746,6 +11883,7 @@
        this%leafp_to_retransp(i)                   = value_patch
        this%frootp_to_litter(i)                    = value_patch
        this%retransp_to_ppool(i)                   = value_patch
+       this%free_retransp_to_ppool(i)              = value_patch
        this%sminp_to_ppool(i)                      = value_patch
        this%ppool_to_leafp(i)                      = value_patch
        this%ppool_to_leafp_storage(i)              = value_patch
@@ -10770,6 +11908,8 @@
        this%livecrootp_to_deadcrootp(i)            = value_patch
        this%livecrootp_to_retransp(i)              = value_patch
        this%pdeploy(i)                             = value_patch
+       this%pinputs(i)                             = value_patch
+       this%poutputs(i)                            = value_patch
        this%wood_harvestp(i)                       = value_patch
        this%fire_ploss(i)                          = value_patch
        this%biochem_pmin_to_plant(i)               = value_patch
@@ -10778,6 +11918,23 @@
        this%hrv_ploss_litter(i)                    = value_patch
        this%sen_ploss_litter(i)                    = value_patch
        this%livestemp_to_litter(i)                 = value_patch
+
+       !Variables used by FUN-P
+       !this%Ppassive(i)                            = value_patch
+       !this%Pactive(i)                             = value_patch
+       !this%Pnonmyc(i)                             = value_patch
+       !this%Pam(i)                                 = value_patch
+       !this%Pecm(i)                                = value_patch        
+       !this%Pretrans(i)                            = value_patch
+       !!this%Pretrans_org(i)                        = value_patch
+       !this%Pretrans_season(i)                     = value_patch
+       !this%Pretrans_stress(i)                     = value_patch
+       !this%Puptake(i)                             = value_patch
+       !this%sminp_to_plant_fun(i)                  = value_patch
+       !this%cost_pactive(i)                        = value_patch
+       !this%cost_pretrans(i)                       = value_patch          
+       !this%puptake_npp_fraction(i)                = value_patch
+
     end do
 
     if ( crop_prog )then
@@ -10816,7 +11973,8 @@
        ! total P deployment (from sminn and retranslocated P pool) (PDEPLOY)
        this%pdeploy(p) = &
             this%sminp_to_ppool(p) + &
-            this%retransp_to_ppool(p)
+            this%retransp_to_ppool(p) + &
+            this%free_retransp_to_ppool(p)
 
        ! pft-level wood harvest
        this%wood_harvestp(p) = &
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/data_types/VegetationPropertiesType.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/data_types/VegetationPropertiesType.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/data_types/VegetationPropertiesType.F90	2020-06-10 13:56:35.374390452 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/data_types/VegetationPropertiesType.F90	2020-07-17 14:22:30.296171504 -0400
@@ -144,6 +144,34 @@
      real(r8), allocatable :: br_xr(:)            !Base rate for excess respiration
      real(r8)              :: tc_stress           !Critial temperature for moisture stress
 
+     ! pft parameters for FUN
+     real(r8), allocatable :: a_fix         (:)   ! A BNF parameter
+     real(r8), allocatable :: b_fix         (:)   ! A BNF parameter
+     real(r8), allocatable :: c_fix         (:)   ! A BNF parameter
+     real(r8), allocatable :: s_fix         (:)   ! A BNF parameter
+     real(r8), allocatable :: akc_active    (:)   ! A mycorrhizal uptake parameter
+     real(r8), allocatable :: akn_active    (:)   ! A mycorrhizal uptake parameter
+     real(r8), allocatable :: akcp_active   (:)   ! A mycorrhizal uptake parameter
+     real(r8), allocatable :: akp_active    (:)   ! A mycorrhizal uptake parameter
+     real(r8), allocatable :: ekc_active    (:)   ! A mycorrhizal uptake parameter
+     real(r8), allocatable :: ekn_active    (:)   ! A mycorrhizal uptake parameter
+     real(r8), allocatable :: ekcp_active   (:)   ! A mycorrhizal uptake parameter
+     real(r8), allocatable :: ekp_active    (:)   ! A mycorrhizal uptake parameter
+     real(r8), allocatable :: kc_nonmyc     (:)   ! A non-mycorrhizal uptake parameter
+     real(r8), allocatable :: kn_nonmyc     (:)   ! A non-mycorrhizal uptake parameter
+     real(r8), allocatable :: kcp_nonmyc    (:)   ! A non-mycorrhizal uptake parameter
+     real(r8), allocatable :: kp_nonmyc     (:)   ! A non-mycorrhizal uptake parameter
+     real(r8), allocatable :: kr_resorb     (:)   ! A N retrasnlcation parameter
+     real(r8), allocatable :: krp_resorb    (:)   ! A P retranslocation parameter
+     real(r8), allocatable :: perecm        (:)   ! The fraction of ECM-associated PFT 
+     real(r8), allocatable :: fun_cn_flex_a (:)   ! Parameter a of FUN-flexcn link code (def 5)
+     real(r8), allocatable :: fun_cn_flex_b (:)   ! Parameter b of FUN-flexcn link code (def 200)
+     real(r8), allocatable :: fun_cn_flex_c (:)   ! Parameter c of FUN-flexcn link code (def 80)
+     real(r8), allocatable :: fun_cp_flex_a (:)   ! Parameter a of FUNP-flexcp link code (def 5)
+     real(r8), allocatable :: fun_cp_flex_b (:)   ! Parameter b of FUNP-flexcp link code (def 200)
+     real(r8), allocatable :: fun_cp_flex_c (:)   ! Parameter c of FUNP-flexcp link code (def 80)    
+     real(r8), allocatable :: FUN_fracfixers(:)   ! Fraction of C that can be used for fixation.    
+
 
    contains
    procedure, public :: Init => veg_vp_init
@@ -181,6 +209,15 @@
     use pftvarcon , only : fnr, act25, kcha, koha, cpha, vcmaxha, jmaxha, tpuha
     use pftvarcon , only : lmrha, vcmaxhd, jmaxhd, tpuhd, lmrse, qe, theta_cj
     use pftvarcon , only : bbbopt, mbbopt, nstor, br_xr, tc_stress, lmrhd 
+    !pft variables for FUN
+    use pftvarcon , only : a_fix, b_fix, c_fix, s_fix
+    use pftvarcon , only : akc_active, akn_active, ekc_active, ekn_active
+    use pftvarcon , only : akcp_active, akp_active, ekcp_active, ekp_active
+    use pftvarcon , only : kc_nonmyc, kn_nonmyc, kr_resorb, perecm
+    use pftvarcon , only : kcp_nonmyc, kp_nonmyc, krp_resorb
+    use pftvarcon , only : fun_cn_flex_a, fun_cn_flex_b, fun_cn_flex_c
+    use pftvarcon , only : fun_cp_flex_a, fun_cp_flex_b, fun_cp_flex_c
+    use pftvarcon , only : FUN_fracfixers
     !
     
     class (vegetation_properties_type) :: this
@@ -197,6 +234,7 @@
     allocate(this%foln          (0:numpft))        ; this%foln         (:)   =nan
     allocate(this%dleaf         (0:numpft))        ; this%dleaf        (:)   =nan
     allocate(this%c3psn         (0:numpft))        ; this%c3psn        (:)   =nan
+    allocate(this%perecm        (0:numpft))        ; this%perecm       (:)  =nan           
     allocate(this%xl            (0:numpft))        ; this%xl           (:)   =nan
     allocate(this%rhol          (0:numpft,numrad)) ; this%rhol         (:,:) =nan
     allocate(this%rhos          (0:numpft,numrad)) ; this%rhos         (:,:) =nan
@@ -290,6 +328,34 @@
     allocate( this%mbbopt(0:numpft))                             ; this%mbbopt(:)                =nan
     allocate( this%nstor(0:numpft))                              ; this%nstor(:)                 =nan
     allocate( this%br_xr(0:numpft))                              ; this%br_xr(:)                 =nan
+    !pft variables for FUN
+    allocate( this%a_fix(0:numpft))                              ; this%a_fix(:)                 =nan
+    allocate( this%b_fix(0:numpft))                              ; this%b_fix(:)                 =nan
+    allocate( this%c_fix(0:numpft))                              ; this%c_fix(:)                 =nan
+    allocate( this%s_fix(0:numpft))                              ; this%s_fix(:)                 =nan 
+    allocate( this%akc_active(0:numpft))                         ; this%akc_active(:)                 =nan
+    allocate( this%akn_active(0:numpft))                         ; this%akn_active(:)                 =nan
+    allocate( this%akcp_active(0:numpft))                        ; this%akcp_active(:)                 =nan
+    allocate( this%akp_active(0:numpft))                         ; this%akp_active(:)                 =nan
+    allocate( this%ekc_active(0:numpft))                         ; this%ekc_active(:)                 =nan
+    allocate( this%ekn_active(0:numpft))                         ; this%ekn_active(:)                 =nan
+    allocate( this%ekcp_active(0:numpft))                        ; this%ekcp_active(:)                 =nan
+    allocate( this%ekp_active(0:numpft))                         ; this%ekp_active(:)                 =nan
+    allocate( this%kc_nonmyc(0:numpft))                          ; this%kc_nonmyc(:)                 =nan
+    allocate( this%kn_nonmyc(0:numpft))                          ; this%kn_nonmyc(:)                 =nan
+    allocate( this%kcp_nonmyc(0:numpft))                         ; this%kcp_nonmyc(:)                 =nan
+    allocate( this%kp_nonmyc(0:numpft))                          ; this%kp_nonmyc(:)                 =nan
+    allocate( this%kr_resorb(0:numpft))                          ; this%kr_resorb(:)                 =nan
+    allocate( this%krp_resorb(0:numpft))                         ; this%krp_resorb(:)                 =nan
+
+    allocate( this%fun_cn_flex_a(0:numpft))                      ; this%fun_cn_flex_a(:)                 =nan
+    allocate( this%fun_cn_flex_b(0:numpft))                      ; this%fun_cn_flex_b(:)                 =nan
+    allocate( this%fun_cn_flex_c(0:numpft))                      ; this%fun_cn_flex_c(:)                 =nan
+    allocate( this%fun_cp_flex_a(0:numpft))                      ; this%fun_cp_flex_a(:)                 =nan
+    allocate( this%fun_cp_flex_b(0:numpft))                      ; this%fun_cp_flex_b(:)                 =nan
+    allocate( this%fun_cp_flex_c(0:numpft))                      ; this%fun_cp_flex_c(:)                 =nan
+    allocate( this%FUN_fracfixers(0:numpft))                     ; this%FUN_fracfixers(:)                 =nan
+
 
     do m = 0,numpft
 
@@ -377,6 +443,35 @@
        this%mbbopt(m)       = mbbopt(m)
        this%nstor(m)        = nstor(m)
        this%br_xr(m)        = br_xr(m)
+       !pft variables for FUN
+       this%perecm          = perecm(m) 
+       this%a_fix           = a_fix(m)
+       this%b_fix           = b_fix(m)
+       this%c_fix           = c_fix(m)
+       this%s_fix           = s_fix(m)
+       this%akc_active      = akc_active(m)
+       this%akn_active      = akn_active(m)
+       this%akcp_active     = akcp_active(m)
+       this%akp_active      = akp_active(m)
+       this%ekc_active      = ekc_active(m)
+       this%ekn_active      = ekn_active(m)
+       this%ekcp_active     = ekcp_active(m)
+       this%ekp_active      = ekp_active(m)
+       this%kc_nonmyc       = kc_nonmyc(m)
+       this%kn_nonmyc       = kn_nonmyc(m)
+       this%kcp_nonmyc      = kcp_nonmyc(m)
+       this%kp_nonmyc       = kp_nonmyc(m)
+       this%kr_resorb       = kr_resorb(m)
+       this%krp_resorb      = krp_resorb(m)
+
+       this%fun_cn_flex_a   = fun_cn_flex_a(m)
+       this%fun_cn_flex_b   = fun_cn_flex_b(m)
+       this%fun_cn_flex_c   = fun_cn_flex_c(m)
+       this%fun_cp_flex_a   = fun_cp_flex_a(m)
+       this%fun_cp_flex_b   = fun_cp_flex_b(m)
+       this%fun_cp_flex_c   = fun_cp_flex_c(m)
+       this%FUN_fracfixers  = FUN_fracfixers(m)
+
  
     end do
     
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/external_models/emi/src/elm_stub/elm_subgrid_types/ColumnDataType.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/external_models/emi/src/elm_stub/elm_subgrid_types/ColumnDataType.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/external_models/emi/src/elm_stub/elm_subgrid_types/ColumnDataType.F90	2020-06-10 13:56:35.530389665 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/external_models/emi/src/elm_stub/elm_subgrid_types/ColumnDataType.F90	2020-05-10 20:09:51.026092935 -0400
@@ -601,6 +601,9 @@
     real(r8), pointer :: actual_immob                          (:)     => null() ! vert-int (diagnostic) actual N immobilization (gN/m2/s)
     real(r8), pointer :: sminn_to_plant_vr                     (:,:)   => null() ! vertically-resolved plant uptake of soil mineral N (gN/m3/s)
     real(r8), pointer :: sminn_to_plant                        (:)     => null() ! vert-int (diagnostic) plant uptake of soil mineral N (gN/m2/s)
+    real(r8), pointer :: sminn_to_plant_fun_vr                     (:,:)   => null() ! vertically-resolved plant uptake of soil mineral N (gN/m3/s)
+    real(r8), pointer :: sminn_to_plant_fun                        (:)     => null() ! vert-int (diagnostic) plant uptake of soil mineral N (gN/m2/s)
+
     real(r8), pointer :: supplement_to_sminn_vr                (:,:)   => null() ! vertically-resolved supplemental N supply (gN/m3/s)
     real(r8), pointer :: supplement_to_sminn                   (:)     => null() ! vert-int (diagnostic) supplemental N supply (gN/m2/s)
     real(r8), pointer :: gross_nmin_vr                         (:,:)   => null() ! vertically-resolved gross rate of N mineralization (gN/m3/s)
@@ -634,6 +637,8 @@
     real(r8), pointer :: actual_immob_nh4_vr                   (:,:)   => null() ! vertically-resolved actual immobilization of NH4 (gN/m3/s)
     real(r8), pointer :: smin_no3_to_plant_vr                  (:,:)   => null() ! vertically-resolved plant uptake of soil NO3 (gN/m3/s)
     real(r8), pointer :: smin_nh4_to_plant_vr                  (:,:)   => null() ! vertically-resolved plant uptake of soil NH4 (gN/m3/s)
+    real(r8), pointer :: smin_no3_to_plant_fun_vr                  (:,:)   => null() ! vertically-resolved plant uptake of soil NO3 (gN/m3/s)
+    real(r8), pointer :: smin_nh4_to_plant_fun_vr                  (:,:)   => null() ! vertically-resolved plant uptake of soil NH4 (gN/m3/s)
     real(r8), pointer :: actual_immob_no3                      (:)     => null() ! actual immobilization of NO3 (gN/m2/s)
     real(r8), pointer :: actual_immob_nh4                      (:)     => null() ! actual immobilization of NH4 (gN/m2/s)
     real(r8), pointer :: smin_no3_to_plant                     (:)     => null() ! plant uptake of soil NO3 (gN/m2/s)
@@ -767,6 +772,8 @@
     real(r8), pointer :: actual_immob_p                        (:)     ! vert-int (diagnostic) actual P immobilization (gP/m2/s)
     real(r8), pointer :: sminp_to_plant_vr                     (:,:)   ! vertically-resolved plant uptake of soil mineral P (gP/m3/s)
     real(r8), pointer :: sminp_to_plant                        (:)     ! vert-int (diagnostic) plant uptake of soil mineral P (gP/m2/s)
+    real(r8), pointer :: sminp_to_plant_fun_vr                     (:,:)   ! vertically-resolved plant uptake of soil mineral P (gP/m3/s)
+    real(r8), pointer :: sminp_to_plant_fun                        (:)     ! vert-int (diagnostic) plant uptake of soil mineral P (gP/m2/s)
     real(r8), pointer :: supplement_to_sminp_vr                (:,:)   ! vertically-resolved supplemental P supply (gP/m3/s)
     real(r8), pointer :: supplement_to_sminp                   (:)     ! vert-int (diagnostic) supplemental P supply (gP/m2/s)
     real(r8), pointer :: gross_pmin_vr                         (:,:)   ! vertically-resolved gross rate of P mineralization (gP/m3/s)
@@ -1585,6 +1592,7 @@
     allocate(this%hrv_deadstemn_to_prod100n       (begc:endc))                   ; this%hrv_deadstemn_to_prod100n      (:)   = nan
     allocate(this%hrv_cropn_to_prod1n             (begc:endc))                   ; this%hrv_cropn_to_prod1n            (:)   = nan
     allocate(this%sminn_to_plant                  (begc:endc))                   ; this%sminn_to_plant	              (:)   = nan
+    allocate(this%sminn_to_plant_fun                  (begc:endc))                   ; this%sminn_to_plant_fun	              (:)   = nan
     allocate(this%potential_immob                 (begc:endc))                   ; this%potential_immob                (:)   = nan
     allocate(this%actual_immob                    (begc:endc))                   ; this%actual_immob                   (:)   = nan
     allocate(this%gross_nmin                      (begc:endc))                   ; this%gross_nmin                     (:)   = nan
@@ -1609,6 +1617,7 @@
     allocate(this%potential_immob_vr              (begc:endc,1:nlevdecomp_full)) ; this%potential_immob_vr             (:,:) = nan
     allocate(this%actual_immob_vr                 (begc:endc,1:nlevdecomp_full)) ; this%actual_immob_vr                (:,:) = nan
     allocate(this%sminn_to_plant_vr               (begc:endc,1:nlevdecomp_full)) ; this%sminn_to_plant_vr              (:,:) = nan
+    allocate(this%sminn_to_plant_fun_vr               (begc:endc,1:nlevdecomp_full)) ; this%sminn_to_plant_fun_vr              (:,:) = nan
     allocate(this%supplement_to_sminn_vr          (begc:endc,1:nlevdecomp_full)) ; this%supplement_to_sminn_vr         (:,:) = nan
     allocate(this%gross_nmin_vr                   (begc:endc,1:nlevdecomp_full)) ; this%gross_nmin_vr                  (:,:) = nan
     allocate(this%net_nmin_vr                     (begc:endc,1:nlevdecomp_full)) ; this%net_nmin_vr                    (:,:) = nan
@@ -1637,6 +1646,8 @@
     allocate(this%actual_immob_nh4_vr             (begc:endc,1:nlevdecomp_full)) ; this%actual_immob_nh4_vr            (:,:) = nan
     allocate(this%smin_no3_to_plant_vr            (begc:endc,1:nlevdecomp_full)) ; this%smin_no3_to_plant_vr           (:,:) = nan
     allocate(this%smin_nh4_to_plant_vr            (begc:endc,1:nlevdecomp_full)) ; this%smin_nh4_to_plant_vr           (:,:) = nan
+    allocate(this%smin_no3_to_plant_fun_vr            (begc:endc,1:nlevdecomp_full)) ; this%smin_no3_to_plant_fun_vr           (:,:) = nan
+    allocate(this%smin_nh4_to_plant_fun_vr            (begc:endc,1:nlevdecomp_full)) ; this%smin_nh4_to_plant_fun_vr           (:,:) = nan
     allocate(this%smin_no3_to_plant               (begc:endc))                   ; this%smin_no3_to_plant              (:)   = nan
     allocate(this%smin_nh4_to_plant               (begc:endc))                   ; this%smin_nh4_to_plant              (:)   = nan
     allocate(this%f_nit                           (begc:endc))                   ; this%f_nit                          (:)   = nan
@@ -1770,6 +1781,7 @@
     allocate(this%hrv_deadstemp_to_prod100p        (begc:endc))                   ; this%hrv_deadstemp_to_prod100p     (:)   = nan
     allocate(this%hrv_cropp_to_prod1p              (begc:endc))                   ; this%hrv_cropp_to_prod1p           (:)   = nan
     allocate(this%sminp_to_plant                   (begc:endc))                   ; this%sminp_to_plant                (:)   = nan
+    allocate(this%sminp_to_plant_fun                  (begc:endc))                   ; this%sminp_to_plant_fun                (:)   = nan
     allocate(this%potential_immob_p                (begc:endc))                   ; this%potential_immob_p             (:)   = nan
     allocate(this%actual_immob_p                   (begc:endc))                   ; this%actual_immob_p                (:)   = nan
     allocate(this%gross_pmin                       (begc:endc))                   ; this%gross_pmin                    (:)   = nan
@@ -1791,6 +1803,7 @@
     allocate(this%potential_immob_p_vr             (begc:endc,1:nlevdecomp_full)) ; this%potential_immob_p_vr          (:,:) = nan
     allocate(this%actual_immob_p_vr                (begc:endc,1:nlevdecomp_full)) ; this%actual_immob_p_vr             (:,:) = nan
     allocate(this%sminp_to_plant_vr                (begc:endc,1:nlevdecomp_full)) ; this%sminp_to_plant_vr             (:,:) = nan
+    allocate(this%sminp_to_plant_fun_vr                (begc:endc,1:nlevdecomp_full)) ; this%sminp_to_plant_fun_vr             (:,:) = nan
     allocate(this%supplement_to_sminp_vr           (begc:endc,1:nlevdecomp_full)) ; this%supplement_to_sminp_vr        (:,:) = nan
     allocate(this%gross_pmin_vr                    (begc:endc,1:nlevdecomp_full)) ; this%gross_pmin_vr                 (:,:) = nan
     allocate(this%net_pmin_vr                      (begc:endc,1:nlevdecomp_full)) ; this%net_pmin_vr                   (:,:) = nan
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/external_models/emi/src/elm_stub/elm_subgrid_types/VegetationDataType.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/external_models/emi/src/elm_stub/elm_subgrid_types/VegetationDataType.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/external_models/emi/src/elm_stub/elm_subgrid_types/VegetationDataType.F90	2020-06-10 13:56:35.543389599 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/external_models/emi/src/elm_stub/elm_subgrid_types/VegetationDataType.F90	2020-07-23 20:27:23.640247664 -0400
@@ -441,9 +441,13 @@
     real(r8), pointer :: deadstemc_xfer_to_deadstemc         (:) => null()    ! dead stem C growth from storage (gC/m2/s)
     real(r8), pointer :: livecrootc_xfer_to_livecrootc       (:) => null()    ! live coarse root C growth from storage (gC/m2/s)
     real(r8), pointer :: deadcrootc_xfer_to_deadcrootc       (:) => null()    ! dead coarse root C growth from storage (gC/m2/s)
+
+
                                                                  
     ! leaf and fine root litterfall fluxes                          
     real(r8), pointer :: leafc_to_litter                     (:) => null()    ! leaf C litterfall (gC/m2/s)
+    real(r8), pointer :: leafc_to_litter_fun                 (:) => null()    ! leaf C litterfall used by FUN (gC/m2/s)
+    real(r8), pointer :: leafc_to_litter_funp                (:) => null()    ! leaf C litterfall used by FUN-P (gC/m2/s)
     real(r8), pointer :: frootc_to_litter                    (:) => null()    ! fine root C litterfall (gC/m2/s)
     real(r8), pointer :: livestemc_to_litter                 (:) => null()    ! live stem C litterfall (gC/m2/s)
     real(r8), pointer :: grainc_to_food                      (:) => null()    ! grain C to food for prognostic crop(gC/m2/s)
@@ -593,6 +597,40 @@
     ! For comparison with RAINFOR wood productivity data         
     real(r8), pointer :: agwdnpp                             (:) => null()    !(gC/m2/s) aboveground NPP
 
+!Variables used by FUN
+     real(r8), pointer :: npp_Nactive                        (:) => null()     ! C used by mycorrhizal uptake    (gC/m2/s)
+     real(r8), pointer :: npp_burnedoff                      (:) => null()     ! C that cannot be used for N uptake   (gC/m2/s)
+     real(r8), pointer :: npp_Nnonmyc                        (:) => null()     ! C used by non-myc uptake        (gC/m2/s)
+     real(r8), pointer :: npp_Nam                            (:) => null()     ! C used by AM plant              (gC/m2/s)
+     real(r8), pointer :: npp_Necm                           (:) => null()     ! C used by ECM plant             (gC/m2/s)
+     real(r8), pointer :: npp_Nactive_no3                    (:) => null()     ! C used by mycorrhizal uptake    (gC/m2/s)
+     real(r8), pointer :: npp_Nactive_nh4                    (:) => null()     ! C used by mycorrhizal uptake    (gC/m2/s)
+     real(r8), pointer :: npp_Nnonmyc_no3                    (:) => null()     ! C used by non-myc               (gC/m2/s)
+     real(r8), pointer :: npp_Nnonmyc_nh4                    (:) => null()     ! C used by non-myc               (gC/m2/s)
+     real(r8), pointer :: npp_Nam_no3                        (:) => null()     ! C used by AM plant              (gC/m2/s)
+     real(r8), pointer :: npp_Nam_nh4                        (:) => null()     ! C used by AM plant              (gC/m2/s)
+     real(r8), pointer :: npp_Necm_no3                       (:) => null()     ! C used by ECM plant             (gC/m2/s)
+     real(r8), pointer :: npp_Necm_nh4                       (:) => null()     ! C used by ECM plant             (gC/m2/s)
+     real(r8), pointer :: npp_Nfix                           (:) => null()     ! C used by Symbiotic BNF         (gC/m2/s)
+     real(r8), pointer :: npp_Nretrans                       (:) => null()     ! C used by retranslocation       (gC/m2/s)
+     real(r8), pointer :: npp_Nuptake                        (:) => null()     ! Total C used by N uptake in FUN (gC/m2/s)
+     real(r8), pointer :: npp_growth                         (:) => null()     ! Total C u for growth in FUN      (gC/m2/s)   
+     real(r8), pointer :: leafc_change                       (:) => null()     ! Total used C from leaves        (gC/m2/s)
+     real(r8), pointer :: soilc_change                       (:) => null()     ! Total used C from soil          (gC/m2/s)
+
+    !Variables used by FUN-P
+     real(r8), pointer :: npp_Pactive                        (:) => null()     ! C used by mycorrhizal uptake    (gC/m2/s)
+     real(r8), pointer :: npp_burnedoff_p                    (:) => null()     ! C that cannot be used for N uptake   (gC/m2/s)
+     real(r8), pointer :: npp_Pnonmyc                        (:) => null()     ! C used by non-myc uptake        (gC/m2/s)
+     real(r8), pointer :: npp_Pam                            (:) => null()     ! C used by AM plant              (gC/m2/s)
+     real(r8), pointer :: npp_Pecm                           (:) => null()     ! C used by ECM plant             (gC/m2/s)
+     real(r8), pointer :: npp_Pretrans                       (:) => null()     ! C used by retranslocation       (gC/m2/s)
+     real(r8), pointer :: npp_Puptake                        (:) => null()     ! Total C used by N uptake in FUN (gC/m2/s)
+     real(r8), pointer :: npp_growth_p                       (:) => null()     ! Total C u for growth in FUN      (gC/m2/s)   
+     real(r8), pointer :: leafc_change_p                     (:) => null()     ! Total used C from leaves for P      (gC/m2/s)
+     real(r8), pointer :: soilc_change_p                     (:) => null()     ! Total used C from soil for P         (gC/m2/s)
+ 
+
   contains
     procedure, public :: Init       => veg_cf_init
   end type vegetation_carbon_flux
@@ -761,6 +799,41 @@
     real(r8), pointer :: plant_ndemand                       (:)   => null()  ! N flux required to support initial GPP (gN/m2/s)
     real(r8), pointer :: avail_retransn                      (:)   => null()  ! N flux available from retranslocation pool (gN/m2/s)
     real(r8), pointer :: plant_nalloc                        (:)   => null()  ! total allocated N flux (gN/m2/s)
+
+!Variables used by FUN
+     real(r8), pointer :: plant_ndemand_retrans               (:)   => null()     ! The N demand pool generated for FUN2.0; mainly used for deciduous trees (gN/m2/s)
+     real(r8), pointer :: plant_ndemand_season                (:)   => null()     ! The N demand pool for seasonal deciduous (gN/m2/s)
+     real(r8), pointer :: plant_ndemand_stress                (:)   => null()     ! The N demand pool for stress deciduous   (gN/m2/s)
+     real(r8), pointer :: Nactive                             (:)   => null()     ! N acquired by mycorrhizal uptake  (gN/m2/s)
+     real(r8), pointer :: Nnonmyc                             (:)   => null()     ! N acquired by non-myc uptake      (gN/m2/s)
+     real(r8), pointer :: Nam                                 (:)   => null()     ! N acquired by AM plant            (gN/m2/s)
+     real(r8), pointer :: Necm                                (:)   => null()     ! N acquired by ECM plant           (gN/m2/s)
+     real(r8), pointer :: Nactive_no3                         (:)   => null()     ! N acquired by mycorrhizal uptake  (gN/m2/s)
+     real(r8), pointer :: Nactive_nh4                         (:)   => null()     ! N acquired by mycorrhizal uptake  (gN/m2/s)
+     real(r8), pointer :: Nnonmyc_no3                         (:)   => null()     ! N acquired by non-myc             (gN/m2/s)
+     real(r8), pointer :: Nnonmyc_nh4                         (:)   => null()     ! N acquired by non-myc             (gN/m2/s)
+     real(r8), pointer :: Nam_no3                             (:)   => null()     ! N acquired by AM plant            (gN/m2/s)
+     real(r8), pointer :: Nam_nh4                             (:)   => null()     ! N acquired by AM plant            (gN/m2/s)
+     real(r8), pointer :: Necm_no3                            (:)   => null()     ! N acquired by ECM plant           (gN/m2/s)
+     real(r8), pointer :: Necm_nh4                            (:)   => null()     ! N acquired by ECM plant           (gN/m2/s)
+     real(r8), pointer :: Nfix                                (:)   => null()     ! N acquired by Symbiotic BNF       (gN/m2/s)
+     real(r8), pointer :: Npassive                            (:)   => null()     ! N acquired by passive uptake      (gN/m2/s)
+     real(r8), pointer :: Nretrans                            (:)   => null()     ! N acquired by retranslocation     (gN/m2/s)
+     real(r8), pointer :: Nretrans_org                        (:)   => null()     ! N acquired by retranslocation     (gN/m2/s)
+     real(r8), pointer :: Nretrans_season                     (:)   => null()     ! N acquired by retranslocation     (gN/m2/s)
+     real(r8), pointer :: Nretrans_stress                     (:)   => null()     ! N acquired by retranslocation     (gN/m2/s)
+     real(r8), pointer :: Nuptake                             (:)   => null()     ! Total N uptake of FUN             (gN/m2/s)
+     real(r8), pointer :: sminn_to_plant_fun                  (:)   => null()     ! Total soil N uptake of FUN        (gN/m2/s)
+     real(r8), pointer :: sminn_to_plant_fun_vr               (:,:) => null()  ! Total layer soil N uptake of FUN  (gN/m2/s)
+     real(r8), pointer :: sminn_to_plant_fun_no3_vr           (:,:) => null()  ! Total layer no3 uptake of FUN     (gN/m2/s)
+     real(r8), pointer :: sminn_to_plant_fun_nh4_vr           (:,:) => null()  ! Total layer nh4 uptake of FUN     (gN/m2/s)
+     real(r8), pointer :: cost_nfix                           (:) => null()    ! Average cost of fixation          (gN/m2/s)
+     real(r8), pointer :: cost_nactive                        (:) => null()    ! Average cost of active uptake     (gN/m2/s)
+     real(r8), pointer :: cost_nretrans                       (:) => null()    ! Average cost of retranslocation   (gN/m2/s)
+     real(r8), pointer :: cost_nnonmyc                        (:) => null()    ! Average cost of non-myc   (gN/m2/s)
+     real(r8), pointer :: nuptake_npp_fraction                (:) => null()   ! frac of npp spent on N acquisition   (gN/m2/s)
+
+
     real(r8), pointer :: smin_no3_to_plant                   (:)   => null()  ! pft level plant uptake of soil NO3 (gN/m2/s) BGC mode
     real(r8), pointer :: smin_nh4_to_plant                   (:)   => null()  ! pft level plant uptake of soil Nh4 (gN/m2/s) BGC mode
     real(r8), pointer :: sminn_to_plant                      (:)   => null()  ! pft level plant uptake of soil N (gN/m2/s) CN mode
@@ -928,6 +1001,29 @@
     real(r8), pointer :: plant_pdemand                       (:)     ! P flux required to support initial GPP (gP/m2/s)
     real(r8), pointer :: avail_retransp                      (:)     ! P flux available from retranslocation pool (gP/m2/s)
     real(r8), pointer :: plant_palloc                        (:)     ! total allocated P flux (gP/m2/s)
+
+!Variables used by FUN-P
+     real(r8), pointer :: plant_pdemand_retrans               (:)   => null()     ! The P demand pool generated for FUN2.0; mainly used for deciduous trees (gP/m2/s)
+     real(r8), pointer :: plant_pdemand_season                (:)   => null()     ! The P demand pool for seasonal deciduous (gP/m2/s)
+     real(r8), pointer :: plant_pdemand_stress                (:)   => null()     ! The P demand pool for stress deciduous   (gP/m2/s)
+     real(r8), pointer :: Pactive                             (:)   => null()     ! P acquired by mycorrhizal uptake  (gP/m2/s)
+     real(r8), pointer :: Pnonmyc                             (:)   => null()     ! P acquired by non-myc uptake      (gP/m2/s)
+     real(r8), pointer :: Pam                                 (:)   => null()     ! P acquired by AM plant            (gP/m2/s)
+     real(r8), pointer :: Pecm                                (:)   => null()     ! P acquired by ECM plant           (gP/m2/s)
+     real(r8), pointer :: Ppassive                            (:)   => null()     ! P acquired by passive uptake      (gP/m2/s)
+     real(r8), pointer :: Pretrans                            (:)   => null()     ! P acquired by retranslocation     (gP/m2/s)
+     real(r8), pointer :: Pretrans_org                        (:)   => null()     ! P acquired by retranslocation     (gP/m2/s)
+     real(r8), pointer :: Pretrans_season                     (:)   => null()     ! N acquired by retranslocation     (gP/m2/s)
+     real(r8), pointer :: Pretrans_stress                     (:)   => null()     ! N acquired by retranslocation     (gP/m2/s)
+     real(r8), pointer :: Puptake                             (:)   => null()     ! Total P uptake of FUN             (gP/m2/s)
+     real(r8), pointer :: sminp_to_plant_fun                  (:)   => null()     ! Total soil N uptake of FUN        (gP/m2/s)
+     real(r8), pointer :: sminp_to_plant_fun_vr               (:,:) => null()  ! Total layer soil N uptake of FUN  (gP/m2/s)
+     real(r8), pointer :: cost_pactive                        (:) => null()    ! Average cost of active uptake     (gP/m2/s)
+     real(r8), pointer :: cost_pretrans                       (:) => null()    ! Average cost of retranslocation   (gP/m2/s)
+    real(r8), pointer :: cost_pnonmyc                       (:) => null()    ! Average cost of non-myc   (gP/m2/s)
+     real(r8), pointer :: puptake_npp_fraction                (:) => null()   ! frac of npp spent on P acquisition   (gP/m2/s)
+
+
     real(r8), pointer :: sminp_to_plant                      (:)     ! plant p uptake (gP/m2/s)
     real(r8), pointer :: plant_pdemand_vr                    (:,:)   ! plant P demand
     real(r8), pointer :: prev_leafp_to_litter                (:)     ! previous timestep leaf P litterfall flux (gP/m2/s)
@@ -1480,6 +1576,8 @@
        allocate(this%livecrootc_xfer_to_livecrootc       (begp:endp)) ;    this%livecrootc_xfer_to_livecrootc        (:) = nan
        allocate(this%deadcrootc_xfer_to_deadcrootc       (begp:endp)) ;    this%deadcrootc_xfer_to_deadcrootc        (:) = nan
        allocate(this%leafc_to_litter                     (begp:endp)) ;    this%leafc_to_litter                      (:) = nan
+       allocate(this%leafc_to_litter_fun                 (begp:endp)) ;    this%leafc_to_litter_fun                  (:) = nan
+       allocate(this%leafc_to_litter_funp                (begp:endp)) ;    this%leafc_to_litter_funp                 (:) = nan
        allocate(this%frootc_to_litter                    (begp:endp)) ;    this%frootc_to_litter                     (:) = nan
        allocate(this%livestemc_to_litter                 (begp:endp)) ;    this%livestemc_to_litter                  (:) = nan
        allocate(this%grainc_to_food                      (begp:endp)) ;    this%grainc_to_food                       (:) = nan
@@ -1582,6 +1680,42 @@
        allocate(this%woodc_loss                          (begp:endp)) ;    this%woodc_loss                           (:) = nan
        allocate(this%fire_closs                          (begp:endp)) ;    this%fire_closs                           (:) = nan
        allocate(this%crop_seedc_to_leaf                  (begp:endp)) ;    this%crop_seedc_to_leaf                   (:) = nan
+
+!Variables used by FUN
+    allocate(this%npp_Nactive                         (begp:endp)) ; this%npp_Nactive                          (:) = nan
+    allocate(this%npp_burnedoff                       (begp:endp)) ; this%npp_burnedoff                        (:) = nan
+    allocate(this%npp_Nnonmyc                         (begp:endp)) ; this%npp_Nnonmyc                          (:) = nan
+    allocate(this%npp_Nam                             (begp:endp)) ; this%npp_Nam                              (:) = nan
+    allocate(this%npp_Necm                            (begp:endp)) ; this%npp_Necm                             (:) = nan
+    allocate(this%npp_Nactive_no3                     (begp:endp)) ; this%npp_Nactive_no3                      (:) = nan
+    allocate(this%npp_Nactive_nh4                     (begp:endp)) ; this%npp_Nactive_nh4                      (:) = nan
+    allocate(this%npp_Nnonmyc_no3                     (begp:endp)) ; this%npp_Nnonmyc_no3                      (:) = nan
+    allocate(this%npp_Nnonmyc_nh4                     (begp:endp)) ; this%npp_Nnonmyc_nh4                      (:) = nan
+    allocate(this%npp_Nam_no3                         (begp:endp)) ; this%npp_Nam_no3                          (:) = nan
+    allocate(this%npp_Nam_nh4                         (begp:endp)) ; this%npp_Nam_nh4                          (:) = nan
+    allocate(this%npp_Necm_no3                        (begp:endp)) ; this%npp_Necm_no3                         (:) = nan
+    allocate(this%npp_Necm_nh4                        (begp:endp)) ; this%npp_Necm_nh4                         (:) = nan
+    allocate(this%npp_Nfix                            (begp:endp)) ; this%npp_Nfix                             (:) = nan
+    allocate(this%npp_Nretrans                        (begp:endp)) ; this%npp_Nretrans                         (:) = nan
+    allocate(this%npp_Nuptake                         (begp:endp)) ; this%npp_Nuptake                          (:) = nan
+    allocate(this%npp_growth                          (begp:endp)) ; this%npp_growth                           (:) = nan
+    allocate(this%leafc_change                        (begp:endp)) ; this%leafc_change                         (:) = nan
+    allocate(this%soilc_change                        (begp:endp)) ; this%soilc_change                         (:) = nan
+
+    !Variables used by FUN-P
+    allocate(this%npp_Pactive                         (begp:endp)) ; this%npp_Pactive                          (:) = nan
+    allocate(this%npp_burnedoff_p                     (begp:endp)) ; this%npp_burnedoff_p                      (:) = nan
+    allocate(this%npp_Pnonmyc                         (begp:endp)) ; this%npp_Pnonmyc                          (:) = nan
+    allocate(this%npp_Pam                             (begp:endp)) ; this%npp_Pam                              (:) = nan
+    allocate(this%npp_Pecm                            (begp:endp)) ; this%npp_Pecm                             (:) = nan
+    allocate(this%npp_Pretrans                        (begp:endp)) ; this%npp_Pretrans                         (:) = nan
+    allocate(this%npp_Puptake                         (begp:endp)) ; this%npp_Puptake                          (:) = nan
+
+    allocate(this%npp_growth_p                        (begp:endp)) ; this%npp_growth_p                         (:) = nan
+    allocate(this%leafc_change_p                      (begp:endp)) ; this%leafc_change_p                       (:) = nan
+    allocate(this%soilc_change_p                      (begp:endp)) ; this%soilc_change_p                       (:) = nan
+
+
     end if ! .not use fates
 
     allocate(this%dwt_seedc_to_leaf                   (begp:endp)) ;    this%dwt_seedc_to_leaf                    (:) = nan
@@ -1601,6 +1735,8 @@
     allocate(this%allocation_stem                     (begp:endp)) ;    this%allocation_stem                      (:) = nan
     allocate(this%allocation_froot                    (begp:endp)) ;    this%allocation_froot                     (:) = nan
 
+ 
+
   end subroutine veg_cf_init
     
   !------------------------------------------------------------------------
@@ -1769,6 +1905,41 @@
     allocate(this%plant_ndemand                       (begp:endp)) ; this%plant_ndemand                       (:) = nan
     allocate(this%avail_retransn                      (begp:endp)) ; this%avail_retransn                      (:) = nan
     allocate(this%plant_nalloc                        (begp:endp)) ; this%plant_nalloc                        (:) = nan
+
+!Variables used by FUN
+    allocate(this%plant_ndemand_retrans (begp:endp)) ;    this%plant_ndemand_retrans (:) = nan
+    allocate(this%plant_ndemand_season  (begp:endp)) ;    this%plant_ndemand_season  (:) = nan
+    allocate(this%plant_ndemand_stress  (begp:endp)) ;    this%plant_ndemand_stress  (:) = nan
+    allocate(this%Nactive               (begp:endp)) ;    this%Nactive               (:) = nan 
+    allocate(this%Nnonmyc               (begp:endp)) ;    this%Nnonmyc               (:) = nan
+    allocate(this%Nam                   (begp:endp)) ;    this%Nam                   (:) = nan
+    allocate(this%Necm                  (begp:endp)) ;    this%Necm                  (:) = nan
+    allocate(this%Nactive_no3           (begp:endp)) ;    this%Nactive_no3           (:) = nan
+    allocate(this%Nactive_nh4           (begp:endp)) ;    this%Nactive_nh4           (:) = nan
+    allocate(this%Nnonmyc_no3           (begp:endp)) ;    this%Nnonmyc_no3           (:) = nan
+    allocate(this%Nnonmyc_nh4           (begp:endp)) ;    this%Nnonmyc_nh4           (:) = nan
+    allocate(this%Nam_no3               (begp:endp)) ;    this%Nam_no3               (:) = nan
+    allocate(this%Nam_nh4               (begp:endp)) ;    this%Nam_nh4               (:) = nan
+    allocate(this%Necm_no3              (begp:endp)) ;    this%Necm_no3              (:) = nan
+    allocate(this%Necm_nh4              (begp:endp)) ;    this%Necm_nh4              (:) = nan
+    allocate(this%Npassive              (begp:endp)) ;    this%Npassive              (:) = nan
+    allocate(this%Nfix                  (begp:endp)) ;    this%Nfix                  (:) = nan
+    allocate(this%Nretrans              (begp:endp)) ;    this%Nretrans              (:) = nan
+    allocate(this%Nretrans_org          (begp:endp)) ;    this%Nretrans_org          (:) = nan
+    allocate(this%Nretrans_season       (begp:endp)) ;    this%Nretrans_season       (:) = nan
+    allocate(this%Nretrans_stress       (begp:endp)) ;    this%Nretrans_stress       (:) = nan 
+    allocate(this%Nuptake               (begp:endp)) ;    this%Nuptake               (:) = nan
+    allocate(this%sminn_to_plant_fun    (begp:endp)) ;    this%sminn_to_plant_fun    (:) = nan
+    allocate(this%sminn_to_plant_fun_vr (begp:endp,1:nlevdecomp_full)) ; this%sminn_to_plant_fun_vr          (:,:) = nan
+    allocate(this%sminn_to_plant_fun_no3_vr (begp:endp,1:nlevdecomp_full)) ; this%sminn_to_plant_fun_no3_vr      (:,:) = nan
+    allocate(this%sminn_to_plant_fun_nh4_vr (begp:endp,1:nlevdecomp_full)) ; this%sminn_to_plant_fun_nh4_vr      (:,:) = nan
+    allocate(this%cost_nfix              (begp:endp)) ;    this%cost_nfix            (:) = nan
+    allocate(this%cost_nactive           (begp:endp)) ;    this%cost_nactive         (:) = nan
+    allocate(this%cost_nretrans          (begp:endp)) ;    this%cost_nretrans        (:) = nan
+    allocate(this%cost_nnonmyc           (begp:endp)) ;    this%cost_nnonmyc        (:) = nan
+    allocate(this%nuptake_npp_fraction   (begp:endp)) ;    this%nuptake_npp_fraction            (:) = nan
+
+
     allocate(this%smin_no3_to_plant                   (begp:endp)) ; this%smin_no3_to_plant                   (:) = nan
     allocate(this%smin_nh4_to_plant                   (begp:endp)) ; this%smin_nh4_to_plant                   (:) = nan
     allocate(this%sminn_to_plant                      (begp:endp)) ; this%sminn_to_plant                      (:) = nan
@@ -1950,6 +2121,30 @@
     allocate(this%plant_pdemand                       (begp:endp)) ; this%plant_pdemand                       (:) = nan
     allocate(this%avail_retransp                      (begp:endp)) ; this%avail_retransp                      (:) = nan
     allocate(this%plant_palloc                        (begp:endp)) ; this%plant_palloc                        (:) = nan
+
+!Variables used by FUN-P
+    allocate(this%plant_pdemand_retrans (begp:endp)) ;    this%plant_pdemand_retrans (:) = nan
+    allocate(this%plant_pdemand_season  (begp:endp)) ;    this%plant_pdemand_season  (:) = nan
+    allocate(this%plant_pdemand_stress  (begp:endp)) ;    this%plant_pdemand_stress  (:) = nan
+    allocate(this%Pactive               (begp:endp)) ;    this%Pactive               (:) = nan 
+    allocate(this%Pnonmyc               (begp:endp)) ;    this%Pnonmyc               (:) = nan
+    allocate(this%Pam                   (begp:endp)) ;    this%Pam                   (:) = nan
+    allocate(this%Pecm                  (begp:endp)) ;    this%Pecm                  (:) = nan
+    allocate(this%Ppassive              (begp:endp)) ;    this%Ppassive              (:) = nan
+    allocate(this%Pretrans              (begp:endp)) ;    this%Pretrans              (:) = nan
+    allocate(this%Pretrans_org          (begp:endp)) ;    this%Pretrans_org          (:) = nan
+    allocate(this%Pretrans_season       (begp:endp)) ;    this%Pretrans_season       (:) = nan
+    allocate(this%Pretrans_stress       (begp:endp)) ;    this%Pretrans_stress       (:) = nan 
+    allocate(this%Puptake               (begp:endp)) ;    this%Puptake               (:) = nan
+    allocate(this%sminp_to_plant_fun    (begp:endp)) ;    this%sminp_to_plant_fun    (:) = nan
+    allocate(this%sminp_to_plant_fun_vr (begp:endp,1:nlevdecomp_full)) 
+    this%sminp_to_plant_fun_vr          (:,:) = nan
+    allocate(this%cost_pactive           (begp:endp)) ;    this%cost_pactive         (:) = nan
+    allocate(this%cost_pretrans          (begp:endp)) ;    this%cost_pretrans        (:) = nan
+   allocate(this%cost_pnonmyc            (begp:endp)) ;    this%cost_pnonmyc         (:) = nan
+    allocate(this%puptake_npp_fraction   (begp:endp)) ;    this%puptake_npp_fraction            (:) = nan
+
+
     allocate(this%sminp_to_plant                      (begp:endp)) ; this%sminp_to_plant                      (:) = nan
     allocate(this%plant_pdemand_vr                    (begp:endp,1:nlevdecomp_full )) ; this%plant_pdemand_vr (:,:) = nan
     allocate(this%prev_leafp_to_litter                (begp:endp)) ; this%prev_leafp_to_litter                (:) = nan
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/external_models/emi/src/elm_stub/elm_types_stub/CNCarbonStateType.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/external_models/emi/src/elm_stub/elm_types_stub/CNCarbonStateType.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/external_models/emi/src/elm_stub/elm_types_stub/CNCarbonStateType.F90	2020-06-10 13:56:35.549389569 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/external_models/emi/src/elm_stub/elm_types_stub/CNCarbonStateType.F90	2020-05-10 20:09:51.096092527 -0400
@@ -34,6 +34,7 @@
      real(r8), pointer :: leafc_patch              (:)     ! (gC/m2) leaf C
      real(r8), pointer :: leafc_storage_patch      (:)     ! (gC/m2) leaf C storage
      real(r8), pointer :: leafc_xfer_patch         (:)     ! (gC/m2) leaf C transfer
+     real(r8), pointer :: leafc_storage_xfer_acc_patch  (:)   ! (gC/m2) Accumulated leaf C transfer
      real(r8), pointer :: frootc_patch             (:)     ! (gC/m2) fine root C
      real(r8), pointer :: frootc_storage_patch     (:)     ! (gC/m2) fine root C storage
      real(r8), pointer :: frootc_xfer_patch        (:)     ! (gC/m2) fine root C transfer
@@ -169,6 +170,7 @@
        allocate(this%leafc_patch              (begp :endp))                   ;     this%leafc_patch              (:)   = nan
        allocate(this%leafc_storage_patch      (begp :endp))                   ;     this%leafc_storage_patch      (:)   = nan
        allocate(this%leafc_xfer_patch         (begp :endp))                   ;     this%leafc_xfer_patch         (:)   = nan
+       allocate(this%leafc_storage_xfer_acc_patch         (begp :endp))                   ;     this%leafc_storage_xfer_acc_patch     (:)   = nan
        allocate(this%frootc_patch             (begp :endp))                   ;     this%frootc_patch             (:)   = nan
        allocate(this%frootc_storage_patch     (begp :endp))                   ;     this%frootc_storage_patch     (:)   = nan
        allocate(this%frootc_xfer_patch        (begp :endp))                   ;     this%frootc_xfer_patch        (:)   = nan
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/external_models/emi/src/elm_stub/utils/clm_varctl.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/external_models/emi/src/elm_stub/utils/clm_varctl.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/external_models/emi/src/elm_stub/utils/clm_varctl.F90	2020-06-10 13:56:35.604389291 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/external_models/emi/src/elm_stub/utils/clm_varctl.F90	2020-05-10 20:09:51.053092778 -0400
@@ -297,6 +297,8 @@
   logical, public :: use_nofire          = .false.
   logical, public :: use_lch4            = .false.
   logical, public :: use_nitrif_denitrif = .false.
+  logical, public :: use_fun             = .false.
+  logical, public :: use_funp            = .false.
   logical, public :: use_vertsoilc       = .false.
   logical, public :: use_extralakelayers = .false.
   logical, public :: use_vichydro        = .false.
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/external_models/sbetr/src/stub_clm/EcophysConType.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/external_models/sbetr/src/stub_clm/EcophysConType.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/external_models/sbetr/src/stub_clm/EcophysConType.F90	2020-06-10 13:58:03.295946712 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/external_models/sbetr/src/stub_clm/EcophysConType.F90	2020-06-30 18:41:14.178277178 -0400
@@ -112,6 +112,38 @@
      real(r8)              :: lamda_ptase              ! critical value that incur biochemical production
      real(r8), allocatable :: i_vc(:)                  ! intercept of photosynthesis vcmax ~ leaf n content regression model
      real(r8), allocatable :: s_vc(:)                  ! slope of photosynthesis vcmax ~ leaf n content regression model
+     ! pft parameters for FUN
+     real(r8), allocatable :: a_fix         (:)   ! A BNF parameter
+     real(r8), allocatable :: b_fix         (:)   ! A BNF parameter
+     real(r8), allocatable :: c_fix         (:)   ! A BNF parameter
+     real(r8), allocatable :: s_fix         (:)   ! A BNF parameter
+     real(r8), allocatable :: akc_active    (:)   ! A mycorrhizal uptake parameter
+     real(r8), allocatable :: akn_active    (:)   ! A mycorrhizal uptake parameter
+     real(r8), allocatable :: akcp_active   (:)   ! A mycorrhizal uptake parameter
+     real(r8), allocatable :: akp_active    (:)   ! A mycorrhizal uptake parameter
+     real(r8), allocatable :: ekc_active    (:)   ! A mycorrhizal uptake parameter
+     real(r8), allocatable :: ekn_active    (:)   ! A mycorrhizal uptake parameter
+     real(r8), allocatable :: ekcp_active   (:)   ! A mycorrhizal uptake parameter
+     real(r8), allocatable :: ekp_active    (:)   ! A mycorrhizal uptake parameter
+     real(r8), allocatable :: kc_nonmyc     (:)   ! A non-mycorrhizal uptake parameter
+     real(r8), allocatable :: kn_nonmyc     (:)   ! A non-mycorrhizal uptake parameter
+     real(r8), allocatable :: kcp_nonmyc    (:)   ! A non-mycorrhizal uptake parameter
+     real(r8), allocatable :: kp_nonmyc     (:)   ! A non-mycorrhizal uptake parameter
+     real(r8), allocatable :: kr_resorb     (:)   ! A N retrasnlcation parameter
+     real(r8), allocatable :: krp_resorb    (:)   ! A P retranslocation parameter
+     real(r8), allocatable :: perecm        (:)   ! The fraction of ECM-associated PFT 
+     real(r8), allocatable :: fun_cn_flex_a (:)   ! Parameter a of FUN-flexcn link code (def 5)
+     real(r8), allocatable :: fun_cn_flex_b (:)   ! Parameter b of FUN-flexcn link code (def 200)
+     real(r8), allocatable :: fun_cn_flex_c (:)   ! Parameter c of FUN-flexcn link code (def 80)
+     real(r8), allocatable :: fun_cp_flex_a (:)   ! Parameter a of FUNP-flexcp link code (def 5)
+     real(r8), allocatable :: fun_cp_flex_b (:)   ! Parameter b of FUNP-flexcp link code (def 200)
+     real(r8), allocatable :: fun_cp_flex_c (:)   ! Parameter c of FUNP-flexcp link code (def 80)    
+     real(r8), allocatable :: FUN_fracfixers(:)   ! Fraction of C that can be used for fixation.    
+
+
+
+
+
   end type Ecophyscon_type
 
   type(ecophyscon_type), public :: ecophyscon ! patch ecophysiological constants structure
@@ -141,6 +173,15 @@
     use pftvarcon , only : i_vc, s_vc
     use pftvarcon , only : leafcn_obs, frootcn_obs, livewdcn_obs, deadwdcn_obs
     use pftvarcon , only : leafcp_obs, frootcp_obs, livewdcp_obs, deadwdcp_obs
+    !pft variables for FUN
+    use pftvarcon , only : a_fix, b_fix, c_fix, s_fix
+    use pftvarcon , only : akc_active, akn_active, ekc_active, ekn_active
+    use pftvarcon , only : akcp_active, akp_active, ekcp_active, ekp_active
+    use pftvarcon , only : kc_nonmyc, kn_nonmyc, kr_resorb, perecm
+    use pftvarcon , only : kcp_nonmyc, kp_nonmyc, krp_resorb
+    use pftvarcon , only : fun_cn_flex_a, fun_cn_flex_b, fun_cn_flex_c
+    use pftvarcon , only : fun_cp_flex_a, fun_cp_flex_b, fun_cp_flex_c
+    use pftvarcon , only : FUN_fracfixers
 
     !
     ! !LOCAL VARIABLES:
@@ -219,6 +260,34 @@
     allocate( ecophyscon%vmax_ptase_vr(1:nlevdecomp))                  ; ecophyscon%vmax_ptase_vr(:)         =nan
     allocate( ecophyscon%i_vc(0:numpft))                               ; ecophyscon%i_vc(:)                  =nan
     allocate( ecophyscon%s_vc(0:numpft))                               ; ecophyscon%s_vc(:)                  =nan
+    !pft variables for FUN
+    allocate( this%a_fix(0:numpft))                              ; this%a_fix(:)                 =nan
+    allocate( this%b_fix(0:numpft))                              ; this%b_fix(:)                 =nan
+    allocate( this%c_fix(0:numpft))                              ; this%c_fix(:)                 =nan
+    allocate( this%s_fix(0:numpft))                              ; this%s_fix(:)                 =nan 
+    allocate( this%akc_active(0:numpft))                         ; this%akc_active(:)                 =nan
+    allocate( this%akn_active(0:numpft))                         ; this%akn_active(:)                 =nan
+    allocate( this%akcp_active(0:numpft))                        ; this%akcp_active(:)                 =nan
+    allocate( this%akp_active(0:numpft))                         ; this%akp_active(:)                 =nan
+    allocate( this%ekc_active(0:numpft))                         ; this%ekc_active(:)                 =nan
+    allocate( this%ekn_active(0:numpft))                         ; this%ekn_active(:)                 =nan
+    allocate( this%ekcp_active(0:numpft))                        ; this%ekcp_active(:)                 =nan
+    allocate( this%ekp_active(0:numpft))                         ; this%ekp_active(:)                 =nan
+    allocate( this%kc_nonmyc(0:numpft))                          ; this%kc_nonmyc(:)                 =nan
+    allocate( this%kn_nonmyc(0:numpft))                          ; this%kn_nonmyc(:)                 =nan
+    allocate( this%kcp_nonmyc(0:numpft))                         ; this%kcp_nonmyc(:)                 =nan
+    allocate( this%kp_nonmyc(0:numpft))                          ; this%kp_nonmyc(:)                 =nan
+    allocate( this%kr_resorb(0:numpft))                          ; this%kr_resorb(:)                 =nan
+    allocate( this%krp_resorb(0:numpft))                         ; this%krp_resorb(:)                 =nan
+    allocate( this%perecm(0:numpft))                             ; this%perecm(:)                        =nan
+    allocate( this%fun_cn_flex_a(0:numpft))                      ; this%fun_cn_flex_a(:)                 =nan
+    allocate( this%fun_cn_flex_b(0:numpft))                      ; this%fun_cn_flex_b(:)                 =nan
+    allocate( this%fun_cn_flex_c(0:numpft))                      ; this%fun_cn_flex_c(:)                 =nan
+    allocate( this%fun_cp_flex_a(0:numpft))                      ; this%fun_cp_flex_a(:)                 =nan
+    allocate( this%fun_cp_flex_b(0:numpft))                      ; this%fun_cp_flex_b(:)                 =nan
+    allocate( this%fun_cp_flex_c(0:numpft))                      ; this%fun_cp_flex_c(:)                 =nan
+    allocate( this%FUN_fracfixers(0:numpft))                     ; this%FUN_fracfixers(:)                 =nan
+
 
     do m = 0,numpft
 
@@ -284,6 +353,36 @@
        ecophyscon%deadwdcp(m)     = deadwdcp(m)
        ecophyscon%graincp(m)      = graincp(m)
 
+       ecophyscon%perecm(m)      = perecm(m)
+       !pft variables for FUN
+       ecophyscon%a_fix           = a_fix(m)
+       ecophyscon%b_fix           = b_fix(m)
+       ecophyscon%c_fix           = c_fix(m)
+       ecophyscon%s_fix           = s_fix(m)
+       ecophyscon%akc_active      = akc_active(m)
+       ecophyscon%akn_active      = akn_active(m)
+       ecophyscon%akcp_active     = akcp_active(m)
+       ecophyscon%akp_active      = akp_active(m)
+       ecophyscon%ekc_active      = ekc_active(m)
+       ecophyscon%ekn_active      = ekn_active(m)
+       ecophyscon%ekcp_active     = ekcp_active(m)
+       ecophyscon%ekp_active      = ekp_active(m)
+       ecophyscon%kc_nonmyc       = kc_nonmyc(m)
+       ecophyscon%kn_nonmyc       = kn_nonmyc(m)
+       ecophyscon%kcp_nonmyc      = kcp_nonmyc(m)
+       ecophyscon%kp_nonmyc       = kp_nonmyc(m)
+       ecophyscon%kr_resorb       = kr_resorb(m)
+       ecophyscon%krp_resorb      = krp_resorb(m)
+
+       ecophyscon%fun_cn_flex_a   = fun_cn_flex_a(m)
+       ecophyscon%fun_cn_flex_b   = fun_cn_flex_b(m)
+       ecophyscon%fun_cn_flex_c   = fun_cn_flex_c(m)
+       ecophyscon%fun_cp_flex_a   = fun_cp_flex_a(m)
+       ecophyscon%fun_cp_flex_b   = fun_cp_flex_b(m)
+       ecophyscon%fun_cp_flex_c   = fun_cp_flex_c(m)
+       ecophyscon%FUN_fracfixers  = FUN_fracfixers(m)
+
+
     end do
 
     do m = 0,numpft
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/external_models/sbetr/src/stub_clm/pftvarcon.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/external_models/sbetr/src/stub_clm/pftvarcon.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/external_models/sbetr/src/stub_clm/pftvarcon.F90	2020-06-10 13:58:03.372946324 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/external_models/sbetr/src/stub_clm/pftvarcon.F90	2020-06-23 19:53:50.996580475 -0400
@@ -208,6 +208,35 @@
   real(r8), allocatable :: frootcp_obs(:)      !fine root C:P (gC/gP)
   real(r8), allocatable :: livewdcp_obs(:)     !live wood (phloem and ray parenchyma) C:P (gC/gP)
   real(r8), allocatable :: deadwdcp_obs(:)     !dead wood (xylem and heartwood) C:P (gC/gP)
+  real(r8), allocatable :: perecm(:)     !The fraction of ECM-associated PFT 
+  ! pft parameters for FUN
+  real(r8), allocatable :: a_fix         (:)   ! A BNF parameter
+  real(r8), allocatable :: b_fix         (:)   ! A BNF parameter
+  real(r8), allocatable :: c_fix         (:)   ! A BNF parameter
+  real(r8), allocatable :: s_fix         (:)   ! A BNF parameter
+  real(r8), allocatable :: akc_active    (:)   ! A mycorrhizal uptake parameter
+  real(r8), allocatable :: akn_active    (:)   ! A mycorrhizal uptake parameter
+  real(r8), allocatable :: akcp_active   (:)   ! A mycorrhizal uptake parameter
+  real(r8), allocatable :: akp_active    (:)   ! A mycorrhizal uptake parameter
+  real(r8), allocatable :: ekc_active    (:)   ! A mycorrhizal uptake parameter
+  real(r8), allocatable :: ekn_active    (:)   ! A mycorrhizal uptake parameter
+  real(r8), allocatable :: ekcp_active   (:)   ! A mycorrhizal uptake parameter
+  real(r8), allocatable :: ekp_active    (:)   ! A mycorrhizal uptake parameter
+  real(r8), allocatable :: kc_nonmyc     (:)   ! A non-mycorrhizal uptake parameter
+  real(r8), allocatable :: kn_nonmyc     (:)   ! A non-mycorrhizal uptake parameter
+  real(r8), allocatable :: kcp_nonmyc    (:)   ! A non-mycorrhizal uptake parameter
+  real(r8), allocatable :: kp_nonmyc     (:)   ! A non-mycorrhizal uptake parameter
+  real(r8), allocatable :: kr_resorb     (:)   ! A retrasnlcation parameter
+  real(r8), allocatable :: krp_resorb    (:)   ! A retrasnlcation parameter
+  
+  real(r8), allocatable :: fun_cn_flex_a (:)   ! Parameter a of FUN-flexcn link code (def 5)
+  real(r8), allocatable :: fun_cn_flex_b (:)   ! Parameter b of FUN-flexcn link code (def 200)
+  real(r8), allocatable :: fun_cn_flex_c (:)   ! Parameter b of FUN-flexcn link code (def 80)    
+  real(r8), allocatable :: fun_cp_flex_a (:)   ! Parameter a of FUNP-flexcp link code (def 5)
+  real(r8), allocatable :: fun_cp_flex_b (:)   ! Parameter b of FUNP-flexcp link code (def 200)
+  real(r8), allocatable :: fun_cp_flex_c (:)   ! Parameter b of FUNP-flexcp link code (def 80)
+  real(r8), allocatable :: FUN_fracfixers(:)   ! Fraction of C that can be used for fixation.    
+
 
   !
   ! !PUBLIC MEMBER FUNCTIONS:
@@ -420,6 +449,34 @@
     allocate( livewdcp_obs       (0:mxpft) )
     allocate( deadwdcp_obs       (0:mxpft) )
 
+    ! pft parameters for FUN
+    allocate( a_fix              (0:mxpft) )
+    allocate( b_fix              (0:mxpft) )
+    allocate( c_fix              (0:mxpft) )
+    allocate( s_fix              (0:mxpft) )
+    allocate( akc_active         (0:mxpft) )
+    allocate( akn_active         (0:mxpft) )
+    allocate( akcp_active        (0:mxpft) )
+    allocate( akp_active         (0:mxpft) )
+    allocate( ekc_active         (0:mxpft) )
+    allocate( ekn_active         (0:mxpft) ) 
+    allocate( ekcp_active        (0:mxpft) ) 
+    allocate( ekp_active         (0:mxpft) )
+    allocate( kc_nonmyc          (0:mxpft) )
+    allocate( kn_nonmyc          (0:mxpft) )
+    allocate( kcp_nonmyc         (0:mxpft) )
+    allocate( kp_nonmyc          (0:mxpft) )
+    allocate( kr_resorb          (0:mxpft) )
+    allocate( krp_resorb         (0:mxpft) )
+    allocate( perecm             (0:mxpft) )
+    allocate( fun_cn_flex_a      (0:mxpft) )
+    allocate( fun_cn_flex_b      (0:mxpft) )
+    allocate( fun_cn_flex_c      (0:mxpft) )
+    allocate( fun_cp_flex_a      (0:mxpft) )
+    allocate( fun_cp_flex_b      (0:mxpft) )
+    allocate( fun_cp_flex_c      (0:mxpft) )
+    allocate( FUN_fracfixers     (0:mxpft) )
+
 
     noveg  = 1
 
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/clm_driver.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/clm_driver.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/clm_driver.F90	2020-06-10 13:57:17.340178651 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/clm_driver.F90	2020-05-10 20:09:51.900087840 -0400
@@ -16,6 +16,7 @@
   use clm_varctl             , only : wrtdia, iulog, create_glacier_mec_landunit, use_fates, use_betr  
   use clm_varctl             , only : use_cn, use_lch4, use_voc, use_noio, use_c13, use_c14
   use clm_varctl             , only : use_erosion
+  use clm_varctl             , only : use_fun
   use clm_time_manager       , only : get_step_size, get_curr_date, get_ref_date, get_nstep, is_beg_curr_day, get_curr_time_string
   use clm_varpar             , only : nlevsno, nlevgrnd, crop_prog
   use spmdMod                , only : masterproc, mpicom
@@ -78,6 +79,8 @@
   use DUSTMod                , only : DustDryDep, DustEmission
   use VOCEmissionMod         , only : VOCEmission
   use FatesBGCDynMod         , only : FatesBGCDyn
+  !! add varibles needed for FUN - R. Braghiere
+  use CNFUNMod               , only : CNFUN, CNFUNInit
   !
   use filterMod              , only : setFilters
   !
@@ -950,6 +953,7 @@
              call EcosystemDynNoLeaching1(bounds_clump,                               &
                        filter(nc)%num_soilc, filter(nc)%soilc,                          &
                        filter(nc)%num_soilp, filter(nc)%soilp,                          &
+                       filter(nc)%num_pcropp, filter(nc)%pcropp, doalb,                         &
                        cnstate_vars, carbonflux_vars, carbonstate_vars,                 &
                        c13_carbonflux_vars,                                             &
                        c14_carbonflux_vars,                                             &
@@ -1012,7 +1016,9 @@
                            cnstate_vars, ch4_vars,                              &
                            carbonstate_vars, carbonflux_vars,                   &
                            nitrogenstate_vars, nitrogenflux_vars,               &
-                           phosphorusstate_vars,phosphorusflux_vars)
+                           phosphorusstate_vars,phosphorusflux_vars,   &
+                c13_carbonflux_vars, c14_carbonflux_vars,   &
+                crop_vars, soilhydrology_vars, waterflux_vars)
 
                     ! STEP-3: update CLM from clm_interface_data
                     call update_bgc_data_clm2clm(clm_interface_data%bgc,        &
@@ -1393,6 +1399,8 @@
        call top_af%UpdateAccVars(bounds_proc)
        
        call veg_es%UpdateAccVars(bounds_proc)
+
+       call col_wf%UpdateAccVars(bounds_proc)
        
        call canopystate_vars%UpdateAccVars(bounds_proc)
        
@@ -1401,6 +1409,9 @@
        end if
 
        call cnstate_vars%UpdateAccVars(bounds_proc)
+
+       !call waterflux_vars%UpdateAccVars(bounds_proc)
+
        
        call t_stopf('accum')
 
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/clm_initializeMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/clm_initializeMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/clm_initializeMod.F90	2020-06-10 13:57:17.344178631 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/clm_initializeMod.F90	2020-05-10 20:09:51.887087915 -0400
@@ -631,6 +631,8 @@
 
     call veg_es%InitAccBuffer(bounds_proc)
 
+    call col_wf%InitAccBuffer(bounds_proc)
+
     call canopystate_vars%initAccBuffer(bounds_proc)
 
     if (crop_prog) then
@@ -639,6 +641,8 @@
 
     call cnstate_vars%initAccBuffer(bounds_proc)
 
+    !call waterflux_vars%initAccBuffer(bounds_proc)
+
     call print_accum_fields()
 
     call t_stopf('init_accflds')
@@ -846,11 +850,13 @@
     call top_as%InitAccVars(bounds_proc)
     call top_af%InitAccVars(bounds_proc)
     call veg_es%InitAccVars(bounds_proc)
+    call col_wf%InitAccVars(bounds_proc)
     call canopystate_vars%initAccVars(bounds_proc)
     if (crop_prog) then
        call crop_vars%initAccVars(bounds_proc)
     end if
     call cnstate_vars%initAccVars(bounds_proc)
+    !call waterflux_vars%initAccVars(bounds_proc)
 
     !------------------------------------------------------------       
     ! Read monthly vegetation
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/clm_interface_bgcType.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/clm_interface_bgcType.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/clm_interface_bgcType.F90	2020-06-10 13:56:35.767388469 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/clm_interface_bgcType.F90	2020-05-10 20:09:51.885087927 -0400
@@ -96,13 +96,22 @@
      real(r8), pointer :: smin_no3_to_plant_vr_col                  (:,:)   ! col vertically-resolved plant uptake of soil NO3 (gN/m3/s)
      real(r8), pointer :: smin_nh4_to_plant_vr_col                  (:,:)   ! col vertically-resolved plant uptake of soil NH4 (gN/m3/s)
 
+        !!!FUN
+        real(r8), pointer :: sminn_to_plant_fun_vr_col             (:,:)    !col vertically-resolved FUN plant uptake of soil mineral N (gN/m3/s)
+        real(r8), pointer :: sminn_to_plant_fun_no3_vr_col         (:,:)    !col vertically-resolved FUN plant uptake of soil NO3 (gN/m3/s)
+        real(r8), pointer :: sminn_to_plant_fun_nh4_vr_col         (:,:)    !col vertically-resolved FUN plant uptake of soil NH4 (gN/m3/s)
+
+
      real(r8), pointer :: potential_immob_col                       (:)     ! col vert-int (diagnostic) potential N immobilization (gN/m2/s)
      real(r8), pointer :: actual_immob_col                          (:)     ! col vert-int (diagnostic) actual N immobilization (gN/m2/s)
      real(r8), pointer :: sminn_to_plant_col                        (:)     ! col vert-int (diagnostic) plant uptake of soil mineral N (gN/m2/s)
+     real(r8), pointer :: sminn_to_plant_fun_col                    (:)     ! col vert-int (diagnostic) plant uptake of soil mineral N (gN/m2/s)
+
 
      real(r8), pointer :: potential_immob_p_vr_col                  (:,:)   ! col vertically-resolved potential P immobilization (gP/m3/s) at each level
      real(r8), pointer :: actual_immob_p_vr_col                     (:,:)   ! col vertically-resolved actual P immobilization (gP/m3/s) at each level
      real(r8), pointer :: sminp_to_plant_vr_col                     (:,:)   ! col vertically-resolved plant uptake of soil mineral P (gP/m3/s)
+     real(r8), pointer :: sminp_to_plant_fun_vr_col                 (:,:)   ! col vertically-resolved plant uptake of soil mineral P (gP/m3/s)
      real(r8), pointer :: supplement_to_sminp_vr_col                (:,:)   ! col vertically-resolved supplemental P supply (gP/m3/s)
      
      real(r8), pointer :: gross_pmin_vr_col                         (:,:)   ! col vertically-resolved gross rate of P mineralization (gP/m3/s)
@@ -111,7 +120,9 @@
      real(r8), pointer :: potential_immob_p_col                     (:)     ! col vert-int (diagnostic) potential P immobilization (gP/m2/s)
      real(r8), pointer :: actual_immob_p_col                        (:)     ! col vert-int (diagnostic) actual P immobilization (gP/m2/s)
      real(r8), pointer :: sminp_to_plant_col                        (:)     ! col vert-int (diagnostic) plant uptake of soil mineral P (gP/m2/s)
-     
+     real(r8), pointer :: sminp_to_plant_fun_col                    (:)     ! col vert-int (diagnostic) plant uptake of soil mineral P (gP/m2/s)
+    
+ 
      ! nitrification / denitrification flux:
      real(r8), pointer :: f_nit_vr_col                              (:,:)   ! col (gN/m3/s) soil nitrification flux
      real(r8), pointer :: f_denit_vr_col                            (:,:)   ! col (gN/m3/s) soil denitrification flux
@@ -330,11 +341,18 @@
     allocate(this%actual_immob_nh4_vr_col   (begc:endc,1:nlevdecomp_full))  ; this%actual_immob_nh4_vr_col      (:,:) = ival
 
     allocate(this%sminn_to_plant_vr_col     (begc:endc,1:nlevdecomp_full))  ; this%sminn_to_plant_vr_col        (:,:) = ival
+
     allocate(this%smin_no3_to_plant_vr_col  (begc:endc,1:nlevdecomp_full))  ; this%smin_no3_to_plant_vr_col     (:,:) = ival
     allocate(this%smin_nh4_to_plant_vr_col  (begc:endc,1:nlevdecomp_full))  ; this%smin_nh4_to_plant_vr_col     (:,:) = ival
+    !!!FUN
+    allocate(this%sminn_to_plant_fun_vr_col     (begc:endc,1:nlevdecomp_full))  ; this%sminn_to_plant_fun_vr_col        (:,:) = ival
+    allocate(this%sminn_to_plant_fun_no3_vr_col  (begc:endc,1:nlevdecomp_full))  ; this%sminn_to_plant_fun_no3_vr_col     (:,:) = ival
+    allocate(this%sminn_to_plant_fun_nh4_vr_col  (begc:endc,1:nlevdecomp_full))  ; this%sminn_to_plant_fun_nh4_vr_col     (:,:) = ival
+    !!!!!
     allocate(this%supplement_to_sminn_vr_col(begc:endc,1:nlevdecomp_full))  ; this%supplement_to_sminn_vr_col   (:,:) = ival
 
     allocate(this%sminn_to_plant_col        (begc:endc))                    ; this%sminn_to_plant_col           (:)   = ival
+    allocate(this%sminn_to_plant_fun_col    (begc:endc))                    ; this%sminn_to_plant_fun_col       (:)   = ival
     allocate(this%potential_immob_col       (begc:endc))                    ; this%potential_immob_col          (:)   = ival
     allocate(this%actual_immob_col          (begc:endc))                    ; this%actual_immob_col             (:)   = ival
 
@@ -344,9 +362,12 @@
     allocate(this%potential_immob_p_vr_col  (begc:endc,1:nlevdecomp_full))  ; this%potential_immob_p_vr_col     (:,:) = ival
     allocate(this%actual_immob_p_vr_col     (begc:endc,1:nlevdecomp_full))  ; this%actual_immob_p_vr_col        (:,:) = ival
     allocate(this%sminp_to_plant_vr_col     (begc:endc,1:nlevdecomp_full))  ; this%sminp_to_plant_vr_col        (:,:) = ival
+    allocate(this%sminp_to_plant_fun_vr_col (begc:endc,1:nlevdecomp_full))  ; this%sminp_to_plant_vr_col        (:,:) = ival
     allocate(this%supplement_to_sminp_vr_col(begc:endc,1:nlevdecomp_full))  ; this%supplement_to_sminp_vr_col   (:,:) = ival
 
     allocate(this%sminp_to_plant_col        (begc:endc))                    ; this%sminp_to_plant_col           (:)   = ival
+    allocate(this%sminp_to_plant_fun_col    (begc:endc))                    ; this%sminp_to_plant_fun_col       (:)   = ival
+
     allocate(this%potential_immob_p_col     (begc:endc))                    ; this%potential_immob_p_col        (:)   = ival
     allocate(this%actual_immob_p_col        (begc:endc))                    ; this%actual_immob_p_col           (:)   = ival
 
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/clm_interface_funcsMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/clm_interface_funcsMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/clm_interface_funcsMod.F90	2020-06-10 13:56:35.772388444 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/clm_interface_funcsMod.F90	2020-05-10 20:09:51.840088189 -0400
@@ -75,7 +75,7 @@
 
   ! misc.
   use abortutils            , only : endrun
-  use clm_varctl            , only : nu_com
+  use clm_varctl            , only : nu_com, use_fun
   !--------------------------------------------------------------------------------------
 
   implicit none
@@ -651,6 +651,7 @@
       ! inorg. nitrogen source
       ndep_to_sminn                    => col_nf%ndep_to_sminn                   , &
       nfix_to_sminn                    => col_nf%nfix_to_sminn                   , &
+      ffix_to_sminn                    => col_nf%ffix_to_sminn                   , &
       fert_to_sminn                    => col_nf%fert_to_sminn                   , &
       soyfixn_to_sminn                 => col_nf%soyfixn_to_sminn                , &
       supplement_to_sminn_vr           => col_nf%supplement_to_sminn_vr          , &
@@ -720,6 +721,12 @@
                                                            nfix_to_sminn(c) * nfixation_prof(c,:) +      &
                                                            soyfixn_to_sminn(c) * nfixation_prof(c,:)
 
+       if(use_fun)then
+        clm_bgc_data%externaln_to_nh4_col(c,:)          = &
+        clm_bgc_data%externaln_to_nh4_col(c,:)          + &
+        ffix_to_sminn(c) * nfixation_prof(c,:)
+       end if
+
        clm_bgc_data%externaln_to_no3_col(c,:)          =   (1._r8-fnh4_dep)*ndep_to_sminn(c) * ndep_prof(c, :) +  &
                                                            (1._r8-fnh4_fert)*fert_to_sminn(c) * ndep_prof(c, :) + &
                                                            (1._r8-fnh4_fert)*supplement_to_sminn_vr(c,:)
@@ -1111,10 +1118,15 @@
      potential_immob              => col_nf%potential_immob           , & ! Output: [real(r8) (:)   ]
      actual_immob                 => col_nf%actual_immob              , & ! Output: [real(r8) (:)   ]
      sminn_to_plant               => col_nf%sminn_to_plant            , & ! Output: [real(r8) (:)   ]
-
+     sminn_to_plant_fun           => col_nf%sminn_to_plant_fun        , & ! Output: [real(r8) (:)   ]
      sminn_to_plant_vr            => col_nf%sminn_to_plant_vr         , &
      smin_no3_to_plant_vr         => col_nf%smin_no3_to_plant_vr      , &
      smin_nh4_to_plant_vr         => col_nf%smin_nh4_to_plant_vr      , &
+     !!!!FUN variables   
+     sminn_to_plant_fun_vr        => col_nf%sminn_to_plant_fun_vr         , &
+     sminn_to_plant_fun_no3_vr    => col_nf%sminn_to_plant_fun_no3_vr      , &
+     sminn_to_plant_fun_nh4_vr         => col_nf%sminn_to_plant_fun_nh4_vr      , &
+     !!!!!
      potential_immob_vr           => col_nf%potential_immob_vr        , &
      actual_immob_vr              => col_nf%actual_immob_vr           , &
      actual_immob_no3_vr          => col_nf%actual_immob_no3_vr       , & ! Output: [real(r8) (:,:) ]
@@ -1131,10 +1143,12 @@
      potential_immob_p            => col_pf%potential_immob_p       , & ! Output: [real(r8) (:)   ]
      actual_immob_p               => col_pf%actual_immob_p          , & ! Output: [real(r8) (:)   ]
      sminp_to_plant               => col_pf%sminp_to_plant          , & ! Output: [real(r8) (:)   ]
-
+     sminp_to_plant_fun           => col_pf%sminp_to_plant_fun      , & ! Output: [real(r8) (:)   ]
      supplement_to_sminp_vr       => col_pf%supplement_to_sminp_vr  , & ! Output: [real(r8) (:,:) ]
 
      sminp_to_plant_vr            => col_pf%sminp_to_plant_vr       , &
+     !FUN
+     sminp_to_plant_fun_vr        => col_pf%sminp_to_plant_vr       , &
      potential_immob_p_vr         => col_pf%potential_immob_p_vr    , & ! Output: [real(r8) (:,:)   ]
      actual_immob_p_vr            => col_pf%actual_immob_p_vr       , &
      gross_pmin_vr                => col_pf%gross_pmin_vr           , & ! Output: [real(r8) (:,:)   ]
@@ -1152,10 +1166,12 @@
         potential_immob(c)  = clm_bgc_data%potential_immob_col(c)
         actual_immob(c)     = clm_bgc_data%actual_immob_col(c)
         sminn_to_plant(c)   = clm_bgc_data%sminn_to_plant_col(c)
+        sminn_to_plant_fun(c)   = clm_bgc_data%sminn_to_plant_fun_col(c)
 
         potential_immob_p(c)  = clm_bgc_data%potential_immob_p_col(c)
         actual_immob_p(c)     = clm_bgc_data%actual_immob_p_col(c)
         sminp_to_plant(c)     = clm_bgc_data%sminp_to_plant_col(c)
+        sminp_to_plant_fun(c) = clm_bgc_data%sminp_to_plant_fun_col(c)
 
         fpi_vr(c,:)                 = clm_bgc_data%fpi_vr_col(c,:)
         fpi_p_vr(c,:)               = clm_bgc_data%fpi_p_vr_col(c,:)
@@ -1163,6 +1179,10 @@
         sminn_to_plant_vr(c,:)      = clm_bgc_data%sminn_to_plant_vr_col(c,:)
         smin_no3_to_plant_vr(c,:)   = clm_bgc_data%smin_no3_to_plant_vr_col(c,:)
         smin_nh4_to_plant_vr(c,:)   = clm_bgc_data%smin_nh4_to_plant_vr_col(c,:)
+        !!!FUN 
+        sminn_to_plant_fun_vr(c,:)      = clm_bgc_data%sminn_to_plant_fun_vr_col(c,:)
+        sminn_to_plant_fun_no3_vr(c,:)   = clm_bgc_data%sminn_to_plant_fun_no3_vr_col(c,:)
+        sminn_to_plant_fun_nh4_vr(c,:)   = clm_bgc_data%sminn_to_plant_fun_nh4_vr_col(c,:)
 
         potential_immob_vr(c,:)     = clm_bgc_data%potential_immob_vr_col(c,:)
         actual_immob_vr(c,:)        = clm_bgc_data%actual_immob_vr_col(c,:)
@@ -1180,6 +1200,7 @@
         supplement_to_sminp_vr(c,:) = clm_bgc_data%supplement_to_sminp_vr_col(c,:)
 
         sminp_to_plant_vr(c,:)      = clm_bgc_data%sminp_to_plant_vr_col(c,:)
+        sminp_to_plant_fun_vr(c,:)      = clm_bgc_data%sminp_to_plant_fun_vr_col(c,:)
         potential_immob_p_vr(c,:)   = clm_bgc_data%potential_immob_p_vr_col(c,:)
         actual_immob_p_vr(c,:)      = clm_bgc_data%actual_immob_p_vr_col(c,:)
         gross_pmin_vr(c,:)          = clm_bgc_data%gross_pmin_vr_col(c,:)
@@ -1356,7 +1377,9 @@
                 cnstate_vars, ch4_vars,                     &
                 carbonstate_vars, carbonflux_vars,          &
                 nitrogenstate_vars, nitrogenflux_vars,      &
-                phosphorusstate_vars,phosphorusflux_vars)
+                phosphorusstate_vars,phosphorusflux_vars,   &
+                c13_carbonflux_vars, c14_carbonflux_vars,   &
+                crop_vars, soilhydrology_vars, waterflux_vars)
 
     ! USES:
     use SoilLittDecompMod          , only: SoilLittDecompAlloc
@@ -1382,6 +1405,14 @@
 
     type(clm_interface_data_type)       , intent(inout) :: clm_interface_data
 
+    !! add varibles needed for FUN
+    type(crop_type)          , intent(inout) :: crop_vars
+    type(carbonflux_type)    , intent(inout) :: c13_carbonflux_vars
+    type(carbonflux_type)    , intent(inout) :: c14_carbonflux_vars
+    type(soilhydrology_type) , intent(in)    :: soilhydrology_vars
+    type(waterflux_type)     , intent(in)    :: waterflux_vars
+
+
     !-------------------------------------------------------------
     ! STEP-2: (i) pass data from clm_bgc_data to SoilLittDecompAlloc
     call clm_bgc_get_data(clm_interface_data, bounds,       &
@@ -1401,7 +1432,9 @@
                cnstate_vars, ch4_vars,                      &
                carbonstate_vars, carbonflux_vars,           &
                nitrogenstate_vars, nitrogenflux_vars,       &
-               phosphorusstate_vars,phosphorusflux_vars)
+               phosphorusstate_vars,phosphorusflux_vars,    &
+               c13_carbonflux_vars, c14_carbonflux_vars,    &
+               crop_vars, soilhydrology_vars, waterflux_vars)
 
     ! STEP-2: (iii) update clm_bgc_data from SoilLittDecompAlloc
     call clm_bgc_update_data(clm_interface_data%bgc, bounds, &
@@ -1589,6 +1622,7 @@
          potential_immob              => col_nf%potential_immob                          , & ! Output: [real(r8) (:)   ]
          actual_immob                 => col_nf%actual_immob                             , & ! Output: [real(r8) (:)   ]
          sminn_to_plant               => col_nf%sminn_to_plant                           , & ! Output: [real(r8) (:)   ]
+         sminn_to_plant_fun           => col_nf%sminn_to_plant_fun                       , & ! Output: [real(r8) (:)   ]
          sminn_to_denit_excess_vr     => col_nf%sminn_to_denit_excess_vr                 , & ! Output: [real(r8) (:,:) ]
          pot_f_nit_vr                 => col_nf%pot_f_nit_vr                             , & ! Output: [real(r8) (:,:) ]  (gN/m3/s) potential soil nitrification flux
          pot_f_denit_vr               => col_nf%pot_f_denit_vr                           , & ! Output: [real(r8) (:,:) ]  (gN/m3/s) potential soil denitrification flux
@@ -1603,13 +1637,21 @@
          f_n2o_nit_vr                 => col_nf%f_n2o_nit_vr                             , & ! Output: [real(r8) (:,:) ]  flux of N2O from nitrification [gN/m3/s]
          supplement_to_sminn_vr       => col_nf%supplement_to_sminn_vr                   , & ! Output: [real(r8) (:,:) ]
          sminn_to_plant_vr            => col_nf%sminn_to_plant_vr                        , & ! Output: [real(r8) (:,:) ]
+         sminn_to_plant_fun_vr        => col_nf%sminn_to_plant_fun_vr                    , & ! Output: [real(r8) (:,:) ]
+         sminn_to_plant_fun_no3_vr    => col_nf%sminn_to_plant_fun_no3_vr                , & ! Output: [real(r8) (:,:) ]
+         sminn_to_plant_fun_nh4_vr    => col_nf%sminn_to_plant_fun_nh4_vr                , & ! Output: [real(r8) (:,:) ]
+
          actual_immob_vr              => col_nf%actual_immob_vr                          , & ! Output: [real(r8) (:,:) ]
 
          potential_immob_p            => col_pf%potential_immob_p                      , & ! Output: [real(r8) (:)   ]
          actual_immob_p               => col_pf%actual_immob_p                         , & ! Output: [real(r8) (:)   ]
          sminp_to_plant               => col_pf%sminp_to_plant                         , & ! Output: [real(r8) (:)   ]
+         sminp_to_plant_fun           => col_pf%sminp_to_plant_fun                     , & ! Output: [real(r8) (:)   ]
+
          supplement_to_sminp_vr       => col_pf%supplement_to_sminp_vr                 , & ! Output: [real(r8) (:,:) ]
          sminp_to_plant_vr            => col_pf%sminp_to_plant_vr                      , & ! Output: [real(r8) (:,:) ]
+         sminp_to_plant_fun_vr        => col_pf%sminp_to_plant_fun_vr                      , & ! Output: [real(r8) (:,:) ]
+
          actual_immob_p_vr            => col_pf%actual_immob_p_vr                      , & ! Output: [real(r8) (:,:) ]
 
          decomp_cascade_ntransfer_vr      =>    col_nf%decomp_cascade_ntransfer_vr       , & ! Output: [real(r8) (:,:,:) ]  vert-res transfer of N from donor to receiver pool along decomp. cascade (gN/m3/s)
@@ -1648,6 +1690,7 @@
             clm_bgc_data%potential_immob_col(c)                       = potential_immob(c)
             clm_bgc_data%actual_immob_col(c)                          = actual_immob(c)
             clm_bgc_data%sminn_to_plant_col(c)                        = sminn_to_plant(c)
+            clm_bgc_data%sminn_to_plant_fun_col(c)                    = sminn_to_plant_fun(c)
             clm_bgc_data%sminn_to_denit_excess_vr_col(c,:)            = sminn_to_denit_excess_vr(c,:)
             clm_bgc_data%pot_f_nit_vr_col(c,:)                        = pot_f_nit_vr(c,:)
             clm_bgc_data%pot_f_denit_vr_col(c,:)                      = pot_f_denit_vr(c,:)
@@ -1662,13 +1705,21 @@
             clm_bgc_data%f_n2o_nit_vr_col(c,:)                        = f_n2o_nit_vr(c,:)
             clm_bgc_data%supplement_to_sminn_vr_col(c,:)              = supplement_to_sminn_vr(c,:)
             clm_bgc_data%sminn_to_plant_vr_col(c,:)                   = sminn_to_plant_vr(c,:)
+           !!!FUN
+            clm_bgc_data%sminn_to_plant_fun_vr_col(c,:)               = sminn_to_plant_fun_vr(c,:)
+            clm_bgc_data%sminn_to_plant_fun_no3_vr_col(c,:)                   = sminn_to_plant_fun_no3_vr(c,:)
+            clm_bgc_data%sminn_to_plant_fun_nh4_vr_col(c,:)                   = sminn_to_plant_fun_nh4_vr(c,:)
+
             clm_bgc_data%potential_immob_vr_col(c,:)                  = potential_immob_vr(c,:)
             clm_bgc_data%actual_immob_vr_col(c,:)                     = actual_immob_vr(c,:)
             clm_bgc_data%potential_immob_p_col(c)                     = potential_immob_p(c)
             clm_bgc_data%actual_immob_p_col(c)                        = actual_immob_p(c)
             clm_bgc_data%sminp_to_plant_col(c)                        = sminp_to_plant(c)
+            clm_bgc_data%sminp_to_plant_fun_col(c)                    = sminp_to_plant_fun(c)
             clm_bgc_data%supplement_to_sminp_vr_col(c,:)              = supplement_to_sminp_vr(c,:)
             clm_bgc_data%sminp_to_plant_vr_col(c,:)                   = sminp_to_plant_vr(c,:)
+            !!!FUN
+            clm_bgc_data%sminp_to_plant_fun_vr_col(c,:)               = sminp_to_plant_fun_vr(c,:)
             clm_bgc_data%potential_immob_p_vr_col(c,:)                = potential_immob_p_vr(c,:)
             clm_bgc_data%actual_immob_p_vr_col(c,:)                   = actual_immob_p_vr(c,:)
 
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/clm_interface_pflotranMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/clm_interface_pflotranMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/clm_interface_pflotranMod.F90	2020-06-10 13:56:35.777388418 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/clm_interface_pflotranMod.F90	2020-05-10 20:09:51.964087467 -0400
@@ -45,6 +45,7 @@
   use filterMod    , only : clumpfilter
   use abortutils   , only : endrun
   use shr_log_mod  , only : errMsg => shr_log_errMsg
+  use clm_varctl   , only : use_fun
 
   ! currently only works with soil columns, i.e. luntype of 'istsoil/istcrop'
   !  use landunit_varcon     , only : istsoil, istcrop
@@ -3709,6 +3710,11 @@
      decomp_npools_delta_vr       => clm_interface_data%bgc%decomp_npools_sourcesink_col  , &
 
      sminn_to_plant_vr            => clm_interface_data%bgc%sminn_to_plant_vr_col         , &
+     !!!FUN module variables
+     sminn_to_plant_fun_vr            => clm_interface_data%bgc%sminn_to_plant_fun_vr_col         , &
+     sminn_to_plant_fun_no3_vr            => clm_interface_data%bgc%sminn_to_plant_fun_no3_vr_col         , &
+     sminn_to_plant_fun_nh4_vr            => clm_interface_data%bgc%sminn_to_plant_fun_nh4_vr_col         , &
+     !!!!
      smin_no3_to_plant_vr         => clm_interface_data%bgc%smin_no3_to_plant_vr_col      , &
      smin_nh4_to_plant_vr         => clm_interface_data%bgc%smin_nh4_to_plant_vr_col      , &
      potential_immob_vr           => clm_interface_data%bgc%potential_immob_vr_col        , &
@@ -3870,7 +3876,10 @@
               smin_no3_to_plant_vr(c,j) = (accextrno3_vr_clm_loc(cellcount)  &
                           * clm_pf_idata%N_molecular_weight)/dtime
               sminn_to_plant_vr(c,j) = smin_nh4_to_plant_vr(c,j) + smin_no3_to_plant_vr(c,j)
-
+              !!!!FUN module eq.
+              if(use_fun)then
+              sminn_to_plant_fun_vr(c,j) = sminn_to_plant_fun_nh4_vr(c,j) + sminn_to_plant_fun_no3_vr(c,j)
+              end if
           else    ! just in case 'clm_pf_idata%nzclm_mapped<nlevdcomp_full', all set to ZERO (different from TH)
 
               do k=1, ndecomp_pools
@@ -3881,6 +3890,9 @@
               smin_nh4_to_plant_vr(c,j)  = 0._r8
               smin_no3_to_plant_vr(c,j)  = 0._r8
               sminn_to_plant_vr(c,j)     = 0._r8
+              sminn_to_plant_fun_vr(c,j) = 0._r8
+              sminn_to_plant_fun_no3_vr(c,j) = 0._r8
+              sminn_to_plant_fun_nh4_vr(c,j) = 0._r8
               gross_nmin_vr(c,j)         = 0._r8
               potential_immob_vr(c,j)    = 0._r8
               actual_immob_vr(c,j)       = 0._r8
@@ -4713,7 +4725,10 @@
          f_ngas_nitri_vr              => clm_interface_data%bgc%f_ngas_nitri_vr_col           , &
          f_ngas_denit_vr              => clm_interface_data%bgc%f_ngas_denit_vr_col           , &
          sminn_to_plant_vr            => clm_interface_data%bgc%sminn_to_plant_vr_col         , &
-
+         !!!!FUN module variables
+         sminn_to_plant_fun_vr        => clm_interface_data%bgc%sminn_to_plant_fun_vr_col     , &
+         sminn_to_plant_fun_no3_vr    => clm_interface_data%bgc%sminn_to_plant_fun_no3_vr_col , &
+         sminn_to_plant_fun_nh4_vr    => clm_interface_data%bgc%sminn_to_plant_fun_nh4_vr_col , &
          plant_ndemand_vr             => clm_interface_data%bgc%plant_ndemand_vr_col          , &
          potential_immob_vr           => clm_interface_data%bgc%potential_immob_vr_col        , &
          actual_immob_vr              => clm_interface_data%bgc%actual_immob_vr_col           , &
@@ -4778,7 +4793,11 @@
             pf_noutputs_nit(fc) = pf_noutputs_nit(fc) + f_ngas_decomp_vr(c,j)*dzsoi_decomp(j) &
                                                       + f_ngas_nitri_vr(c,j)*dzsoi_decomp(j)
             pf_noutputs_denit(fc) = pf_noutputs_denit(fc) + f_ngas_denit_vr(c,j)*dzsoi_decomp(j)
+            if(.not.use_fun)then
             pf_noutputs_veg(fc) = pf_noutputs_veg(fc) + sminn_to_plant_vr(c,j)*dzsoi_decomp(j)
+            else
+            pf_noutputs_veg(fc) = pf_noutputs_veg(fc) + sminn_to_plant_fun_vr(c,j)*dzsoi_decomp(j)
+            end if
 
             pf_ngas_dec(fc)     = pf_ngas_dec(fc)     + f_ngas_decomp_vr(c,j)*dzsoi_decomp(j)
             pf_ngas_min(fc)     = pf_ngas_min(fc)     + f_ngas_denit_vr(c,j)*dzsoi_decomp(j) &
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/clm_varcon.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/clm_varcon.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/clm_varcon.F90	2020-06-10 13:56:35.783388388 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/clm_varcon.F90	2020-05-10 20:09:51.836088213 -0400
@@ -77,6 +77,8 @@
   real(r8), public, parameter :: degpsec = 15._r8/3600.0_r8 ! Degree's earth rotates per second
   real(r8), public, parameter ::  secspday= SHR_CONST_CDAY  ! Seconds per day
   integer,  public, parameter :: isecspday= secspday        ! Integer seconds per day
+  integer, public, parameter  :: fun_period  = 1            ! A FUN parameter, and probably needs to be changed for testing
+  real(r8),public, parameter  :: smallValue  = 1.e-12_r8    ! A small values used by FUN
   real(r8), public, parameter ::  spval = 1.e36_r8          ! special value for real data
   integer , public, parameter :: ispval = -9999             ! special value for int data 
                                                             ! (keep this negative to avoid conflicts with possible valid values)
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/clm_varctl.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/clm_varctl.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/clm_varctl.F90	2020-06-10 13:57:17.347178616 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/clm_varctl.F90	2020-05-10 20:09:51.851088125 -0400
@@ -327,6 +327,8 @@
   logical, public :: use_nofire          = .false.
   logical, public :: use_lch4            = .false.
   logical, public :: use_nitrif_denitrif = .false.
+  logical, public :: use_fun             = .false.
+  logical, public :: use_funp            = .false.
   logical, public :: use_vertsoilc       = .false.
   logical, public :: use_extralakelayers = .false.
   logical, public :: use_vichydro        = .false.
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/controlMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/controlMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/controlMod.F90	2020-06-10 13:57:17.354178580 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/controlMod.F90	2020-05-10 20:09:51.948087560 -0400
@@ -117,6 +117,7 @@
     use shr_string_mod            , only : shr_string_getParentDir
     use clm_interface_pflotranMod , only : clm_pf_readnl
     use ALMBeTRNLMod              , only : betr_readNL
+    use MaintenanceRespMod        , only : MaintenanceRespReadNML
     !
     implicit none
     !
@@ -206,7 +207,7 @@
          perchroot, perchroot_alt
 
     namelist /clm_inparm / &
-         anoxia, anoxia_wtsat
+         anoxia, anoxia_wtsat, use_fun, use_funp
 
     namelist /clm_inparm / &
          deepmixing_depthcrit, deepmixing_mixfact, lake_melt_icealb
@@ -476,6 +477,14 @@
     ! ----------------------------------------------------------------------
 
     call control_spmd()
+
+    ! ----------------------------------------------------------------------
+    ! Read in other namelists that are dependent on other namelist setttings
+    ! ----------------------------------------------------------------------
+
+    !if ( use_fun ) then
+    !   call MaintenanceRespReadNML( NLFilename )
+    !end if
     
     if (use_pflotran) then
        call clm_pf_readnl(NLFilename)
@@ -617,6 +626,8 @@
     call mpi_bcast (use_vancouver, 1, MPI_LOGICAL, 0, mpicom, ier)
     call mpi_bcast (use_mexicocity, 1, MPI_LOGICAL, 0, mpicom, ier)
     call mpi_bcast (use_noio, 1, MPI_LOGICAL, 0, mpicom, ier)
+    call mpi_bcast (use_fun, 1, MPI_LOGICAL, 0, mpicom, ier) 
+    call mpi_bcast (use_funp, 1, MPI_LOGICAL, 0, mpicom, ier)
 
     ! initial file variables
     call mpi_bcast (nrevsn, len(nrevsn), MPI_CHARACTER, 0, mpicom, ier)
@@ -872,6 +883,8 @@
     write(iulog,*) '    use_mexicocity = ', use_mexicocity
     write(iulog,*) '    use_noio = ', use_noio
     write(iulog,*) '    use_betr = ', use_betr
+    write(iulog,*) '    use_fun = ', use_fun
+    write(iulog,*) '    use_funp = ', use_funp
     write(iulog,*) 'input data files:'
     write(iulog,*) '   PFT physiology and parameters file = ',trim(paramfile)
     write(iulog,*) '   Soil order dependent parameters file = ',trim(fsoilordercon)
@@ -918,6 +931,10 @@
           call endrun(msg=' error: spinup_state can only have integer value of 0 or 1'//&
                errMsg(__FILE__, __LINE__))
        end if
+
+       if ( use_fun ) then
+          write(iulog,*) '   Fixation and Uptake of Nitrogen Model Version 2 (FUN2) is turned on for Nitrogen Competition'
+       end if
        
        write(iulog,*) '   override_bgc_restart_mismatch_dump                     : ', override_bgc_restart_mismatch_dump
     end if
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/lnd2atmMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/lnd2atmMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/lnd2atmMod.F90	2020-06-10 13:56:35.841388095 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/lnd2atmMod.F90	2020-07-15 21:09:52.528738541 -0400
@@ -36,6 +36,7 @@
   use ColumnDataType       , only : col_ws, col_wf, col_cf, col_es  
   use VegetationDataType   , only : veg_es, veg_ef, veg_ws, veg_wf
   use SoilHydrologyType    , only : soilhydrology_type 
+  use clm_varctl           , only : use_fun
   
   !
   ! !PUBLIC TYPES:
@@ -358,7 +359,9 @@
        ! TODO temperary treatment in case weird values after c2g
        if(lnd2atm_vars%t_soisno_grc(g, 1) > 400._r8) then
            write(iulog,*)'lnd2atm_vars%t_soisno_grc(g, 1) is',lnd2atm_vars%t_soisno_grc(g, 1)
+           if(.not.use_fun)then
            call endrun( msg=' lnd2atm ERROR: lnd2atm_vars%t_soisno_grc >  400 Kelvin degree.'//errMsg(__FILE__, __LINE__))
+           end if
        end if
        lnd2atm_vars%Tqsur_grc(g) = avg_tsoil_surf(lnd2atm_vars%t_soisno_grc(g,-nlevsno+1:nlevgrnd))
        lnd2atm_vars%Tqsub_grc(g) = avg_tsoil(lnd2atm_vars%zwt_grc(g),lnd2atm_vars%t_soisno_grc(g,-nlevsno+1:nlevgrnd))
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/pftvarcon.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/pftvarcon.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/pftvarcon.F90	2020-06-10 13:56:35.862387989 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/pftvarcon.F90	2020-06-30 21:12:38.084155823 -0400
@@ -265,6 +265,35 @@
   ! Soil erosion ground cover
   real(r8), allocatable :: gcpsi(:)            !bare ground LAI-decay parameter
   real(r8), allocatable :: pftcc(:)            !plant cover reduction factor for transport capacity
+  ! pft parameters for FUN
+  real(r8), allocatable :: perecm(:)   ! The fraction of ECM-associated PFT 
+  real(r8), allocatable :: a_fix(:)   ! A BNF parameter
+  real(r8), allocatable :: b_fix(:)   ! A BNF parameter
+  real(r8), allocatable :: c_fix(:)   ! A BNF parameter
+  real(r8), allocatable :: s_fix(:)   ! A BNF parameter
+  real(r8), allocatable :: akc_active(:)   ! A mycorrhizal uptake parameter
+  real(r8), allocatable :: akn_active(:)   ! A mycorrhizal uptake parameter
+  real(r8), allocatable :: akcp_active(:)   ! A mycorrhizal uptake parameter
+  real(r8), allocatable :: akp_active(:)   ! A mycorrhizal uptake parameter
+  real(r8), allocatable :: ekc_active(:)   ! A mycorrhizal uptake parameter
+  real(r8), allocatable :: ekn_active(:)   ! A mycorrhizal uptake parameter
+  real(r8), allocatable :: ekcp_active(:)   ! A mycorrhizal uptake parameter
+  real(r8), allocatable :: ekp_active(:)   ! A mycorrhizal uptake parameter
+  real(r8), allocatable :: kc_nonmyc(:)   ! A non-mycorrhizal uptake parameter
+  real(r8), allocatable :: kn_nonmyc(:)   ! A non-mycorrhizal uptake parameter
+  real(r8), allocatable :: kcp_nonmyc(:)   ! A non-mycorrhizal uptake parameter
+  real(r8), allocatable :: kp_nonmyc(:)   ! A non-mycorrhizal uptake parameter
+  real(r8), allocatable :: kr_resorb(:)   ! A retrasnlcation parameter
+  real(r8), allocatable :: krp_resorb(:)   ! A retrasnlcation parameter
+  
+  real(r8), allocatable :: fun_cn_flex_a(:)   ! Parameter a of FUN-flexcn link code (def 5)
+  real(r8), allocatable :: fun_cn_flex_b(:)   ! Parameter b of FUN-flexcn link code (def 200)
+  real(r8), allocatable :: fun_cn_flex_c(:)   ! Parameter b of FUN-flexcn link code (def 80)    
+  real(r8), allocatable :: fun_cp_flex_a(:)   ! Parameter a of FUNP-flexcp link code (def 5)
+  real(r8), allocatable :: fun_cp_flex_b(:)   ! Parameter b of FUNP-flexcp link code (def 200)
+  real(r8), allocatable :: fun_cp_flex_c(:)   ! Parameter b of FUNP-flexcp link code (def 80)
+  real(r8), allocatable :: FUN_fracfixers(:)   ! Fraction of C that can be used for fixation.    
+
 
   !
   ! !PUBLIC MEMBER FUNCTIONS:
@@ -348,7 +377,7 @@
     expected_pftnames(24) = 'irrigated_soybean                  '
 
     allocate( dleaf         (0:mxpft) )       
-    allocate( c3psn         (0:mxpft) )       
+    allocate( c3psn         (0:mxpft) )     
     allocate( xl            (0:mxpft) )          
     allocate( rhol          (0:mxpft,numrad) ) 
     allocate( rhos          (0:mxpft,numrad) ) 
@@ -520,6 +549,34 @@
     ! Ground cover for soil erosion
     allocate( gcpsi              (0:mxpft) )
     allocate( pftcc              (0:mxpft) )
+    ! pft parameters for FUN
+    allocate( perecm             (0:mxpft) )
+    allocate( a_fix              (0:mxpft) )
+    allocate( b_fix              (0:mxpft) )
+    allocate( c_fix              (0:mxpft) )
+    allocate( s_fix              (0:mxpft) )
+    allocate( akc_active         (0:mxpft) )
+    allocate( akn_active         (0:mxpft) )
+    allocate( akcp_active        (0:mxpft) )
+    allocate( akp_active         (0:mxpft) )
+    allocate( ekc_active         (0:mxpft) )
+    allocate( ekn_active         (0:mxpft) ) 
+    allocate( ekcp_active        (0:mxpft) ) 
+    allocate( ekp_active         (0:mxpft) )
+    allocate( kc_nonmyc          (0:mxpft) )
+    allocate( kn_nonmyc          (0:mxpft) )
+    allocate( kcp_nonmyc         (0:mxpft) )
+    allocate( kp_nonmyc          (0:mxpft) )
+    allocate( kr_resorb          (0:mxpft) )
+    allocate( krp_resorb         (0:mxpft) )
+    allocate( fun_cn_flex_a      (0:mxpft) )
+    allocate( fun_cn_flex_b      (0:mxpft) )
+    allocate( fun_cn_flex_c      (0:mxpft) )
+    allocate( fun_cp_flex_a      (0:mxpft) )
+    allocate( fun_cp_flex_b      (0:mxpft) )
+    allocate( fun_cp_flex_c      (0:mxpft) )
+    allocate( FUN_fracfixers     (0:mxpft) )
+
 
     ! Set specific vegetation type values
 
@@ -910,6 +967,61 @@
     if ( .not. readv ) gcpsi(:) = 0._r8
     call ncd_io('pftcc',pftcc, 'read', ncid, readvar=readv, posNOTonfile=.true.)
     if ( .not. readv ) pftcc(:) = 1._r8
+   ! pft parameters for FUN
+    call ncd_io('perecm',perecm, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    !if ( .not. readv ) perecm(:) = (/0.01_r8,0.02_r8,0.03_r8,0.04_r8,0.05_r8,0.06_r8,0.07_r8,0.08_r8,0.09_r8,0.10_r8,0.11_r8,0.12_r8,0.13_r8,0.14_r8,0.15_r8,0.16_r8,0.17_r8,0.18_r8,0.19_r8,0.20_r8,0.21_r8,0.22_r8,0.23_r8,0.24_r8,0.25_r8/)
+    call ncd_io('a_fix', a_fix, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('b_fix', b_fix, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('c_fix', c_fix, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('s_fix', s_fix, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('akc_active', akc_active, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('akn_active', akn_active, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('akcp_active', akcp_active, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('akp_active', akp_active, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('ekc_active', ekc_active, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('ekn_active', ekn_active, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('ekcp_active', ekcp_active, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('ekp_active', ekp_active, 'read', ncid, readvar=readv, posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('kc_nonmyc', kc_nonmyc, 'read', ncid, readvar=readv,   posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('kn_nonmyc', kn_nonmyc, 'read', ncid, readvar=readv,   posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('kcp_nonmyc', kcp_nonmyc, 'read', ncid, readvar=readv,   posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('kp_nonmyc', kp_nonmyc, 'read', ncid, readvar=readv,   posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('kr_resorb', kr_resorb, 'read', ncid, readvar=readv,   posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('krp_resorb', krp_resorb, 'read', ncid, readvar=readv,   posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+
+    call ncd_io('fun_cn_flex_a', fun_cn_flex_a, 'read', ncid, readvar=readv,         posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('fun_cn_flex_b', fun_cn_flex_b, 'read', ncid, readvar=readv,         posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('fun_cn_flex_c', fun_cn_flex_c, 'read', ncid, readvar=readv,         posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('fun_cp_flex_a', fun_cp_flex_a, 'read', ncid, readvar=readv,         posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('fun_cp_flex_b', fun_cp_flex_b, 'read', ncid, readvar=readv,         posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('fun_cp_flex_c', fun_cp_flex_c, 'read', ncid, readvar=readv,         posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
+    call ncd_io('FUN_fracfixers', FUN_fracfixers, 'read', ncid, readvar=readv,         posNOTonfile=.true.)
+    if ( .not. readv ) call endrun(msg=' ERROR: error in reading in pft data'//errMsg(__FILE__, __LINE__))
        
     call ncd_io('mergetoclmpft', mergetoclmpft, 'read', ncid, readvar=readv)  
     if ( .not. readv ) then
diff -ruN /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/readParamsMod.F90 /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/readParamsMod.F90
--- /home/braghiere/E3SM_latest/E3SM/components/clm/src/main/readParamsMod.F90	2020-06-10 13:56:35.865387974 -0400
+++ /home/braghiere/models_v3.2/E3SM_global/components/clm/src/main/readParamsMod.F90	2020-05-10 20:09:51.818088318 -0400
@@ -7,6 +7,7 @@
   !
   use clm_varctl   , only: use_cn, use_century_decomp, use_nitrif_denitrif
   use clm_varctl   , only: use_lch4, use_fates
+  use clm_varctl   , only: use_fun
   implicit none
   save
   private
@@ -84,6 +85,7 @@
     use CNPhenologyBeTRMod       , only : readCNPhenolBeTRParams
     use MaintenanceRespMod               , only : readMaintenanceRespParams
     use NitrogenDynamicsMod           , only : readNitrogenDynamicsParams
+    use CNFUNMod                 , only : readParams
     use GapMortalityMod          , only : readGapMortParams 
     use CNGapMortalityBeTRMod    , only : readCNGapMortBeTRParams
     use CNNitrifDenitrifMod      , only : readNitrifDenitrifParams
@@ -158,6 +160,9 @@
          call readPhenolParams(ncid)
        endif
        call readMaintenanceRespParams (ncid)
+       !Variables for FUN
+       call readParams(ncid)
+       !-------------------
        call readNitrogenDynamicsParams (ncid)
        if(is_active_betr_bgc)then
          call readCNGapMortBeTRParams (ncid)
